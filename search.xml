<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[文件夹命名习惯]]></title>
      <url>%2F2018-01-07-name.html</url>
      <content type="text"><![CDATA[常用的项目目录文件命名 config 配置文件 static 静态资源 src,source 源代码 examples，demo 示例 docs 文档 plugins 插件 lib library,库文件 component 组件 dist distribution,打包编译后的文件 less,sass,typescript,es6 test,tests,test 测试文件 benchmarks 测试版本的性能变化 units,spec 单元测试 e2e 端对端测试 build,script 构建脚本 utils,tools,helpers 工具代码 models,views,controllers,middlewares MVC，中间件 router 路由 server 服务端代码 adapters 适配器模式 legacy 兼容历史版本或者浏览器的代码 bin 命令脚本，命令行工具 common 公用文件 packages 打包多个npm包,减小体积 core 核心文件 misc 杂项]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端语音播报问题集合]]></title>
      <url>%2F2017-12-19-sound.html</url>
      <content type="text"><![CDATA[突然想到之前一个项目的问题，当时手忙脚乱糊弄地解决了一下。打卡签到，播放“XXX,签到成功”。判断一个人的语音提示是否播报完成？或者打断？ 文本生成语音1234567891011121314151617181920var speaker = new window.SpeechSynthesisUtterance();var speakTimer, stopTimer;// 开始播报function speakText(text) &#123; clearTimeout(speakTimer); window.speechSynthesis.cancel(); speakTimer = setTimeout(function () &#123; speaker.text = text; window.speechSynthesis.speak(speaker); &#125;, 200);&#125;// 停止播报function stopSpeak() &#123; clearTimeout(stopTimer); clearTimeout(speakTimer); stopTimer = setTimeout(function () &#123; window.speechSynthesis.cancel(); &#125;, 20);&#125; APISpeechSynthesis 参数 含义 paused 是否暂停 pending 是否处理中 speaking 是否朗读中 onvoiceschanged 声音变化时触发 cancel() 情况待朗读队列 getVoices() 获取浏览器支持的语音包列表 pause() 暂停 resume() 重新开始 speak() 读合成的语音，参数必须 SpeechSynthesisUtterance 参数 含义 lang 语言 pitch 音高 rate 语速 text 文本 voice 声音 volume 音量 onboundary 单词或句子边界触发，即分隔处触发 onend 结束时触发 onerror 错误时触发 onmark onpause 暂停时触发 onresume 重新播放时触发 onstart 开始时触发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2018前端学习计划]]></title>
      <url>%2F2017-12-19-plan2018.html</url>
      <content type="text"><![CDATA[再堕落下去，要是个废人了。开始好好学习，天天向上咯！小小列个清单先~ 旧的要巩固基础 结构：HTML/HTML5 样式：CSS/CSS3/canvas/svg/vr/webGL 逻辑：JavaScript/jQuery 地图：摸清天地图，一切地图不是事儿 数据:数据库/php(后台小哥哥的东西，看看会cv就好) 服务：node 兼容性：web和移动端/各浏览器 框架全家桶 vue+vuex+vue+router+axios react+ Angular(找时间看2啊) 构建 LESS/SASS TypeSript webpack+npm/yarn 代码规范 es6 小技能 gif录制，用啥软件来着，记得回去翻翻 新的要学学学学学！嘿嘿~特效，公式撸起来 贝塞尔曲线原理 视差原理 阻尼公式 新框架 express框架 koa框架 egg.js(天猫)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[毒鸡汤]]></title>
      <url>%2F2017-12-08-soup.html</url>
      <content type="text"><![CDATA[在家里闲置了很久的大脑，可能就是鸡汤喝得太多了吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript要仔细学之二//闭包]]></title>
      <url>%2F2017-06-28-js02.html</url>
      <content type="text"><![CDATA[不得不看之闭包– 一个栗子 问题:点击列表输出对应的索引（用JS，非JQ） 123456789101112&lt;ul&gt; &lt;li&gt;哈哈哈&lt;/li&gt; &lt;li&gt;嘤嘤嘤&lt;/li&gt; &lt;li&gt;嘿嘿嘿&lt;/li&gt; &lt;li&gt;啦啦啦&lt;/li&gt; &lt;li&gt;略略略&lt;/li&gt; &lt;li&gt;嘻嘻嘻&lt;/li&gt; &lt;li&gt;呵呵呵&lt;/li&gt; &lt;li&gt;哒哒哒&lt;/li&gt; &lt;li&gt;嘁嘁嘁&lt;/li&gt; &lt;li&gt;哟哟哟&lt;/li&gt;&lt;/ul&gt; 可能有小可爱会这样做:1234567var lis = document.querySelectorAll('ul li');var len = lis.length;for(var i = 0; i &lt; len; i++) &#123; lis[i].addEventListener('click', function () &#123; console.log(i); &#125;, false);&#125; 运行结果是，不管点击哪个列表，结果输出的都是10。 var声明的变量是函数作用域的，而不是块级作用域的。也就是说，for循环10次，每次都是改变同一个i，所以它的值会从0一直加到10。 闭包保存的是外部变量的引用，而不是值。也就是说，循环10次监听器创建了10 个闭包，它们里面的i引用的是同一个啊。所以全部都指向了10。 解决方案let替代var但是涉及到es6,出于兼容性的考虑，还要做转译，还是微微有点不开心1234567var lis = document.querySelectorAll('ul li');var len = lis.length;for(let i = 0; i &lt; len; i++) &#123; lis[i].addEventListener('click', function () &#123; console.log(i); &#125;, false);&#125; 立即执行函数(切断闭包)123456789var lis = document.querySelectorAll('ul li');var len = lis.length;for(var i = 0; i &lt; len; i++) &#123; (function (i) &#123; lis[i].addEventListener('click', function () &#123; console.log(i); &#125;, false); &#125;)(i)&#125; 事件委托(避开闭包)12345678var ul = document.querySelector('ul');var lis = ul.querySelectorAll('li'); ul.addEventListener('click', function (e) &#123; var target = e.target; if(target.nodeName.toLowerCase() === 'li') &#123; console.log([].indexOf.call(lis, target)); &#125;&#125;, false);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[鹅厂小事件]]></title>
      <url>%2F2017-06-21-tencent.html</url>
      <content type="text"><![CDATA[鹅厂啊鹅厂 鹅厂企业邮箱鹅厂企业邮箱pop设置：pop.exmail.qq.comci]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript模块规范:CommonJS和AMD]]></title>
      <url>%2F2017-06-20-modulerule.html</url>
      <content type="text"><![CDATA[目前，通行的Javascript模块规范有两种：CommonJS和AMD。 CommonJS 在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。 假定有一个数学模块math.js，就可以像下面这样加载。[math.js]12var math = require('math');math.add(2,3); // 5 ,调用模块提供的方法 CommonJS规范不适用于浏览器环境。第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 ## AMD规范 全称：Asynchronous Module Definition（异步模块定义）它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：require([module], callback);上述的例子：123 require(['math'], function (math) &#123; math.add(2, 3); &#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[rawraw的github]]></title>
      <url>%2F2017-06-20-github.html</url>
      <content type="text"><![CDATA[rawraw的github项目的快速链接 bundler browserify webpack RequireJS/AMD taskrunner Grunt Gulp git常用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5/JavaScript/CSS书写规范]]></title>
      <url>%2F2017-06-14-norm.html</url>
      <content type="text"><![CDATA[作为强迫症，就是特别喜欢介个样子// HTML5头部12345678&lt;!DOCTYPE html&gt;&lt;meta charset="utf-8"&gt;&lt;meta name="viewport" content="width=device-width"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge" /&gt;&lt;meta name="description" content=""&gt;&lt;meta name="keywords" content=""&gt; &lt;title&gt;HTML5 standardization&lt;/title&gt;//type属性：省略 区分浏览器no-js标签是需要与Modernizr等类库配合使用的&lt;script src=&quot;js/libs/modernizr-2.5.0.min.js&quot;&gt;&lt;/script&gt;1234&lt;!--[if lt IE 7]&gt; &lt;html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="zh"&gt; &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; &lt;html class="no-js lt-ie9 lt-ie8" lang="zh"&gt; &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; &lt;html class="no-js lt-ie9" lang="zh"&gt; &lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;&lt;!--&gt; &lt;html class="no-js" lang="zh"&gt; &lt;!--&lt;![endif]--&gt; 避免IE6条件注释引起的高版本IE文件阻塞问题 与Modernizr等特征检测类库使用相同的class，更具备通用性 优于使用CSS Hack 嵌套规则 块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素； 里面不能放块级元素； 块级元素与块级元素并列、内嵌元素与内嵌元素并列； 文档内容 自定义属性：data-* 不要使用内联样式 不要使用和,用css来控制。不要使用和，HTML5不赞成使用 实体字符引用 字符 实体名 实体数 “ &amp;quot; &amp;#34; ‘ &amp;apos;(IE不支持) &amp;#39; &amp; &amp;amp; &amp;#38; &gt; &amp;gt; &amp;#62; &lt; &amp;lt; &amp;#60; &nbsp; &amp;nbsp; &amp;#160; &emsp; &amp;emsp; &amp;#12288; ￥&yen; &amp;yen; &amp;#165; &brvbar; &amp;brvbar; &amp;#39; &copy; &amp;copy; &reg; &amp;reg; &amp;#169; &trade; &amp;trade; &amp;#8428; &middot; &amp;middot; &amp;#183; &laquo; &amp;laquo; &amp;#171; &raquo; &amp;raquo; &amp;#187; &deg; &amp;deg; &amp;#176; &times; &amp;times; &amp;#215; &divide; &amp;divide; &amp;#247; &permil; &amp;permil; &amp;#8240; 图片 给图片添加width和height，提升页面加载速度 给所有img添加alt属性 不要使用或尽量少用gif文件 CSS引用结构按照顺序引入CSS 一律写在 CSS 文件中，原则上不写内联样式，不直接为标签添加样式（reset 除外）。 基础框架（reset / grid …） 通用模块（theme/ common…） 页面样式（page…） 命名规范 CSS对大小写敏感 不采用驼峰式命名，不用中文拼音 不允许使用具体的样式名称命名，也不应包含颜色、位置等与现实效果相关的信息。 加上适当的命名空间（前缀），以避免命名冲突。命名空间不使用单个字母，以免与通用样式冲突。 文件命名CSS 文件命名由小写字母、下划线（_）组成。 选择器命名CSS 文件命名由小写字母、中划线（-）组成。|布局（grid） .g-|模块（module） .m-|元件（unit）|功能（function）|状态 .z-|皮肤（skin） .s-|JS选择器 .j-| 书写规范 ;分行书写 属性值为 0 时，单位可以省略。 属性值为小数时，小数点之前的 0 不可以省略。 省略 url 中的引号，其他需要引号的地方使用单引号。 书写顺序属性| 显示属性 | display, visibility, position, float, clear, list-style, top 等 || 自身属性 | width, height, margin, padding, border, overflow 等 || 文本及修饰属性 | font, text-align, text-decoration, vertical-align, white-space, color, background 等 || CSS3 属性 | border-radius, box-shadow, gradients, transforms, animations 等 | 链接a:link -&gt; a:visited -&gt; a:hover -&gt; a:active 优化合并选择器属性值缩写 margin padding border background font color list-style 避免耗性能的属性 width: expression(this.width&gt;100?&#39;100px&#39;:&#39;auto&#39;); filter: alpha(opacity=50); 图片合并（sprite）文件压缩JavaScript使用===/!====和!=不判断类型 特殊情况在判断函数是否为空的情况下，使用==或!=是可以的。12345//如果foo没有被初始化，它默认的值是undefined而不是null。当然underfined更不会等于null了。//因此这种情况应该使用==和!=。if (foo == null) &#123; ...&#125; DELETE在数组中数组可以被DELETE，但是会留下undefined元素。可以用shift( )/pop( )/splice(index,num)1234var myArray = [ 'a', 'b', 'c', 'd' ];delete myArray[2]; // Noncompliant. myArray =&gt; ['a', 'b', undefined, 'd']console.log(myArray[2]); // 'undefined' for...in..的循环在每次操作前需要进行过滤判断“for … in”这种循环允许开发人员按照属性的名字遍历对象。不幸的是，这个属性的集合包括了对象自身和对象继承的对象的所有属性。如果程序不考虑这点就会出现错误。都应该包括一个if判断来过滤你需要的属性。12345for (name in object) &#123; if (object.hasOwnProperty(name)) &#123; doSomething(name); &#125;&#125; NaN不要出现在比较中NAN不等于包括自身在内的任何值。因此与NAN作比较是得不到你需要的结果的，但是这种错误有可能会出现。事实上，判断值是否等于NAN最好的方法就是和它自己作比较即NAN!==NAN，因为正常的变量都是等于自身的，如果不等于自身成立，就说明这个值是NAN。 保证函数调用时传入的参数都被使用12345678function doSomething(a, b) &#123; compute(arguments);&#125;doSomething(1, 2, 3) function say(a, b) &#123; print(a + ' ' + b);&#125;say('hello', 'world', '!'); 选择器得到的结果一定要用LENGTH判断无论是否找到该对象，选择器总是返回一个对象。123456if ($('.test')) &#123; // ... &#125;if ($('.test').length &gt; 0) &#123; // ...&#125; 用逻辑短路防止出现空的错误123456789101112if (str != null &amp;&amp; str.length == 0) &#123; console.log('String is empty');&#125;if (str != undefined &amp;&amp; str.length == 0) &#123; console.log('String is empty');&#125;if (str == null || str.length &gt; 0) &#123; console.log('String is not empty');&#125;if (str == undefined || str.length &gt; 0) &#123; console.log('String is not empty');&#125; 易错点 用null,不要用undefined（尚未创建）赋值给变量。 var i = 0;i = i++; parseInt函数有两个版本的，一个是只有一个参数的，而另一个是需要两个参数的。然而，旧版的浏览器不支持一个参数的parseInt方法。parseInt(&quot;010&quot;, 10); 性能优化 var input = $( &#39;form input[type=radio]&#39; );代替var input = $( &#39;form input:radio&#39; ); var $productIds = $(&#39;#products&#39;).find(&#39;div.id&#39;);代替var $productIds = $(&#39;#products div.id&#39;); 选择结果应该被保存，var paragraph = $(&#39;p&#39;);paragraph.hide();paragraph.show(); 尽量不要通配选择器$( &#39;.buttons&#39; ).children();代替`$( ‘.buttons &gt; ‘ ); ` 使用===/!==，==和!=不判断类型 约定规范 每一条声明须要由“;”结尾 注释不应该写在每一行的最后面；一行代码不要太长（不超过80）；多分行分行 文件后面应该包含一个空行（这条规则会使得在利用一些工具，例如Git的时候配合的更好） 声明STRING类型的变量是需要用单引号 源代码文件应该有足够的注释（默认15%） FUNCTIONS不应该有太多行（阈值：300），难以理解以及维护。 函数不应该有太多的参数（临界值为7） 一个表达式不应该有超过三个的操作符，以增加表达式的可读性。 循环不应该包括多余一个的BREAK或者CONTINUE语句，否则重构 结尾的逗号不应该被使用var settings = {&#39;foo&#39;: oof,&#39;bar&#39;: rab}; ARGUMENTS.CALLER和ARGUMENTS.CALLEE在ECMAScript5中，这两个函数在strict模式下都被禁止使用。在最新的Javascript版本中不建议被使用。 不要省略大括号（）if，作为范围控制 SWITCH的每个条件结尾都要有BREAK 发布版本中不要有alert(),console,给攻击者泄露敏感信息 //TODO，// FIXME只在 开发过程中。 开发人员不能注释代码，因为会影响代码可读性。不再使用的代码就删除。 new关键字应该和构造函数一起使用 不要使用ARRAY和OBJECT的构造方法。超过一个参数，会新建多个array. 不要重载内置对象 及时释放无用的储存]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[API大全整理/from github]]></title>
      <url>%2F2017-06-13-api.html</url>
      <content type="text"><![CDATA[偶然发现的github上的API，蛮好用的吼、 emoji表情包大全https://api.github.com/emojisGET返回数据格式：1234567&#123; "+1": "https://assets-cdn.github.com/images/icons/emoji/unicode/1f44d.png?v7", "-1": "https://assets-cdn.github.com/images/icons/emoji/unicode/1f44e.png?v7", "100": "https://assets-cdn.github.com/images/icons/emoji/unicode/1f4af.png?v7", "1234": "https://assets-cdn.github.com/images/icons/emoji/unicode/1f522.png?v7", //... &#125; markdown编辑器https://api.github.com/markdownPOST12345data = &#123; "text":"#test", "mode": "gfm", "context": "github/gollum" &#125; 返回数据：html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript要仔细学之一//apply( )和call( )的区别]]></title>
      <url>%2F2017-06-12-js01.html</url>
      <content type="text"><![CDATA[call和apply可以改变this指针,即改变函数的作用域。 说明call和apply方法的作用相同，就是参数不同。call和apply的第一个参数都是一样的，但是后面参数不同，call从第二个参数开始后面有许多参数，apply第二个参数必须是数组。call([thisObj[,arg1[, arg2[, [,.argN]]]]])apply([thisObj[,argArray]])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块打包-bundler：browserify、webpack、RequireJS/AMD]]></title>
      <url>%2F2017-05-26-bundler.html</url>
      <content type="text"><![CDATA[目前比较完善的模块打包：browserify和webpack。webpack在browserify之后出现。 browserifywebpackRequireJS/AMD]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[任务流工具-taskrunner：Grunt、Gulp]]></title>
      <url>%2F2017-05-26-task-runner.html</url>
      <content type="text"><![CDATA[目前比较完善的任务流工具：Grunt和Gulp。Gulp在Grunt之后出现，有Grunt的优点，同时增加了新特性。 Grunt安装npm install grunt-cli -g Gulp安装npm install gulp-cli -g]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[design patterns - JavaScript设计模式]]></title>
      <url>%2F2017-05-25-design-patterns.html</url>
      <content type="text"><![CDATA[哎，最不想整理的就是这一块了 最初在设计模式 一书中，许多设计模式都鼓励使用松散耦合。在更改一个代码片段时，就会发生问题，系统其他部分 —— 曾认为完全不相关的部分中也有可能出现级联破坏。该问题在于紧密耦合 。系统某个部分中的函数和类严重依赖于系统的其他部分中函数和类的行为和结构。您需要一组模式，使这些类能够相互通信，但不希望将它们紧密绑定在一起，以避免出现联锁。 工厂模式简单工厂模式12345678910111213141516function BuyHero(name,type,price)&#123; var obj = &#123;&#125;; obj.name = name; obj.age = type; obj.price = price; obj.sayName = function()&#123; return this.name; &#125;; return obj;&#125;var h1 = new BuyHero('Teemo','ADC','6300');var h2 = new BuyHero('Amumu','Jungle','3100');//返回都是object 无法识别对象的类型，哪个对象的实列 console.log(typeof h1); // object console.log(typeof h2); // object console.log(h1 instanceof Object); // true 复杂工厂模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 定义英雄池的构造函数var League = function(name)&#123; this.name = name; this.method = function()&#123; return this.name; &#125;&#125;;League.prototype = &#123; constructor: League, /* * 买英雄这个方法 * @param &#123;name&#125; 英雄名字 */ buyHero: function(name)&#123; var hero = this.createHero(name); // 执行Q、W...技能，哦，业务逻辑 hero.Q(); hero.W(); return hero; &#125;, createHero: function(model)&#123; throw new Error("父类是抽象类不能直接调用，需要子类重写该方法"); &#125;&#125;;// 实现原型继承function extend(Sub,Sup) &#123;//Sub表示子类，Sup表示超类 var F = function()&#123;&#125;;// 首先定义一个空函数 F.prototype = Sup.prototype;// 设置空函数的原型为超类的原型 Sub.prototype = new F();// 实例化空函数，并把超类原型引用传递给子类 Sub.prototype.constructor = Sub;// 重置子类原型的构造器为子类自身 Sub.sup = Sup.prototype;// 在子类中保存超类的原型,避免子类与超类耦合 if(Sup.prototype.constructor === Object.prototype.constructor) &#123; Sup.prototype.constructor = Sup;// 检测超类原型的构造器是否为原型自身 &#125;&#125;var HeroChild = function(name)&#123; this.name = name; // 继承构造函数父类中的属性和方法 League.call(this,name);&#125;;// 子类继承父类原型方法extend(HeroChild,League);// BicycleChild 子类重写父类的方法HeroChild.prototype.createHero = function()&#123; var Q = function()&#123; console.log("执行Q业务操作"); &#125;; var W = function()&#123; console.log("执行W业务操作"); &#125;; return &#123; Q: Q, W: W &#125;&#125;;var Teemo = new HeroChild("提莫"); console.log(Teemo); console.log(Teemo.name);//提莫 Teemo.buyHero(); 理解 父类是一个抽象类，不能被实列化,将其成员对象的实列化推迟到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。子类之间是相互独立的。 优点解决多个类似对象声明的问题;解决实列化对象产生重复的问题。在父类中编写一些相同的方法代码,在子类中重写该父类的方法，去实现具体的业务逻辑。 1/弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。 2/重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。 缺点无法获取对象类型 单体模式封装单体模式123456789101112131415161718192021222324252627282930313233343536// 写法一var Singleton = function(name)&#123; this.name = name; this.instance = null;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;;// 获取实例对象function getInstance(name) &#123; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;// 写法二var Singleton = function(name)&#123; this.name = name; &#125;; Singleton.prototype.getName = function()&#123; return this.name; &#125; // 获取实例对象 var getInstance = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125; &#125;)();// 测试单体模式的实例var a = getInstance("aa");var b = getInstance("bb");console.log(a===b);// true,b的实例就是a的实例 使用代理实现单体模式具体的单体模式中的实例化类的事情交给代理函数去处理，这样做的好处是具体的业务逻辑分开了，代理只管代理的业务逻辑，在这里代理的作用是实例化对象，并且只实例化一次; 创建div代码只管创建div，其他的不管；12345678910111213141516171819202122232425262728293031323334353637//创建一个div//第一种var CreateDiv = function(html) &#123; this.html = html; this.init();&#125;;CreateDiv.prototype.init = function()&#123; var div = document.createElement("div"); div.innerHTML = this.html; document.body.appendChild(div);&#125;;// 代理实现单体模式var ProxyMode = (function()&#123; var instance; return function(html) &#123; if(!instance) &#123; instance = new CreateDiv("rawraw hello"); &#125; return instance; &#125;&#125;)();//第二种 // 代理实现单体模式 var ProxyMode = (function()&#123; var instance; return function(html) &#123; if(!instance) &#123; instance = document.createElement("div"); instance.innerHTML = "rawraw hello"; document.body.appendChild(instance); &#125; return instance; &#125; &#125;)();var a = new ProxyMode("aaa");var b = new ProxyMode("bbb");console.log(a===b);// true 综合123456789101112131415161718192021222324252627282930313233// 创建divvar createWindow = function()&#123; var div = document.createElement("div"); div.innerHTML = "我是弹窗内容"; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;// 创建iframevar createIframe = function()&#123; var iframe = document.createElement("iframe"); document.body.appendChild(iframe); return iframe;&#125;;// 获取实例的封装代码var getInstance = function(fn) &#123; var result; return function()&#123; return result || (result = fn.call(this,arguments)); &#125;&#125;;// 测试创建divvar createSingleDiv = getInstance(createWindow);document.getElementById("test").onclick = function()&#123; var win = createSingleDiv(); win.style.display = "block";&#125;;// 测试创建iframevar createSingleIframe = getInstance(createIframe);document.getElementById("test").onclick = function()&#123; var win = createSingleIframe(); win.innerHTML = "rawraw hello";&#125;; 理解 单体模式是以对象字面量的方式来创建单体模式一个用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。以对象字面量的方式来创建单体模式。 适用场景：弹窗 优点缺点模块模式123456789101112var singleMode = (function()&#123; var privateNum = 112;// 创建私有变量 // 创建私有函数 function privateFunc()&#123; // 实现自己的业务逻辑代码 &#125; // 返回一个对象包含公有方法和属性 return &#123; publicMethod1: publicMethod1, publicMethod2: publicMethod1 &#125;;&#125;)(); 模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，先定义了私有变量和函数，供内部函数使用，然后将一个对象字面量作为函数的值返回，返回的对象字面量中只包含可以公开的属性和方法。这样的话，可以提供外部使用该方法；由于该返回对象中的公有方法是在匿名函数内部定义的，因此它可以访问内部的私有变量和函数。 增强的模块模式适合那些单列必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况。12345678910111213141516171819202122function CustomType() &#123; this.name = "rawraw";&#125;CustomType.prototype.getName = function()&#123; return this.name;&#125;;var application = (function()&#123; var privateA = "aa";// 定义私有 function A()&#123;&#125;// 定义私有函数 var object = new CustomType();// 实例化一个对象后，返回该实例，然后为该实例增加一些公有属性和方法 object.A = "cc";// 添加公有属性 // 添加公有方法 object.B = function()&#123; return privateA; &#125;; return object;// 返回该对象&#125;)();console.log(application);console.log(application.A);// ccconsole.log(application.B()); // aaconsole.log(application.name); // rawrawconsole.log(application.getName());// rawraw 理解 模块模式的思路是为单体模式添加私有变量和私有方法能够减少全局变量的使用； 适用场景：必须创建一个对象并以某些数据进行初始化，同时还要公开一些能够访问这些私有数据的方法 优点缺点代理模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748```## 理解&gt;&gt;&gt; 适用场景：图片预加载## 案例```js// 不使用代理的预加载图片函数如下var myImage = (function()&#123; var imgNode = document.createElement(&quot;img&quot;); document.body.appendChild(imgNode); var img = new Image(); img.onload = function()&#123; imgNode.src = this.src; &#125;; return &#123; setSrc: function(src) &#123; imgNode.src = &quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;; img.src = src; &#125; &#125;&#125;)();// 调用方式myImage.setSrc(&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;);var myImage = (function()&#123; var imgNode = document.createElement(&quot;img&quot;); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();// 代理模式var ProxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src) &#123; myImage.setSrc(&quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;); img.src = src; &#125; &#125;&#125;)();// 调用方式ProxyImage.setSrc(&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;); 优点1.代理对象可以代替本体被实例化，并使其可以被远程访问；2.它还可以把本体实例化推迟到真正需要的时候；对于实例化比较费时的本体对象，或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象； 缺点职责链模式12345```## 理解## 优点## 缺点# 命令模式 1234## 理解## 优点## 缺点# 模板方法模式 1234## 理解## 优点## 缺点# 策略模式 1234## 理解## 优点## 缺点# 发布-订阅模式(观察者模式) 1234## 理解## 优点## 缺点# 中介者模式 ``` 理解优点缺点http://www.cnblogs.com/tugenhua0707/p/5198407.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Front-end总结]]></title>
      <url>%2F2017-05-25-front-end.html</url>
      <content type="text"><![CDATA[前端学习流程整理、我的小计划。然后可能就是大神了吧，哈哈哈哈哈哈哈哈哈哈~ 要不要画个图 我先纠结几天吧、]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[navicat for mysql安装问题]]></title>
      <url>%2F2017-05-16-navicat.html</url>
      <content type="text"><![CDATA[navicat for mysql安装问题小集合 10451234C:\xampp\MySQL\bin mysql -u root mysql mysql&gt; UPDATE user SET Password=PASSWORD(&apos;newpassword&apos;) where USER=&apos;root&apos;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xampp配置虚拟主机]]></title>
      <url>%2F2017-05-16-xampp.html</url>
      <content type="text"><![CDATA[xampp配置虚拟主机 首先，xampp要可以基本运行起来 域名配置以管理员身份运行hosts,新增127.0.0.1 test.com xampp配置1234567891011&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;E:/test&quot; ## 文件根目录 ServerName test.com ## 虚拟域名 &lt;Directory E:/test&gt; ## 文件根目录 Options -Indexes AllowOverride ALL DirectoryIndex index.php index.html Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http协议]]></title>
      <url>%2F2017-05-10-http.html</url>
      <content type="text"><![CDATA[一个页面的呈现，经历了怎样的对白、 在浏览器输入url地址浏览器查找域名的 IP 地址 http://mp.weixin.qq.com/s/Z-vKtayFWPZ-E-mXAgVNsQhttp://mp.weixin.qq.com/s/monpEQJWf1MpBYManDY12A]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式整理]]></title>
      <url>%2F2017-05-09-regexp.html</url>
      <content type="text"><![CDATA[特别简单的就不记下来了，这么简单都还要来翻，还撸什么码/ 汉字: ^[\u4e00-\u9fa5]{0,}$email: ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[优化总结]]></title>
      <url>%2F2017-05-04-optimize.html</url>
      <content type="text"><![CDATA[better better ~~ 强迫症的宝宝-_— 图片清晰度动画3D启用硬件加速1234#test &#123; -webkit-transform:translate3d(0, 0, 0) transform: translate3d(0, 0, 0);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[各种爹一样的兼容处理]]></title>
      <url>%2F2017-05-03-compatible.html</url>
      <content type="text"><![CDATA[好奇怪的ie678,好奇怪的安卓机，好奇怪的ios爸爸。。。 web端杂在ie6-7中，用margin-bottom代替padding 移动端]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[好用的小东西整理]]></title>
      <url>%2F2017-05-03-css3.html</url>
      <content type="text"><![CDATA[常用的css3巴拉巴拉的，js小技巧-_- CSS部分 移动端将文本分成多列12345#test&#123; -moz-column-count:3; -webkit-column-count:3; column-count:3;&#125; 创建模糊文本123456#test &#123; color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125; ``` ### pre标签内文本自动换行 pre{ overflow: auto; background-color: #f1f1f1; overflow-x: auto; /* Use horizontal scroller if needed; for Firefox 2, not white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */ word-wrap: break-word; /* Internet Explorer 5.5+ */ margin: 0; padding:5px 5px 3px 5px; white-space : normal; /* crucial for IE 6, maybe 7? */ } 1### 表格自动宽度 td { white-space: nowrap;}12### 让滚动条顺溜地滑定位后的滑动会出现卡顿 body { -webkit-overflow-scrolling: touch; overflow-scrolling: touch;}1### 长按闪退 #test{ -webkit-touch-callout: none;}1### select 设置右对齐 select option { direction: rtl;}1### touch时有半透明灰色遮罩（ios和android） #test{ -webkit-tap-highlight-color:rgba(255,255,255,0)}1### 输入框默认内阴影、以及默认样式(ios) #test{ -webkit-appearance: none;}123456789### 部分机型存在type为search的input，自带close按钮样式&gt;`#Search::-webkit-search-cancel-button&#123; display: none; &#125;`### 默认首字母会大写(ios)&gt;`&lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt;`### 圆角失效(某些Android) #test{ background-clip: padding-box;}1234567### 移动端伪类 `:active` 失效移动端应该是touch&gt;`&lt;body ontouchstart=&quot;&quot;&gt;` &gt;或者`document.addEventListener(&apos;touchstart&apos;,function()&#123;&#125;,false);`## 浏览器### 禁止复制、选中文本 #test{ -webkit-user-select: none; -moz-user-select: none; -khtml-user-select: none; user-select: none;}123456789101112131415161718192021### 消除 IE10 的叉号&gt;`input:-ms-clear&#123;display:none;&#125;`### css垂直居中 ![去这里看](center) ## CSS3### 伪类#### 修改选中文本的颜色：```css [ 举一个栗子 ]user-select:none::selection&#123;color: white;background-color: red;&#125; ::-moz-selection &#123;color: white;background-color: red;&#125; 首字母设置12345678910111213#test:first-child::first-letter&#123; font-size: 28px; font-weight: bold;&#125;/*首字下沉*/p:first-letter&#123; display:block; margin:5px 0 0 5px; float:left; color:#FF3366; font-size:60px; font-family:Georgia; &#125; 透明度的兼容123456#test &#123; filter: alpha(opacity=50); /* internet explorer */ -khtml-opacity: 0.5; /* khtml, old safari */ -moz-opacity: 0.5; /* mozilla, netscape */ opacity: 0.5; /* fx, safari, opera */&#125; webkit mask遮罩要记得来写http://www.cnblogs.com/cosiray/archive/2012/12/06/2804770.html transform出现锯齿123-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0); transform: rotate(-4deg) skew(10deg) translateZ(0); outline: 1px solid rgba(255,255,255,0) 渐变[ 举一个栗子 ]12345678910111213141516171819202122232425262728/*上至下，默认方向*/#test&#123; background: -webkit-linear-gradient(#000, #fff); background: -o-linear-gradient(#000, #fff); background: -moz-linear-gradient(#000, #fff); background: linear-gradient(#000, #fff); &#125;/*左至右*/#test2 &#123; background: -webkit-linear-gradient(left, #000 , #fff); background: -o-linear-gradient(right, #000, #fff); background: -moz-linear-gradient(right, #000, #fff); background: linear-gradient(to right, #000 , #fff); &#125;/*角度。12点方向为0deg,顺时针增加deg*/#test3 &#123; background: -webkit-linear-gradient(180deg, #000, #fff); background: -o-linear-gradient(180deg, #000, #fff); background: -moz-linear-gradient(180deg, #000, #fff); background: linear-gradient(180deg, #000, #fff);&#125;/*也可以径向渐变，多种颜色，透明度*/#test4&#123; background: -webkit-radial-gradient(#000 , #fff 10%, #000 20%); background: -o-radial-gradient(#000, #fff 10%, #000 20%); background: -moz-radial-gradient(#000, #fff 10%, #000 20%); background: radial-gradient(#000, #fff 10%, #000 20%); &#125; JS部分 中文输入法输入英文时，有六分之一空格（ios） this.value = this.value.replace(/\u2006/g, &#39;&#39;); 移动端autoplay 失效问题必须由用户来触发才可以播放。touchstart 触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。 document.addEventListener(&#39;touchstart&#39;, function () { document.getElementsByTagName(&#39;audio&#39;)[0].play(); document.getElementsByTagName(&#39;audio&#39;)[0].pause(); }); 批量修改样式[ 举一个栗子 ]1div.style.cssText = 'width:100px;height:100px;' 展开select的option123456function showDropdown(sltElement) &#123; var event; event = document.createEvent(&apos;MouseEvents&apos;); event.initMouseEvent(&apos;mousedown&apos;, true, true, window); sltElement.dispatchEvent(event);&#125;; HTML部分 meta标签apple-mobile-web-app-capableapple-mobile-web-app-capable是设置Web应用是否以全屏模式运行。 &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; 缓存有时候改了bug刷新并没有卵用，然后就好气啊。手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。 &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt;format-detection 启动或禁用自动识别页面中的电话号码。&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; 奇怪的浏览器强制屏幕12345678910111213141516171819&lt;!-- QQ浏览器私有 --&gt;&lt;!-- 全屏模式 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- 强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- 强制横屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;landscape&quot;&gt;&lt;!-- 应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- UC浏览器私有 --&gt;&lt;!-- 全屏模式 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- 强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- 强制横屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;landscape&quot;&gt;&lt;!-- 应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; 移动端拨打电话功能（安卓、ios都可以） &lt;a href=&quot;tel:10086&quot;&gt;10086&lt;/a&gt; app横屏字体text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-size-adjust: 100%; 顶部状态栏背景色先指定全屏模式 apple-mobile-web-app-capable&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;blank&quot; /&gt; content:default 正常显示 blank 黑色背景 lank-translucent 黑色半透明，页面主体会向上占据位置 桌面图标图片尺寸可以设定为5757（px）或者Retina可以定为114114（px），ipad尺寸为72*72（px) 去光泽 &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;touch-icon-iphone.png&quot; /&gt; 启动画面 &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;start.png&quot;/&gt;iOS下页面启动加载时显示的画面图片，避免加载时的白屏。可以通过madia来指定不同的大小：1234567891011121314151617181920&lt;!--iPhone--&gt; &lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone Retina --&gt; &lt;link href=&quot;apple-touch-startup-image-640x920.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone 5 --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; media=&quot;(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)&quot; href=&quot;apple-touch-startup-image-640x1096.png&quot;&gt; &lt;!-- iPad portrait --&gt; &lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad landscape --&gt; &lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina portrait --&gt; &lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina landscape --&gt; &lt;link href=&quot;apple-touch-startup-image-1496x2048.png&quot;media=&quot;(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot;rel=&quot;apple-touch-startup-image&quot; /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[\\这个插件还可以//之select2]]></title>
      <url>%2F2017-04-19-plu-select2.html</url>
      <content type="text"><![CDATA[placeholder: 一定要加空的 [ 举一个栗子 ]1234567$('#test').select2(&#123; data:[ &#123;id:1,text:"teemo"&#125;, &#123;id:2,text:"anni"&#125;, //... ]&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试大宝典]]></title>
      <url>%2F2017-04-12-interview.html</url>
      <content type="text"><![CDATA[为什么要学习前端对前端的认识基础知识HTML部分1、重绘和回流 会引起重绘和回流的操作: 添加、删除元素(回流+重绘) 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流) 移动元素，比如改变top,left,transform的值，或者移动元素到另外一个父元素中。(重绘+回流) 对style的操作(对不同的属性操作，影响不一样) 还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等(回流+重绘) 2、浏览器缓存机制浏览器缓存机制是指通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。Cache-Control 用于控制文件在本地缓存有效时长。Last-Modified 是标识文件在服务器上的最新更新时间。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。 特殊情况： 手动刷新页面（F5)，浏览器会直接认为缓存已经过期（可能缓存还没有过期），在请求中加上字段：Cache-Control:max-age=0，发包向服务器查询是否有文件是否有更新。 强制刷新页面（Ctrl+F5)，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。 3、History路由机制用户访问网页的历史记录通常会被保存在一个类似于栈对象中，即history对象，点击返回就出栈，跳下一页就入栈。 window.history.back() 返回到上一个页面 window.history.forward() 进入到下一个页面 window.history.go([delta]) 跳转到指定页面 HTML5增强的History Api和时间： pushState是往history对象里添加一个新的历史记录，即压栈。 replaceState 是替换history对象中的当前历史。 当点击浏览器后退按钮或js调用history.back都会触发onpopstate事件（类似的事件: onhashchange）。onpopstate是专门用来监听浏览器前进后退。onhashchange监听浏览器、客户端前进和后退事件 4、Canvas和SVGCanvas 通过Javascript 来绘制 2D 图形。 SVG 是一种使用 XML 描述 2D 图形的语言。 Canvas和SVG相比，canvas更依赖于分辨率，不支持事件处理器，文本渲染能力弱，比较适合密集型游戏，其中的许多对象会被频繁绘制，而svg则比较适用于类似谷歌地图带有大型渲染区域的应用程序。 CSS部分0、盒子模型window.top.document.compatMode ？ 1、选择器常用选择器：类选择器、标签选择器、ID选择器、后代选择器、群组选择器、伪类选择器(before/after)、兄弟选择器(+~)、属性选择器。 2、定位 relative、absolute、fixed fixed 在移动端的兼容性问题。解决方案： absolute+内部滚动 浮动清浮动方案 3、自适应calc/box 4、Flex布局注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 5、CSS3 transition、transform、Animation 6、Sprite7、iconfontJS部分0、基础语法1、原型链prototype，建立了变量查找机制。 2、作用域作用域链:作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 在JS中没有会块级作用域，只有函数作用域。怪异现象：变量提升。 js变量提升(es6)3、函数普通函数的创建有：显式声明、匿名定义、new Function() 等三种方式。 函数声明和函数表达式的区别函数声明会提前ECMAScript规范中表示，函数声明语句可以出现在全局代码中，或者内嵌在其他函数中，但是不能出现在循环、条件判、或者try/finally以及with语句中。 que0.1 : spacify(&#39;rawraw&#39;) =&gt; &#39;r a w r a w&#39;answer :123function spacify(str) &#123; return str.split('').join(' ');&#125; que0.2 : spacify(&#39;rawraw&#39;) =&gt; &#39;r a w r a w&#39;answer :123String.prototype.spacify = function()&#123; return this.split('').join(' ');&#125;; apply和call的区别详情见这里 que0.1 : log(&#39;hello world&#39;);answer :1234function log(msg)&#123; console.log(msg);&#125;//apply que0.2 : log(&#39;hello&#39;, &#39;world&#39;);answer :1log('hello', 'world'); que0.3 : ‘(app) hello world’arguments是一个伪数组，我们需要先将它转换成正常的数组，我们可以使用Array.prototype.slice,answer :12345function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift('(app)'); console.log.apply(console, args);&#125;; Context的理解que0.1 : 运行结果123456789101112131415161718192021 var User = &#123; count: 1, getCount: function() &#123; return this.count; &#125; &#125;;``` ##### que0.2 : 运行结果```jsconsole.log(User.getCount());var func = User.getCount; console.log(func()); //undefined,unc的上下文是 ｀window，因此已经失去了count属性``` ##### que0.3 : 如何确保func的上下文始终都和User关联，这样可以使输出的答案是1answer :```jsvar func = User.getCount.bind(User); console.log(func()); que0.4 : 老浏览器兼容answer :123456Function.prototype.bind = Function.prototype.bind || function(context) &#123; var self = this; return function()&#123; return self.apply(context, arguments); &#125;;&#125; 4、函数指针this的指向： 作为普通函数调用（this指向全局对象window对象） 作为对象的方法调用（this指向该对象） 构造器调用（this指向用new返回的这个对象） call、apply、bind的调用（this指向第一个参数对象） 5、闭包去看闭包吧 什么情况下会发生闭包，为什么需要闭包，什么场景下需要，闭包闭了谁，怎么释放被闭包的变量内存，闭包的优点是什么，缺点是什么等等。《红宝书》：是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。《你不知道的javascript》：当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函数持有对该词法作用域的引用，这个引用就叫做闭包。 闭包其实是一个主动执行的代码块，这个代码块的特殊之处是可以永久保存局部变量，但又不污染全局变量，可以形成一个独立的执行过程，因此我们经常用闭包来定义组件。闭包本质还是函数，只不过这个函数绑定了上下文环境（函数内部引用的所有变量）。 特性 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收缺点常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。使用场景可以用来管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。 6、事件系统 Event(事件模型及事件代理/委托)(事件是用户与页面交互的基础，到目前为止，DOM事件从PC端的 鼠标事件(mouse) 发展到移动端的 触摸事件(touch) 和 手势事件(guesture) 由于DOM结构可能会多层嵌套，因此也衍生出了两种事件流：事件捕获和事件冒泡，后者最常用。利用事件冒泡机制可以实现很多功能，比如页面点击统计。 除此之外，在页面初始化、滚动、隐藏、返回等操作时分别内置了onload/onDOMContentLoaded、onscroll、onvisibility和onhashchange等事件，如果想要捕获这些事件，需要通过addEventLisener/attachEvent来进行绑定。) 事件的三个阶段捕获，目标，冒泡阶段(低版本IE不支持捕获阶段) {事件的代理/委托}的原理以及优缺点优点 大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适事件代理的应用常用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不应用触发事件的被绑上了事件 IE和W3C不同绑定事件解绑事件的方法有什么区别，参数分别是什么，以及事件对象e有什么区别target，currentTarget，以及IE下的srcElement和this 实现事件模型即写一个类或是一个模块，有两个函数，一个bind一个trigger，分别实现绑定事件和触发事件，核心需求就是可以对某一个事件名称绑定多个事件响应函数，然后触发这个事件名称时，依次按绑定顺序触发相应的响应函数。 大致实现思路就是创建一个类或是匿名函数，在bind和trigger函数外层作用域创建一个字典对象，用于存储注册的事件及响应函数列表，bind时，如果字典没有则创建一个，key是事件名称，value是数组，里面放着当前注册的响应函数，如果字段中有，那么就直接push到数组即可。trigger时调出来依次触发事件响应函数即可。 不过还有很多细节，比如触发响应函数时的上下文应该是什么，触发响应函数的参数列表应该是什么，如果要求把调用trigger的参数列表都传到响应函数中还要考虑到吧arguments对象转化为纯数组才行等等。 还有一些面试官会问到事件如何派发也就是事件广播（dispatchEvent）等等，这里不再展开。 7、单线程和异步队列 setTimeout和setInterval JS是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，主线程会形成一个全局执行环境，执行环境采用栈的方式将待执行任务按顺序依次来执行。但在浏览器中有一些任务是非常耗时的，比如http请求、定时器、事件回调等，为了保证其他任务的执行效率不被影响，JS在执行环境中维护了一个异步队列(也叫工作线程)，并将这些任务放入队列中进行等待，这些任务的执行时机并不确定，只有当主线程的任务执行完成以后，才会去检查异步队列中的任务是否需要开始执行。这就是为什么setTimeout(fn,0) 始终要等到最后执行的原因。 Ajax8、DOM对象:document/全局对象:window(document对象里保存着整个web页面dom结构，在页面上所有的元素最终都会映射为一个dom对象。 document也提供了很多api来查找特定的dom对象，比如getElementById,querySelector等等。) Function.bind函数作用，应用场景，举个栗子1、Function.bind返回的也是一个函数，所以注定发生了闭包；2、在返回的这个函数中去调用一个其他的函数，这其实本质上就是函数钩子(HOOK)；1、保持函数的this指向；2、保持函数的所有参数都传递到目标函数；3、保持函数的返回值； 123456789101112131415161718192021222324if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== "function") &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 9、继承算法排序、去重巴拉巴拉跨域问题http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.htmlhttp://www.cnblogs.com/scottckt/archive/2011/11/12/2246531.htmlhttp://www.cnblogs.com/cat3/archive/2011/06/15/2081559.htmlJSONP原理。这里简单讲就是HTML里面所有带src属性的标签都可以跨域，如iframe，img，script等。 正则尽量不要拆字符，不可预知性1234567891011121314function getQueryObject(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(&quot;?&quot;) + 1); var obj = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (rs, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); val = String(val); obj[name] = val; return rs; &#125;); return obj;&#125; 性能优化网络性能优化，加快访问速度，浏览器并行加载数量，怎样实现原生JS异步载入，CDN加速的原理，如何将不同静态资源发布到多个域名服务器上，发布后这些静态字段的url路径改怎么批量改写，用什么工具进行项目打包，css打包后的相对路径怎么转换为绝对路径，用什么工具进行项目模块依赖管理，怎么进行cookie优化文件合并文件最小化/文件压缩使用CDN托管缓存的使用 函数节流http://www.alloyteam.com/2012/11/javascript-throttle/ 前端设计模式比较多的有观察者模式，职责链模式，工厂模式。比如如何去设计一个前端UI组件，应该公开出哪些方法，应该提供哪些接口，应该提供哪些事件。哪部分逻辑流程应该开放出去让用户自行编写，如何实现组件与组件之间的通信，如何实现高内聚低耦合，如何实现组件的高复用等等 前端面试问题合集 了解这家公司版本管理流程管理每天怎么知道要做什么事情？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown常用语法]]></title>
      <url>%2F2017-04-11-markdown.html</url>
      <content type="text"><![CDATA[markdown：语法比较少也简单，用来写作排版很棒哦、markdownpad：编译+预览的功能。纯编译的话，一般编辑器都可以。markdownpad2破解绿色中文版下载&emsp;提取密码：2ne1 一、标题1.第一种方法的标题code： 123456# 一级标题## 二级标题### 三级标题 #### 四级标题##### 五级标题###### 六级标题 结果：最小到6个###### 一级标题二级标题三级标题四级标题五级标题六级标题2. 第二种方法的标题code： 12345一级标题=============二级标题---- 结果： 一级标题二级标题3. 第三种方法的标题code： 12345678&lt;font size=1&gt;rawraw&lt;/font&gt;&lt;font size=2&gt;rawraw&lt;/font&gt;&lt;font size=3&gt;rawraw&lt;/font&gt;&lt;font size=4&gt;rawraw&lt;/font&gt;&lt;font size=5&gt;rawraw&lt;/font&gt;&lt;font size=6&gt;rawraw&lt;/font&gt;&lt;font size=7&gt;rawraw&lt;/font&gt;&lt;font size=8&gt;rawraw&lt;/font&gt; 结果：最大到7rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw 二、排序code： 1234567891011121314//无序 * == + == -* raw* rawraw* raw+ raw+ rawraw+ rawrawraw- raw- rawraw- rawrawraw//有序，相当于自己写吧1. 提莫2. 娑娜3. 莫甘娜 结果： raw rawraw raw raw rawraw rawrawraw raw rawraw rawrawraw 提莫 娑娜 莫甘娜 三、引用code： 12&gt; 这是一段引用&gt;&gt; 这是一段引用的嵌套 结果： 这是一段引用 这是一段引用的嵌套 四、图片code： 1![“好看死了的图片”](/images/bg/0004.jpg) 结果： 五、链接code： 123456[去吧，皮卡丘](nothing)[回到主页](http://rawraw.info)飞去百度吧[Baidu] [1] ,或者[Rawraw] [2] 或者 [nothing] [3]. [1]: http://www.baidu.com/ "Baidu" [2]: http://rawraw.info "Rawrawh" [3]: nothing "nothing" 结果： 去吧，皮卡丘回到主页飞去百度吧Baidu ,或者Rawraw 或者 nothing. 文章内部链接的话，可以利用a的锚点 六、代码code： 123456//行内代码`body &#123; margin: 0; padding: 0; &#125;`//行内代码代码块```CSS [reset.css]body &#123; margin: 0; padding: 0; &#125;\`\`\` 结果： body { margin: 0; padding: 0; } [reset.css]1body &#123; margin: 0; padding: 0; &#125; 七、分割线code： 123***//或者--- 结果： 八、斜体code： 123//_和* 一样_我是歪的_*我是歪的* 结果： 我是歪的我是歪的 九、表格好麻烦 code： 12345| 立正！ | 向左看！ | 向右看齐！|| :----------: |---------- | -----: || 拉克丝 | 潘森 | 伊泽瑞尔 || 弗拉基米尔 | 波比 | 崔丝塔娜 || 费德提克 | 雷克顿 | 库奇 | 结果： 立正！ 向左看！ 向右看齐！ 拉克丝 潘森 伊泽瑞尔 弗拉基米尔 波比 崔丝塔娜 费德提克 雷克顿 库奇 十、phpstorm中的markdown插件Setting –&gt; Plungins –&gt; 搜索markdown ，install]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS居中方法合集]]></title>
      <url>%2F2017-04-09-center.html</url>
      <content type="text"><![CDATA[居中方法合集 看demo去吧/ 行元素居中水平居中text-align:center 垂直居中line-height 块元素居中水平居中margin: 0 auto 水平垂直居中方法一: 纯position + margin本元素：position: absolute;left: 50%;top: 50%;margin-left: -50px;margin-top: -50px;父元素：position: relative;兼容性：兼容所有margin值为本元素宽高的一半123&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.box1&#123; position: relative; width: 200px; height: 200px; background: #ffd2e9;&#125;.box1 .center &#123; position: absolute; left: 50%; top: 50%; width: 100px; height: 100px; background: #8cebf6; margin-left: -50px; margin-top: -50px;&#125; 方法二: position + margin本元素：margin: auto;position: absolute;left: 0;right: 0;top: 0;bottom: 0;父元素：position: relative兼容：不兼容ie6123&lt;div class=&quot;box2&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.box2 &#123; position: relative; width: 200px; height: 200px; background: #ffd2e9;&#125;.box2 .center &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; width: 100px; height: 100px; background: #8cebf6; margin: auto;&#125; 方法三: position + transform方法三-01本元素：position: absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);父元素：position: relative 方法三-02本元素：position: relative;top: 50%;left:50%;display: inline-block;-webkit-transform: translate(-50%);transform: translate(-50%);父元素：nothing兼容性：ie9以下不支持 transformposition定位父元素元素的宽高50%，transform定位本元素的宽高50%12345678&lt;div class=&quot;box3&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box3_&quot;&gt; &lt;div class=&quot;center&quot;&gt; 11111111 &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930.box3&#123; position: relative; width: 200px; height: 200px; background: #ffd2e9;&#125;.box3 .center &#123; position: absolute; top:50%; left:50%; width: 100px; height: 100px; background: #8cebf6; -webkit-transform:translate(-50%,-50%); transform:translate(-50%,-50%);&#125;.box3_&#123; width: 200px; height: 200px; background: #ffd2e9;&#125;.box3_ .center&#123; position: relative; top: 50%; left:50%; display: inline-block; background: #8cebf6; -webkit-transform: translate(-50%); transform: translate(-50%);&#125; 方法四: flex + center本元素：nothing~~父元素：display: flex;align-items: center;justify-content: center;兼容性：适合移动端123&lt;div class=&quot;box4&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.box4&#123; display: flex; width: 200px; height: 200px; align-items: center;/*垂直居中*/ justify-content: center;/*水平居中*/ background: #ffd2e9;&#125;.box4 .center &#123; width: 100px; height: 100px; background: #8cebf6;&#125; 方法五: flex + margin本元素：margin: auto;父元素：display: flex;兼容性：适合移动端123&lt;div class=&quot;box5&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112.box5 &#123; display: flex; width: 200px; height: 200px; background: #ffd2e9;&#125;.box5 .center &#123; width: 100px; height: 100px; margin: auto; background: #8cebf6;&#125; 方法六:table-cell + inline-block本元素：display: inline-block;父元素：display: table-cell;vertical-align: middle;text-align: center;兼容性：不兼容ie6/7123&lt;div class=&quot;box6&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box6&#123; display: table-cell; width: 200px; height: 200px; background: #ffd2e9; vertical-align: middle; text-align: center;&#125;.box6 .center&#123; display: inline-block; width: 100px; height: 100px; background: #8cebf6;&#125; 不定宽高的元素居中上述方法四五六]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo之站点配置和next主题配置]]></title>
      <url>%2F2017-04-07-hexo-next.html</url>
      <content type="text"><![CDATA[给丑丑的默认hexo换个皮肤、 站点配置next主题配置http://www.tuicool.com/articles/ueI7naVNext主题文档：http://theme-next.iissnan.com/Rss:$ npm install hexo-generator-feed –save]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[看好看的颜色也是一种幸福]]></title>
      <url>%2F2017-04-07-color.html</url>
      <content type="text"><![CDATA[日系传统颜色： 青碧SEIHEKI浅葱ASAGI青磁SEIJI水浅葱MIZUASAGI白群BYAKUGUN瓶覗KAMENOZOKI水MIZU空SORA露草TSUYUKUSA #0080ff]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo搭建个人博客]]></title>
      <url>%2F2017-04-07-hexo.html</url>
      <content type="text"><![CDATA[很酷啊~hexo+github,再加上十几二十块买个酷酷的域名,完成这个小站哦~写写学习笔记，写写杂七杂八的小东西，虽然可能没什么人来看，但是，我开心呀~~~ 一、hexo先配hexo再拉git库吧，不然.git文件在hexo初始化的时候被删掉也是一个心烦的事情内。//1、安装node环境（基本可以忽略，都装了吧）1$ cnpm install npm -g//2、全局安装hexo依赖1$ npm install -g hexo-cli//3、初始化博客文件夹1$ npm init [folder]第一次尝试的报错：说是swig和minimatch要升级到3.0.2的问题，那就在安装一下swig,再升级一下minimatch咯12$ npm install swig$ npm minimatch@”3.0.2”第二次尝试的报错：还是swig有问题咯，那就再装，哼，明明绿了第三次尝试的报错：还是跟第二次一样！！还有这个关于fsevents的报错，是可以忽略的反正他跟你说缺啥，你就用npm install补啥看到INFO Start blogging with Hexo!这句话就ok啦//4、启动hexo12345$ hexo sever//或者$ hexo s//可以自定义端口号，默认是4000，没事也就别改啦$ hexo server -p 1102 //指定1102端口如果前面看到INFO Start blogging with Hexo!，这一步基本没问题。听话地去浏览器打开http://localhost:4000，然后看到这样没有报错最开心了！！第一步搞定！这是hexo的默认主题和配置，然后就可以开始屁颠屁颠改成自己喜欢的样子了咧。二、github//1、建立github库Tip:命名必须 账户名.github.io//2、项目拉取到本地1$ git clone https://github.com/yourname/yourname.github.io三、hexo/github大合体//1、安装deployer依赖1$ npm install hexo-deployer-git --save//2、hexo配置修改 1234567node_modules --&gt;scaffolds --&gt;source --&gt; 文章、图片等资源themes --&gt; 站点主题的相关配置.gitignore --&gt;_config.yml --&gt; 主要改这个文件！！！package.json --&gt; yes!打开_config.yml,就先改# Site和# Deployment这两部分先，其他的以后熟了再细看吧。去看完整版(有空再写哈哈)[_config.yml]12345678910# Sitetitle: #你的网站的名字咧subtitle: #你的网站的副标题咧description: #你的网站的描述咧author: #你的大名咧# Deploymentdeploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 千万千万不要忘记每个冒号后面都要有空格！！WTF! //3、hexo新建文章12345//新建文章$ hexo new test //默认post//新建草稿和文件夹（先别试这个）$ hexo new draft test$ hexo new page test 可以发现source文件夹下的_posts文件夹下多了一个test.md的文件， [test.md]12345---title: test //该文章标题，可以和文件名不一样的date: 2017-04-07 15:00:51tags: //标签，多个用数组[ tag1 , tag2 ]--- //4、hexo打包1$ hexo generate //打包，等同于hexo g //5、hexo同步到git1$ hexo deploy //上传git,等同于hexo d 如果出现下图，一定是前面的_config.yml里面的# Deployment部分没有配置好。 注意红色部分也要有个空格！WTF! 四、世界宇宙超级无敌酷的域名合体 五、hexo常用语句整理12345$ hexo n = hexo new //新建$ hexo s = hexo server //开启$ hexo c = hexo clean //清缓存 $ hexo g = hexo generate //打包$ hexo d = hexo deploy //上传git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nothing]]></title>
      <url>%2F2017-03-30-nothing.html</url>
      <content type="text"><![CDATA[不想撸码的时候要看看电影看看书、看看那些美丽的地方、 书单：1.《React全栈》 作者：张轩 杨寒星 2.《JavaScript高级程序设计》 3.《JavaScript语言精粹》 4.《高性能JavaScript》 电影：1.《暗夜恐惧》 8个黑白简约风高智商小故事 2.《爆裂鼓手》 一定要戴着耳机看，感觉老师才是男主，演技爆表。 3.《立春》 https://www.zhihu.com/question/28882548/answer/42426812?utm_campaign=weekly192&amp;utm_source=weekly-digest&amp;utm_medium=email 旅行攻略：1.[绿野自助户外活动](www.lvye.org) 2.[穷游网:针对国外旅游的攻略论坛](www.go2eu.com)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Babel安装、编译、配置（cmd和phpstorm）]]></title>
      <url>%2F2017-03-27-babel.html</url>
      <content type="text"><![CDATA[讲道理 这里我要找一张好看的图片（没写完啊没写完，不生气了再写） 开始Babel转码器工具：cmd、phpstorm10.0.3环境：Windows 10好多爹一样的浏览器不支持666的ES6啊！大Babel帮你ES6编译成ES5哦~省事儿~作用： ①让code支持es6 ②支持react的一些特性（eg:JSX） 安装环境12cnpm install babel-cli -gcnpm install babel-cli --save-dev 安装插件前面新建的es5.js和源文件es6.js是一毛一样的，毕竟还没有配置。 新建配置文件.babelrc1234&#123;"presets":[],"plugins":[]&#125; 安装预设1$ cnpm install --save-dev babel-preset-es2015 啊啊啊啊啊啊啊啊啊啊啊啊啊！！！！！答应我这一步千万不要用Terminal来装！！不要用Terminal来装！！不要用Terminal来装！！会炸啊会炸！！老老实实把这个项目关了去打开cmd！无响应了一个世纪、看到红色的这句话，省你一个小时时间！装完趁早吧，好气！也别轻易把node_modules给ignore，找个吃饭的时间弄，不然真当卡死。哦，还有气死！另外，如果phpstorm一直好卡一直indexing的话，可以在phpstorm.vmoptions里面，最后加上12-Dawt.usesystemAAFontSettings=lcd -Dawt.java2d.opengl=true 回归正题，在.babelrc文件里加上es2015的字段，在package.js加上对应字段。[.babelrc]1234&#123;"presets":["es2015"],"plugins":[]&#125; [package.js]123"babel": &#123; "presets": ["es2015"]&#125; 安装展开符插件1$ cnpm install babel-plugin-transform-object-rest-spread --save-dev 在.babelrc文件里加上transform-object-rest-spread的字段1234&#123;"presets":["es2015"],"plugins":["transform-object-rest-spread"]&#125; 三、编译es6文件夹底下新建es6.js123let number = [1,2,3];let double = number.map((n) =&gt; n*2);console.log(double); 如果出现红红黄黄的报错↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓File =&gt; settings =&gt; Languages =&gt; JavaScript =&gt; JavaScript language version 改为ECMAScript6 然后apply一下、 cmd编译$ babel es6.jscmd窗口的结果：123456789"use strict";/***Created by rawraw on 2017/3/27.var number = [1, 2, 3];var double2 = number.map(function (n) &#123; return n * 2;&#125;);console.log(double2); 手动编译先试一下安装的杂七杂八能不能运行起来 cmd文件 to 文件123$ babel es6/es6.js -o es5/es5.js//或者$ babel es6/es6.js --out-file es5/es5.js 文件夹 to 文件夹123$ babel es6 -d es5//或者$ babel es6 --out-dir es5 文件夹 to 文件123$ babel es6 -d es5//或者$ babel es6 --out-file es5/es5.js 直接运行es6 codebabel-node 通过phpstorm下面的terminal嗯，好，很完美。然后es5文件夹下es5.js的内容试这样子的[es5.js]123456"use strict";var number = [1, 2, 3];var double2 = number.map(function (n) &#123; return n * 2;&#125;);console.log(double2); 自动编译cmd监听123$ babel es6/es6.js -w -o es5/es5.js//或者$ babel es6/es6.js --watch --out-file es5/es5.js phpstorm添加事件监听这个时候，如果讲道理的话，自己会弹出来这个，那就很happy地点击add添加事件监听。 不讲道理的话，↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓File =&gt; settings =&gt; Tools =&gt; File Watchers =&gt; + =&gt; Babel名字随意取咯~如果这个时候apply,不设置编译后目标文件夹，默认是在该文件下生成一个js和js.mapTips:在babel监听配置之前，已存在的js文件，需要发生修改，才会触发自动编译。可以在中间回车几下。不过好丑好难过啊，还是整一个文件夹给它吧(自动编译定位在虚线内，也可以跳过啊，并没有影响) 好啦好啦，开始正式配置了、主要修改scope 和 output paths,就是编译前的文件夹和编译后的文件夹需要进行编译的文件夹：绿色框框的是哪个按钮啥意思自己去百度哈，总之就是选文件夹用的、如果这个时候apply,不设置编译后目标文件夹，默认是在该文件下生成一个js和js.map原：$FileNameWithoutExtension$-compiled.js:$FileNameWithoutExtension$-compiled.js.map改：$ProjectFileDir$\es5\$FileNameWithoutExtension$.js 并且，很稳地出现报错： 主要就是这句：Error: Couldn&#39;t find preset &quot;env&quot; relative to directory &quot;es5&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LESS环境部署]]></title>
      <url>%2F2017-03-24-less.html</url>
      <content type="text"><![CDATA[等等再发咯]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇test]]></title>
      <url>%2F2017-03-22-test1.html</url>
      <content type="text"><![CDATA[1 + 1 = 11 ? nothing测试1测试2[reset.css]1body &#123; margin: 0; padding: 0; &#125; 一、一级标题//2、二级标题红的呢]]></content>
    </entry>

    
  
  
</search>
