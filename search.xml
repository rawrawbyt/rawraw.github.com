<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PM2常用]]></title>
    <url>%2F2019-09-22-pm2.html</url>
    <content type="text"><![CDATA[定义 PM2（Process Manager 2 ）是具有内置负载均衡器的Node.js应用程序的生产运行时和进程管理器。 它允许您永久保持应用程序活跃，无需停机即可重新加载它们，并促进常见的Devops任务。 特性 日志管理：应用程序日志保存在服务器的硬盘中~/.pm2/logs/ 负载均衡：PM2可以通过创建共享同一服务器端口的多个子进程来扩展您的应用程序。这样做还允许您以零秒停机时间重新启动应用程序。 终端监控：可以在终端中监控您的应用程序并检查应用程序运行状况（CPU使用率，使用的内存，请求/分钟等）。 SSH部署：自动部署，避免逐个在所有服务器中进行ssh。 静态服务：支持静态服务器功能 安装12345npm install pm2 -g yarn global add pm2 apt update &amp;&amp; apt install sudo curl &amp;&amp; curl -sL https://raw.githubusercontent.com/Unitech/pm2/master/packager/setup.deb.sh | sudo -E bash - 常用启动服务123pm2 start app.js //启动app.js应用pm2 start app.js --name demo //启动应用并设置namepm2 start app.sh //脚本启动 停止服务123pm2 stop all //停止所有应用pm2 stop [AppName] //根据应用名停止指定应用pm2 stop [ID] //根据应用id停止指定应用 删除应用123pm2 delete all //关闭并删除应用pm2 delete [AppName] //根据应用名关闭并删除应用pm2 delete [ID] //根据应用ID关闭并删除应用 创建开机自启动1pm2 startup 更新PM212pm2 updatePM2pm2 update 监听模式1pm2 start app.js --watch //当文件发生变化，自动重启 静态服务器1pm2 serve ./dist 9090 //将目录dist作为静态服务器根目录，端口为9090 启用群集模式（自动负载均衡）123//max 表示PM2将自动检测可用CPU的数量并运行尽可能多的进程//max可以自定义，如果是4核CPU，设置为2者占用2个pm2 start app.js -i max 重新启动1pm2 restart app.js //同时杀死并重启所有进程。短时间内服务不可用。生成环境推荐使用reload 0秒停机重新加载12pm2 reload app.js //重新启动所有进程，始终保持至少一个进程在运行pm2 gracefulReload all //优雅地以群集模式重新加载所有应用程序 查看启动列表1pm2 list 查看每个应用程序占用情况1pm2 monit 显示应用程序所有信息12pm2 show [Name] //根据name查看pm2 show [ID] //根据id查看 日志查看123pm2 logs //查看所有应用日志pm2 logs [Name] //根据指定应用名查看应用日志pm2 logs [ID] //根据指定应用ID查看应用日志 保存当前应用列表1pm2 save 重启保存的应用列表1pm2 resurrect 清除保存的应用列表1pm2 cleardump 保存并恢复PM2进程1pm2 update deploy.js生成配置文件12pm2 ecosystem //生成一个示例JSON配置文件pm2 init 12345678910111213141516171819202122232425262728293031[ecosystem.config.js]module.exports = &#123; apps : [&#123; name: 'API', script: 'app.js', // Options reference: https://pm2.io/doc/en/runtime/reference/ecosystem-file/ args: 'one two', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: &#123; NODE_ENV: 'development' &#125;, env_production: &#123; NODE_ENV: 'production' &#125; &#125;], deploy : &#123; production : &#123; user : 'node', host : '212.83.163.1', ref : 'origin/master', repo : 'git@github.com:repo.git', path : '/var/www/production', 'post-deploy' : 'npm install &amp;&amp; pm2 reload ecosystem.config.js --env production' &#125; &#125;&#125;; 12345678910111213141516171819[node]const fs = require("fs");const cors = require("cors");const path = require("path");const express = require("express");const app = express();app.use(cors());app.use(express.static(path.resolve(__dirname, "./dist")));app.use(express.static("state"));app.get("*", function(req, res) &#123; const html = fs.readFileSync( path.resolve(__dirname, "./dist/index.html"), "utf-8" ); res.send(html);&#125;);app.listen(3000);]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flex]]></title>
    <url>%2F2019-09-22-flex.html</url>
    <content type="text"><![CDATA[每行3个123456789.row &#123; width: 100%; display: flex; flex-wrap: wrap; align-content: flex-start;&#125;.col&#123; flex: 0 0 33.333333%;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios内嵌webview中判断图片上传方向处理]]></title>
    <url>%2F2019-09-22-h5.html</url>
    <content type="text"><![CDATA[webview中图片裁剪或压缩的时候，获取的图片方向为拍摄时的方向； 参考]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何做好一份分享]]></title>
    <url>%2F2019-08-21-share.html</url>
    <content type="text"><![CDATA[Stay Hungry, Stay Foolish.刻意训练和精心准备，则是演讲成功的最关键的因素。所谓的优秀，都是刻意训练和长期的积累在短时间内爆发出来的，大家往往只看到短时间内惊人的爆发力，却忽略了其背后的付出与努力。 如何快速有效地提升自己。曾经，我们强调更多的是学习和思考，古语也说: 学而不思则罔，思而不学则殆。而现在，还有一种更为行之有效的方法，那就是：分享。 沟通的本质是让对方轻松地弄明白他原来并不知道的东西，更进一步，让对方通过自己已经懂的知识理解他原来并不懂的东西。 Who-What&amp;When-Why-How-Future-Recap Who: 自我介绍，让听众了解自己，建立连接； What&amp;When: 今天要分享的主题，通过简短介绍吸引听众的注意力、好奇心； Why: 为什么要做这个架构改造、技术升级，整个项目的背景是什么样的，结合对听众的了解，做特定的介绍； How: 深入浅出 3~4 个最核心的内容点，当然为了全面性，你可以都罗列出来，但介绍的重点建议控制在 3~4 项； Future: 让大家了解你未来的计划，你对技术趋势的看法等等； Recap: 对今天的主题再做一个回顾，让听众加深对核心内容记忆。 point1 逐字稿前期避免紧张必备逐字稿，充分的准备；别让正式演讲是你的第一次；时刻提醒自己要放慢语速；逐字稿 point2 PPTPPT是配角，你才是主角；多图少字；PPT保留keyword，只是提醒作用（照着ppt读，人家不如直接下载ppt）；正常流程，不要交互式的幻灯片；流程图更能清晰地表达； Who: 1 页 What&amp;When: 1~2 页 Why: 1 页 How: 展开 3~4 点，每点 2~3 页 Future: 1 页 Recap: 1 页 point3 心理紧张和焦虑感是普遍存在的，并非自己独有；确信自己的分享对听众是有价值的，会让自己信心满满; 了解需求；可以先引入话题，提出观点；适可而止，不可贪多，知识点建议控制在三点左右，这样不仅更容易让听众记住，而且自己讲的时候也比较简单，不用担心到时候忘词；不要背完整的演讲稿（实在不安可以背），记住开场和思路；要提前熟悉场地，看看演讲场地的环境，了解听众座位的布局; point4 学会讲故事 凡是能让人在脑海中产生画面感的话语或文字就是故事。 人们在听故事的时候更容易产生共情作用，也更容易理解你想要表达的信息。 讲一个好故事的核心：给听众一个期望，然后用你讲的故事填满这个期望，让人们采用你的建议和陈述，这就是故事的核心。 赋比兴； 用自己习惯的手势配合你的演讲内容就好，但是不要手足无措，比如一会儿插兜一会儿抱胸，自己不觉得，台下听众会看得非常清楚。一个非常自然的手势是“切西瓜”，伸出手臂，摊开手掌，让手掌与地面垂直，然后小幅度上下挥动。不要做出夸张的身体姿势，有病哦； （可以去看这本书《粘住》） ### 收尾时要强调重点；根据心理学中的“近因效应”：人对演讲末尾部分的印象最为深刻，记忆也最为清晰。要想让听众记住你期望他记住的 2-3 个关键点，以达到分享的目的，在收尾时的总结和强调就至关重要。]]></content>
  </entry>
  <entry>
    <title><![CDATA[node.js内存溢出]]></title>
    <url>%2F2019-08-19-nodememory.html</url>
    <content type="text"><![CDATA[转的整理； 现象 密集型运算；批量处理数据，大量循环； 操作的数据量较大；对象需要频繁的创建/销毁，或操作对象本身较大； 原因V8内存分配机制 V8本身分配的内存较小; JavaScript语言本身限制; 程序员使用不当; V8是 Google 在 Chrome 浏览器中使用的 JavaScript 引擎。而在浏览器环境中，运算一般不需要多大内存。V8 对每个进程分配的运行内存，在32位系统中约为700MB，而在64位系统中约为1.4GB。 方案 使用 async/await防止事件堆积,变为同步操作； V8 获得内存回收的机会；每次循环V8都会回收内存一次，因此内存不会再溢出。但这样做必然会造成运行效率的降低，而应该在速度在安全之间平衡，控制好循环的安全次数。说明:实际开发中，上面这种虽然解决了内存溢出，但是仍然会造成进程阻塞，可以开启一个进程/线程来解决阻塞问题深入理解Node.js 进程与线程 增加V8内存空间node --max-old-space-size=4096 app 使用非V8内存V8内存：数组、字符串等JavaScript内置对象，运行时使用“V8内存”系统内存：Buffer是一个Node.js的扩展对象，使用底层的系统内存，不占用V8内存空间。与之相关的文件系统fs和流Stream流操作，都不会占用V8内存。[fs学习]（https://mp.weixin.qq.com/s/m1SqvFaqTn3Bh2Fg9500sQ）[stream学习]（https://mp.weixin.qq.com/s/HQmualyyEV4t7lG0PZf8zQ）Buffer学习]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack config]]></title>
    <url>%2F2019-08-13-webpack.html</url>
    <content type="text"><![CDATA[打包原理webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。webpack就是识别你的 入口文件。识别你的模块依赖，来打包你的代码。webpack做的就是分析代码，转换代码，编译代码，输出代码。 webpack中每个模块有一个唯一的id，是从0开始递增的。整个打包后的bundle.js是一个匿名函数自执行。参数则为一个数组。数组的每一项都为个function。function的内容则为每个模块的内容，并按照require的顺序排列。 如何实现一个简单的webpack 读取文件分析模块依赖 对模块进行解析执行(深度遍历) 针对不同的模块使用相应的loader 编译模块，生成抽象语法树AST。 循环遍历AST树，拼接输出js。 loader原理在解析对于文件，会自动去调用响应的loaderloader 本质上是一个函数，输入参数是一个字符串，输出参数也是一个字符串。当然，输出的参数会被当成是 JS 代码，从而被 esprima 解析成 AST，触发进一步的依赖解析。webpack会按照从右到左的顺序执行loader。 打包原理 区分环境12345678910111213141516171819202122232425const fs = require('fs');const exec = require('child_process').exec;exec('git rev-parse --abbrev-ref HEAD', (_error, stdout, _stderr) =&gt; &#123; let url = stdout.replace(/^\s+|\s+$/g, ''); let pageUrl = ''; if (url === 'master') &#123; url = 'https://api.duoxuanmall.com'; pageUrl = 'https://native.duoxuanmall.com' &#125; else &#123; url = 'https://dailyapi.duoxuanmall.com'; pageUrl = 'https://dailynative.duoxuanmall.com' &#125; const content = ` export const rootUrl = '$&#123;url&#125;' export const pageUrl = '$&#123;pageUrl&#125;' ` fs.writeFile('./config/rootUrl.js', content, function (err) &#123; if(err) &#123; console.log(err); &#125;else&#123; console.log('success') &#125; &#125;)&#125;) [生成的文件]12export const rootUrl = ''export const pageUrl = '' 自定义ip&quot;dev&quot;: &quot;node bin/get_enviroment.js &amp;&amp; webpack-dev-server --config ./webpack.config.js --host 192.168.7.236 --port 8086&quot;,]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[serverlees无服务器架构]]></title>
    <url>%2F2019-08-13-serverlees.html</url>
    <content type="text"><![CDATA[学不动了学不动了 开发历史 serverlees无服务器是一种学说，而不是技术 概念]]></content>
      <tags>
        <tag>serverlees</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript要仔细学之三//阻止事件]]></title>
    <url>%2F2019-07-29-js03.html</url>
    <content type="text"><![CDATA[哈哈 这么久了，用是会用，居然迷迷糊糊，这次千万记住咯～ event.stopPropagation()方法 这是阻止事件的冒泡方法，不让事件向documen上层蔓延，但是默认事件任然会执行，当你调用这个方法的时候，如果点击一个连接，这个连接仍然会被打开。 event.preventDefault()方法 这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素，此方法可以控制一些按钮在点击时只触发时间而不会引起表单的提交。 return false； 同时阻止事件冒泡也会阻止默认事件；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault()]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序内置webview调试工具]]></title>
    <url>%2F2019-07-27-vconsole.html</url>
    <content type="text"><![CDATA[webview页面调试工具 1.yarn add vConsole2.12import VConsole from 'vconsole/dist/vconsole.min.js'let vConsole = new VConsole() // 初始化]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>vconsole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli]]></title>
    <url>%2F2019-07-18-vue-cli.html</url>
    <content type="text"><![CDATA[vue-cli3一直运行 /sockjs-node/info?t= 解决方案 sockjs-node 是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟、全双工的浏览器和web服务器之间通信通道。 服务端：sockjs-node（https://github.com/sockjs/sockjs-node）客户端：sockjs-clien（https://github.com/sockjs/sockjs-client） 如果你的项目没有用到 sockjs，vuecli3 运行 yarn serve 之后 network 里面一直调研一个接口：http://localhost:8080/sockjs-node/info?t=1462183700002 源码关闭： 找到/node_modules/sockjs-client/dist/sockjs.js第1605行 123456try &#123;// self.xhr.send(payload); 把这里注掉&#125; catch (e) &#123; self.emit('finish', 0, ''); self._cleanup(false);&#125;]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序们taro]]></title>
    <url>%2F2019-07-18-mini-program.html</url>
    <content type="text"><![CDATA[微信小程序转taro$ taro convert]]></content>
      <tags>
        <tag>taro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快应用]]></title>
    <url>%2F2019-07-18-pwa.html</url>
    <content type="text"><![CDATA[参考]]></content>
      <tags>
        <tag>pwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chorme扩展工具]]></title>
    <url>%2F2019-07-18-chorme-extend.html</url>
    <content type="text"><![CDATA[换了台笔记本，vpn也上不去了。只能瞎搞了。 React Devtools调试工具Git 地址Git 地址 git clone https://github.com/facebook/react-devtools.git 进入react-devtools文件夹，安装依赖npm --registry https://registry.npm.taobao.org install 打包一份扩展程序npm run build:extension:chrome项目目录中生成一个新的文件夹，react-devtools -&gt; shells -&gt; chrome -&gt; build -&gt; unpacked文件夹 加载打开chrome扩展程序chrome://extensions/，加载已解压的扩展程序，选择第3步中的生成的unpacked文件夹。 vue-devtoolshttps://github.com/vuejs/vue-devtoolsgit clone https://github.com/vuejs/vue-devtools.gitnpm i修改manifest.json文件把”persistent”:false改成truenpm run build选择vue-devtools&gt;shells下的chrome文件夹]]></content>
  </entry>
  <entry>
    <title><![CDATA[图床工具]]></title>
    <url>%2F2019-07-18-picgo.html</url>
    <content type="text"><![CDATA[参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发注意事项]]></title>
    <url>%2F2019-07-18-wx.html</url>
    <content type="text"><![CDATA[Input fix参考 Fix 不能设置 top0]]></content>
      <tags>
        <tag>wx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vultr 搭建 SSR]]></title>
    <url>%2F2019-07-18-ssr.html</url>
    <content type="text"><![CDATA[参考参考]]></content>
      <tags>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh哦]]></title>
    <url>%2F2019-07-18-ssh.html</url>
    <content type="text"><![CDATA[检查.ssh文件夹是否存在$ ls -al ~/.ssh 不存在新建.ssh文件夹$ mkdir ~/.ssh$ cd ~/.ssh$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;连续按三次回车id_rsa id_rsa.pub 查看公钥$ cat id_rsa.pub 将密钥复制到剪贴板pbcopy &lt; ~/.ssh/id_rsa.pub 生成多个sshssh-keygen -t rsa -C &quot;xxx@gmail.com&quot;命名id_rsa_rawraw会生成id_rsa_rawraw id_rsa_rawraw.pub]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue集合]]></title>
    <url>%2F2019-05-20-vue.html</url>
    <content type="text"><![CDATA[原理数据双向绑定Vue3之前通过get和set完成，而Vue3后通过proxy来完成。 虚拟dom一个内部的json字符串。 生命周期详细哦 bugsfor中的key[Vue warn]: Error in render: “TypeError: _self.$scopedSlots.default is not a function” 究其原因，是因为表格是element-ui通过循环产生的，而vue在dom重新渲染时有一个性能优化机制，就是相同dom会被复用，这就是问题所在，所以，通过key去标识一下当前行是唯一的，不许复用，就行了。 方案：添加 :key=”Math.random()” 优化代码v-if / v-showv-if:惰性;切换过程中条件块内的事件监听器和子组件适当地被销毁和重建;v-show:不管初始条件是什么，元素总是会被渲染;v-if 适用于在运行时不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 computed / watchcomputed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；computed适用于需要进行数值计算，并且依赖于其它数据时；因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；watch适用于需要在数据变化时执行异步或开销较大的操作时；使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if v-for 遍历必须为 item 添加 key在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。 v-for 遍历避免同时使用 v-ifv-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。百度小程序里面for和if同时使用是直接语法报错的；1234567891011121314&lt;divv-for="(key,obj) in lists":key="key"&gt;&#123;&#123; obj.name &#125;&#125;&lt;/div&gt;computed: &#123; lists: function () &#123; return this.lists.filter(function (list) &#123; return list.isActive &#125;) &#125;&#125; 懒加载图片资源懒加载 插件：yarn add vue-lazyload --save-dev [main.js]1import VueLazyload from 'vue-lazyload' 12345678Vue.use(VueLazyload)orVue.use(VueLazyload, &#123; preLoad: 1.3, error: 'dist/error.png', loading: 'dist/loading.gif', attempt: 1&#125;) vue文件 1&lt;img v-lazy="/static/img/1.png"&gt; 路由懒加载 首屏加载问题；const goodslist = () =&gt; import( /* webpackChunkName: &quot;trade&quot; */ &#39;./views/Goodslist.vue&#39;); 服务端渲染 SSR/预渲染SSR:重点优化的场景；预渲染:少量页面优化；在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。 第三方插件的按需引入 yarn add babel-plugin-component -D [.babelrc]123456789101112&#123; "presets": [["es2015", &#123; "modules": false &#125;]], "plugins": [ [ "component", &#123; "libraryName": "element-ui", "styleLibraryName": "theme-chalk" &#125; ] ]&#125; [main.js]1234import Vue from 'vue';import &#123; Button,&#125; from 'element-ui';Vue.use(Button) 长列表性能优化 Vue 会通过 Object.defineProperty对数据进行劫持，来实现视图响应数据的变化;纯粹的数据展示，不会做任何修改的数据可以通过 Object.freeze 方法来冻结一个对象；this.lists = Object.freeze(lists); 无限列表性能;vue-virtual-scroll-list 和 vue-virtual-scroller 事件的销毁Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露;123456created() &#123; addEventListener('click', this.click, false)&#125;,beforeDestroy() &#123; removeEventListener('click', this.click, false)&#125; webpack图片压缩 yarn add image-webpack-loader --save-dev [webpack.base.conf.js]123456789101112131415161718&#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, use:[ &#123; loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; loader: 'image-webpack-loader', options: &#123; bypassOnDebug: true, &#125; &#125; ]&#125; 减少 ES6 转为 ES5 的冗余代码123ES6 转为 ES5,需要以下两个辅助函数：babel-runtime/helpers/createClass // 用于实现 class 语法babel-runtime/helpers/inherits // 用于实现 extends 语法 在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。 yarn add babel-plugin-transform-runtime --save-dev [.babelrc]123"plugins": [ "transform-runtime"] 提取公共代码如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题： 相同的资源被重复加载，浪费用户的流量和服务器的成本。 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：123456789101112131415161718// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function(module, count) &#123; return ( module.resource &amp;&amp; /\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ); &#125;&#125;),// 抽取出代码模块的映射关系new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', chunks: ['vendor']&#125;) 模版预编译当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。 提取组件的 CSS当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。查阅这个构建工具各自的文档来了解更多： webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好) Browserify + vueify Rollup + rollup-plugin-vue 优化 SourceMap我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ）开发环境推荐：cheap-module-eval-source-map生产环境推荐：cheap-module-source-map原因如下： cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息； module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置； soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性； eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。 构建结果输出分析vue-cli2:webpack-bundle-analyzer[webpack.prod.conf.js]1234if (config.build.bundleAnalyzerReport) &#123; var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin());&#125; yarn run build --reportvue-cli3:[vue.config.js]12345678910111213141516171819202122module.exports=&#123; chainWebpack:config=&gt;&#123; // config.moudle // .rule('vue') // .user('vue-loader') // .loader('vue-loader') // .tap(options=&gt;&#123; // //update // return options // &#125;) // Examples //config // .plugin('hot') // .use(webpack.HotModuleReplacementPlugin); // config // .plugin('env') // .use(webpack.EnvironmentPlugin, ['NODE_ENV']); config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) &#125;&#125; if (process.env.npm_config_report) { // …}[package.json]1"analyz": "npm_config_report=true npm run build" 基础web开启 gzip 压缩gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右 yarn add compression --save 123var compression = require('compression');var app = express();app.use(compression()) 重启服务，观察网络面板里面的 response header，如果看到content-encoding的字段则表明 gzip 开启成功; 浏览器缓存;静态资源进行缓存CDN 的使用Chrome Performance 查找性能瓶颈]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖包管理npm、yarn]]></title>
    <url>%2F2019-05-16-yarn.html</url>
    <content type="text"><![CDATA[npm和yarn区别 yarnYarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化；Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。就像我们可以从官方文档了解那样，它的目的是解决这些团队使用 npm 面临的少数问题，即： 安装的时候无法保证速度/一致性 安全问题，因为 npm 安装时允许运行代码 优势 yarn.lock 文件 并行安装每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。 清晰的输出npm 默认情况下非常冗余，例如使用 npm install 时它会递归列出所有安装的信息；而 Yarn 则一点也不冗余，当可以使用其它命令时，它适当的使用 emojis 表情来减少信息（Windows 除外）。 pnpm可阅读pnpm的作者Zoltan Kochan发表的“为什么要用pnpm？” pnpm运行起来非常的快，超过了npm和yarn pnpm采用了一种巧妙的方法，利用硬链接和符号链接来避免复制所有本地缓存源文件，这是yarn的最大的性能弱点之一 使用链接并不容易，会带来一堆问题需要考虑。 pnpm继承了yarn的所有优点，包括离线模式和确定性安装]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx正向代理和反向代理]]></title>
    <url>%2F2019-05-16-nginx.html</url>
    <content type="text"><![CDATA[nginx正向代理和反向代理 正向代理的代理对象是客户端,反向代理的代理对象是服务端。 参考 正向代理正向代理:客户端 &lt;一&gt; 代理 一&gt;服务端 反向代理反向代理:客户端 一&gt;代理 &lt;一&gt; 服务端]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨浏览器开发]]></title>
    <url>%2F2019-05-16-browser.html</url>
    <content type="text"><![CDATA[重点：要脱离前端类库的跨浏览器开发 css reset Polyfill抚平不同浏览器之间对js实现的差异。 Selenium是前端工具 测试IETester让您查看 不同IE版本的页面Browsershots让你看看 不同平台上的页面Google让您搜索已知且模糊的IE变态IE 6 No More为您节省了很多麻烦，而不用担心IE 6这个名字的史前垃圾。YUI Graded Browser Support - 确保您知道要关注哪些浏览器jQquery跨浏览器javascript库YUI 3: Reset CSS重置您的CSS(链接包含有用的信息以及CSS)9 Most Common IE Bugs and How to Fix Them非常有用的提示，如何通过先解决常见问题来获得最大的收益。Cross browser development包含许多有关跨浏览器开发的有用教程。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨终端开发]]></title>
    <url>%2F2019-05-16-client.html</url>
    <content type="text"><![CDATA[Flutter]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>跨终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI七层模型与TCP/IP四层模型]]></title>
    <url>%2F2019-05-16-osi.html</url>
    <content type="text"><![CDATA[OSI七层模型与TCP/IP四层模型参考]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>OSI</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get/post请求区别]]></title>
    <url>%2F2019-05-16-getpost.html</url>
    <content type="text"><![CDATA[GET和POST本质上两者没有任何区别，是HTTP协议中的两种发送请求的方法，底层实现都是基于TCP/IP协议。 定义GET和POST是HTTP协议中的两种发送请求的方法。HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。上述的所谓区别，只是浏览器厂家根据约定，做得限制而已。HTTP请求，最初设定了八种方法。这八种方法本质上没有任何区别。只是让请求，更加有语义而已。 OPTIONS 返回服务器所支持的请求方法 GET 向服务器获取指定资源 HEAD 与GET一致，只不过响应体不返回，只返回响应头 POST 向服务器提交数据，数据放在请求体里 PUT 与POST相似，只是具有幂等特性，一般用于更新 DELETE 删除服务器指定资源 TRACE 回显服务器端收到的请求，测试的时候会用到这个 CONNECT 预留，暂无使用 万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 在万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 w3school标准答案 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。（所以中文需要URL编码） GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 重大区别GET产生一个TCP数据包；POST产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>get</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的几种方式]]></title>
    <url>%2F2019-05-15-proxy.html</url>
    <content type="text"><![CDATA[跨域的几种方式 跨域是什么一个完整的地址 = 协议 + 子域名 + 主域名 + 端口号 + 请求资源地址 JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 同源策略同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。它的存在可以保护用户隐私信息，防止身份伪造等(读取Cookie)。 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求不能发送 允许跨域加载资源的三个标签 &lt;img src=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 解决方案nginx详情见proxy websocketWebsocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 123456789101112131415161718192021//前端代码：&lt;div&gt;user input：&lt;input type = &quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var socket = io(&apos;http://www.domain2.com:8080&apos;);// 连接成功处理socket.on(&apos;connect&apos;,function()&#123; // 监听服务端消息 socket.on(&apos;message&apos;,function(msg)&#123; console.log(&apos;data from server: ---&gt; &apos;+msg );&#125;);// 监听服务端关闭 socket.on(&apos;disconnect&apos;,function()&#123; console.log(&apos;Server socket has closed.&apos;); &#125;);&#125;);document.getElementsByTagName(&apos;input&apos;)[0].onblur = function()&#123; socket.send(this.value);&#125;;&lt;/script&gt; 1234567891011121314151617181920212223242526//Nodejs socket后台：var http = require(&apos;http&apos;);var socket = require(&apos;socket.io&apos;);// 启http服务var server = http.createServer(function(req,res)&#123; res.writeHead(200,&#123; &apos;Content-type&apos;: &apos;text/html&apos; &#125;); res.end();&#125;);server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;);// 监听socket连接socket.listen(server).on(&apos;connection&apos;,function(client)&#123;// 接收信息 client.on(&apos;message&apos;,function(msg) &#123; client.send(&apos;hello：&apos; + msg); console.log(&apos;data from client: ---&gt; &apos; + msg); &#125;); // 断开处理 client.on(&apos;disconnect&apos;, function() &#123; console.log(&apos;Client socket has closed.&apos;); &#125;);&#125;); cors整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 CORS要求浏览器(&gt;IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。服务端：header(&quot;Access-Control-Allow-Origin:*&quot;);header(&quot;Access-Control-Allow-Methods:POST,GET&quot;); JSONP原理：利用 &lt;script&gt; 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。 JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）。 JSONP优点是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性。 声明一个回调函数，其函数名(如fn)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。 创建一个&lt;script&gt;标签，把那个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该函数名,通过问号传参。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串 123456&lt;script type =&quot;text/javascript&quot;&gt;function fn(data)&#123; alert(data.msg);&#125;&lt;/script&gt;&lt;script type = &quot;text/javascript&quot; src=&quot;http://test.com/jsonServerResponse?jsonp=fn&quot;&gt;&lt;/script&gt; postMessage如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和 window.open 方法打开的窗口，它们与父窗口无法通信。HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。 postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为 *，表示不限制域名，向所有窗口发送。 123456789101112131415161718//发送信息页面 http://localhost:63342/index.html&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;跨域请求&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://localhost:3000/users/reg&quot; id=&quot;frm&quot;&gt;&lt;/iframe&gt; &lt;input type=&quot;button&quot; value =&quot;OK&quot; onclick=&quot;run()&quot;&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;function run()&#123; var frm = document.getElementById(&quot;frm&quot;); frm.contentWindow.postMessage(&quot;跨域请求信息&quot;,&quot;http://localhost:3000&quot;;&#125;&lt;/script&gt; 1234//接收信息页面 http://localhost:3000/message.html window.addEventListener(&quot;message&quot;,function(e)&#123;//通过监听message事件，可以监听对方发送的消息。 console.log(e.data);&#125;,false);]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这是一个键盘]]></title>
    <url>%2F2019-04-29-keyboard.html</url>
    <content type="text"><![CDATA[code12 result]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（不记得转自哪里了）如何避免自己写的代码成为别人眼中的一坨屎！]]></title>
    <url>%2F2019-04-18-shit.html</url>
    <content type="text"><![CDATA[应该是出自某本书还是什么地方的。相信每一个优秀的工程师都有一颗追求卓越代码的心， Any fool can write code that a computer can understand. Good programmers write code that humans can understand. 普通的工程师堆砌代码，优秀的工程师优雅代码，卓越的工程师简化代码。 首先，在苍蝇眼里，一切都是屎。 一、注释 不要给不好的名字加注释，一个好的名字比好的注释更重要； 不要“拐杖注释”，好代码 &gt; 坏代码 + 好注释； 一定要给常量加注释； 团队统一定义标记： TODO 待处理的问题； FIXME 已知有问题的代码； *HACK 不得不采用的粗糙的解决方案； 在注释中用精心挑选的输入输出例子进行说明； 注释应该声明代码的高层次意图，而非明显的细节； 不要在代码中加入代码的著作信息，git可以干的事情不要交给代码； 源代码中的html注释是一种厌物, 增加阅读难度； 注释一定要描述离它最近的代码； 注释一定要与代码对应； 公共api需要添加注释，其它代码谨慎使用注释； 典型的烂注释： 不恰当的信息；废弃的注释；冗余注释；糟糕的注释；注释掉的代码； 唯一真正好的注释是你想办法不去写的注释： 不要有循规式注释，比如setter/getter注释； 不要添加日志式注释，比如修改时间等信息（git可以做的事情）； 注释一定是表达代码之外的东西，代码可以包含的内容，注释中一定不要出现； 如果有必要注释，请注释意图（why），而不要去注释实现（how)，大家都会看代码； *适当添加警示注释； 二、命名 尽可能使用标准命名方法，比如设计模式，通用学术名词等； 命名要找更有表现力的词： 使用更专业的词，比如不用get而使用fetch或者download； 避免空泛的名字，像tmp； 使用具体的名字来细致的描述事物； 给变量名带上重要的细节，比如加上单位ms等； 为作用域大的名字采用更长的名字，作用域小的使用短名字； 变量类型为布尔值表达加上is，has，can，should这样的词会更明确； 变量名称长短应该与其作用域对应； 别害怕长名称，长而具有描述性的名称比短而令人费解的名称好； 函数名称应该说明副作用，名称应该表达函数，变量或类的一切信息，请不要掩盖副作用，比如CreateAndReturnXXX； 三、方法 函数不应该有100行那么长，20行封顶最好： if else while等控制语句其中代码块应该只有一行，也就是一个函数调用语句； 函数的锁进层次不应该多于两层； *一个函数只做一件事，一个函数不应该能抽象出另外一个函数； 某个公共函数调用的私有函数紧随其后； 最理想的参数是零参数，最长不要超过三个入参，尽量不要输出参数： 如果函数传入三个及以上参数最好将其抽象为类； 标识参数十分丑陋，向函数传入布尔值用于区分不同业务的做法很丑陋，应该拆分为多个函数； 别返回null值，抛出异常或者返回特殊对象，尽量避免NPE； 别传入null值； 四、异常与错误 抽离try catch包含的代码块，其中代码块抽象为一个函数； 抛出的每个异常，都应当提供足够的环境说明，已便判断错误的来源与处所； 不要将系统错误归咎于偶然事件； 五、并发 分离并发相关代码与其它代码； 严格限制对可能被共享的数据的访问； 避免使用一个共享对象的多个同步方法； 保持同步区域微小，尽可能少设计临界区； 六、单元测试 不要怕单元测试的方法名字太长或者繁琐，测试函数的名称就像注释； 不要追求太高的测试覆盖率，测试代码前面90%通常比后面10%花的时间少； 使用最简单的并且能够完整运用代码的测试输入；； 给测试函数取一个完整性的描述性名字，比如 Test _； 测试代码与生产代码一样重要； 如果测试代码不能保证整洁，你就会很快失去他们； 每个测试一个断言，单个测试中断言数量应该最小化也就是一个断言； FIRST原则： 快速 Fast； 独立 Independent 测试应该相互独立； 可重复 Repeatable 测试应当在任何环境中重复通过； 自足验证 Self-Validating 测试应该有布尔值输出； 及时 Timely 最好的方式是TDD； 七、代码结构 代码行长度控制在100-120个字符； 可能用大多数为200行，最长500行的单个文件构造出色的系统； 关系密切的代码应该相互靠近： 变量声明应该靠近其使用位置； 若某个函数调用了另外一个，应该把他们放在一起，而且调用者应该放在被调用者上面； 自上向下展示函数调用依赖顺序； 应该把解释条件意图的函数抽离出来，尽可能将条件表达为肯定形式； 不要继承常量，比如接口中定义常量，不要使用继承欺骗编程语言的作用范围规则； 模块不应了解它所操作对象的内部情况； DTO（Data Transfer Objects）是一个只有公共变量没有函数的类； 对象暴露行为，隐藏数据； 不要使用“尤达表示法” 如 if(null == obj)，现代编译器对if(obj = null)这样的代码会给出警告； 一般情况使用if else，简单语句使用三目运算符； 通常来讲提早返回可以减少嵌套并让代码整洁； 八、设计 类应该足够短小： 类应该满足单一权责原则（SRP），类和模块只有一个修改理由； 类应该只有少量的实体变量； 类应该遵循依赖倒置原则 DIP（Dependency Inversion Principle），类应该依赖于抽象而不是依赖于具体细节； 类中的方法越少越好，函数知道的变量越少越好，类拥有的实体变量越少越好； 通过减少变量的数量和让他们尽量“轻量级”来让代码更有可读性： 减少变量； 缩小变量的作用域； 只写一次的变量更好，如常量； 最好读的代码就是没有代码： 从项目中消除不必要的功能，不要过度设计； 从新考虑需求，解决版本最简单的问题，只要能完成工作就行； 经常性地通读标准库的整个API，保持对他们的熟悉程度； 简单设计： 运行所有测试； 不可重复； 表达了程序员的意图； 尽可能减少类和方法的数量； 以上规则按重要程度排列； 无论是设计系统或者单独模块，别忘了使用大概可工作的最简单方案； 整洁的代码只提供一种而非多种做一件事的途径，他只有尽量少的依赖。明确定义并提供尽量少的API； 减少重复代码，提高表达力，提早构建，简单抽象；]]></content>
      <categories>
        <category>Rule</category>
      </categories>
      <tags>
        <tag>rule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less=>vue中引入]]></title>
    <url>%2F2019-04-18-less-vue.html</url>
    <content type="text"><![CDATA[在vue中引入less step 1npm install less less-loader --saveoryarn add less less-loader --save step2修改webpack.config.js文件，配置loader加载依赖，让其支持外部的less,在原来的代码上添加 1234&#123; test: /\.less$/, loader: &quot;style-loader!css-loader!less-loader&quot;,&#125;, or 12345678910111213 或者 @import &apos;./index.less&apos;; //引入全局less文件 ）。webpack.base.conf.js &#123; test: /\.scss$/, loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;,&quot;style-loader!css-loader!less-loader&quot;] &#125;, &#123; test:/\.less$/, loader:&apos;less-loader&apos; &#125;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp配置]]></title>
    <url>%2F2019-04-18-gulp.html</url>
    <content type="text"><![CDATA[gulp配置 config端口1234567gulp.task(&apos;connect&apos;, function () &#123; connect.server(&#123; port: 3006, livereload: true, host: &apos;0.0.0.0&apos; &#125;);&#125;); 自定义标签if_eq1234567hbs.handlebars.registerHelper(&apos;if_eq&apos;,function(v1,v2,name)&#123; if(v1 == v2)&#123; return name.fn(this) &#125;else&#123; return name.inverse(this) &#125;&#125;)]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvc/mvvm]]></title>
    <url>%2F2019-03-16-mvc.html</url>
    <content type="text"><![CDATA[mvc/mvvm区别 MVCModel View Controller Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来 众所周知，MVC 是开发客户端最经典的设计模式，iOS 开发也不例外，但是 MVC 有让人无法忽视的严重问题。 特点 Model和View永远不能相互通信，只能通过Controller传递。 Controller可以直接与Model对话（读写调用Model），Model通过Notification和KVO机制与Controller间接通信。 Controller可以直接与View对话，通过outlet,直接操作View,outlet直接对应到View中的控件,View通过action向Controller报告事件的发生(如用户Touch我了)。Controller是View的直接数据源（数据很可能是Controller从Model中取得并经过加工了）。Controller是View的代理（delegate),以同步View与Controller。 缺点View的可扩展性相当低。在通常的开发中，除了简单的 Model、View 以外的所有部分都被放在了 Controller 里面。Controller 负责显示界面、响应用户的操作、网络请求以及与 Model 交互。这就导致了 Controller： 逻辑复杂，难以维护； 和 View 紧耦合，无法测试； MVVMModel View ViewModel Controller的存在感被完全的降低了。本质上是一个精心优化的 MVC 架构；既然 View 和 Controller 是一对好基友，在 MVVM 里面，干脆把它们当做 View。现在将原来 Controller 的部分职责拆分出来由 View Model 承担，主要包括： 校验用户输入； 网络请求； 展示层的逻辑，比如格式化字符串； 其他不能放入 Model，与 View 无关的逻辑； 优点 MVVM 兼容 MVC，可以先创建一个简单的 View Model，再慢慢迁移。 MVVM 使得 app 更容易测试，因为 View Model 部分不涉及 UI。 MVVM 最好配合 binding 机制，Model 的变化需要同步到 View Model，View Model 的变化也需要同步到 View 发展史]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>mvc</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消除图片间的间隙（行内元素）]]></title>
    <url>%2F2018-09-22-img.html</url>
    <content type="text"><![CDATA[原因img标签为inline元素，该元素默认垂直对齐方式为以父元素的baseline，但是展示时又是以bottomline为对齐方式，因此造成了上下两个img标签之间的间隙 top-line/middle-line（top和bottom的中间）/base-line/bottom-line 方案1.img{ display:block}过于暴力，相当于从根本上改变了img。2.img{vertical-align:top;}改变其垂直对齐方式3.div{font-size:0};把父元素的文字大小设置为04.div{ margin-bottom:-3px };这可真low]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在table中margin 失效]]></title>
    <url>%2F2018-05-20-tem.html</url>
    <content type="text"><![CDATA[想写个某几行tr滑动的动画，发现margin在table里没有用，那我总不能特地搞个定位来弄这个动画吧。气。 当display：table,margin会不起作用 方案一border-spacing设置单元格td的边在横向和纵向上的间距。指定一个length值时，这个值将作用于横向和纵向上的间距;指定两个length值时，第一个将作用于横向间距，第二个值将作用于纵向间距。table{border-spacing:5px 10px;} 1234table&#123; border-collapse:separate; border-spacing: -15px;&#125;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm常用命令]]></title>
    <url>%2F2018-03-27-npm.html</url>
    <content type="text"><![CDATA[npm常用命令以及npm包发布 安装升级安装node以后自动会安装NPM。 淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 升级$ npm install -g npm 常用安装包$ npm install &lt;pkg&gt; 或者 $ npm install &lt;pkg&gt;@&lt;version&gt; 卸载包$ npm uninstall &lt;pkg&gt; 或者 $ npm uninstall &lt;pkg&gt;@[&lt;version&gt;] 查看当前项目下的包列表$ npm ls #查看全局包列表$ npm ls －g #清理缓存$ npm cache clean #显示包的package.json信息,后面可以跟属性名称。e.g.：$ npm view &lt;pkg&gt; versions 其中versions是package.json的versions属性$ npm view &lt;pkg&gt; [attribute] 发布自己的npm包登陆第一次：$ npm adduser输入password的时候会自动隐藏，管自己输就好了然后邮箱一直enter不了，一直报e400的错。然后想到之前装的淘宝镜像。然后就用cnpm就完全o**k！！所以 所有的命令行 自己自动都改c吧，懒得一个个改了。not 第一次：$ npm login 查看当前用户$ npm whoami 发布$ npm init动次打次 怼怼怼$ npm publish$ npm publish &lt;pkg&gt;@&lt;version&gt; 报错集合ERR 403:包名字重了npm please try running this command again as root：未登录 迭代$ npm publish &lt;pkg&gt;@&lt;version&gt; 快速升级方法小版本号升级一个版本$ npm version patch 中版号升级一个版本$ npm version minor 大版本号升级一个版本$ npm version majornpm社区版本号规则采用的是semver(语义化版本)，主要规则如下：版本格式：主版号.次版号.修订号，版号递增规则如下： 主版号：当你做了不相容的 API 修改， 次版号：当你做了向下相容的功能性新增， 修订号：当你做了向下相容的问题修正。 先行版号及版本编译资讯可以加到「主版号.次版号.修订号」的后面，作为延伸。 删除不能删除整个包，只能某个版本$ npm unpublish &lt;pkg&gt;[@&lt;version&gt;]]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animation整理]]></title>
    <url>%2F2018-03-27-animation.html</url>
    <content type="text"><![CDATA[清电脑翻出一堆以前做的demo。 组件导航栏 特效云墙]]></content>
      <categories>
        <category>Frontend-work</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暂放]]></title>
    <url>%2F2018-03-23-temporay.html</url>
    <content type="text"><![CDATA[偶尔翻到以前的笔记，先都堆在这放放，晚点整理； 20160710：1.angular 对应的路由路径/回调不能为空 20160817：1.iphone4.5 偶尔不支持vh /vw的！！！（vh用，反正要写媒体查询） 20160810：自动换行 word-break:break-all和word-wrap:break-word 构建混合移动应用的流行框架优缺点对比 Angular中ng-view 和ui-view区别ui-router是angular-ui下的一个模块angular-ui，可以嵌套。ng-view不可以嵌套 Keypress keydown keyup 区别]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端兼容性整理以及优化]]></title>
    <url>%2F2018-03-23-compatibility.html</url>
    <content type="text"><![CDATA[移动端兼容性整理 插件Modernizr：兼容CSS3、HTML5新特性 Listcontenteditable元素只能输入纯文本-webkit-user-modify: read-only|read-write|read-write-plaintext-only IE6-8和FF3-浏览器不支持”:nth-child”选择器:nth-child(2n),:nth-child(even):nth-child(n+5)这个选择器是选择从第五个元素开始选择:nth-child(4n+1)这种方法是实现隔几选一的效果，比如我们这里是隔三选一::selectionuser-select:none 优化增加该属性，可以增加弹性（在绝对定位的时候会用到）-webkit-overflow-scrolling: touch; 输入法开始中文输入时会触发compositionstart事件选词结束后会触发compositionend事件]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础小结]]></title>
    <url>%2F2018-03-19-cssbase.html</url>
    <content type="text"><![CDATA[css tips~ 初始化 不同浏览器的一些标签的默认值不同 盒子模型默认为box-sizing是content-box；标准盒子模型（content-box）：宽度=内容的宽度（content）+ border + padding + margin低版本IE盒子模型（border-box）：宽度=内容宽度（content+border+padding）+ margin 选择器id、类、标签选择器、相邻选择器、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器 优先级算法元素选择符： 1class选择符： 10id选择符：100元素标签：1000!important 继承性盒子属性不可继承可继承的属性：font-size, font-family, color不可继承的样式：border, padding, margin, width, height 居中自己去翻那篇居中的有空来放个链接 a的hover顺序 a:link {} a:visited {} a:hover {} a:active {} 隐藏的几种方法1.display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）2.visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）3.层级z-index4.定位定到天边去吧 chrome中，使用visibility：collapse值和使用hidden没有区别。firefox，opera和IE，使用collapse值和使用display：none没有什么区别。 float清浮动:伪类浮动元素的display:block CSS3新特性 rgba background-image background-origin(content-box/padding-box/border-box) background-size background-repeat word-wrap：break-word text-shadow： 1px 1px 1px #666666; border-radius border-image: url(border.png) 30 30 round box-shadow: 10px 10px 5px #666666 font-face属性：定义自己的字体 媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性 兼容性问题 IE6双边距bug块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。 渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 123456&#123;background-color:#f1ee18;/*所有识别*/.background-color:#00deff9; /*IE6、7、8识别*/+background-color:#a200ff;/*IE6、7识别*/_background-color:#1e0bd1;/*IE6识别*/&#125; 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。 IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 BFC规范(块级格式化上下文：block formatting context)定位方案： 内部的Box会在垂直方向上一个接一个放置。 Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。 每个元素的margin box 的左边，与包含块border box的左边相接触。 BFC的区域不会与float box重叠。 BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 计算BFC的高度时，浮动元素也会参与计算。 满足下列条件之一就可触发BFC 根元素，即html float的值不为none（默认） overflow的值不为visible（默认） display的值为inline-block、table-cell、table-caption position的值为absolute或fixed 举个栗子：上下margin重合的问题：在重合元素外包裹一层容器，并触发该容器生成一个BFC。overflow: hidden; 响应式设计一个网站能够兼容多个终端，通过媒体查询检测不同的设备屏幕尺寸做处理。&lt;meta name=&quot;’viewport’&quot; content=&quot;”width=device-width,&quot; initial-scale=&quot;1.&quot; maximum-scale=&quot;1,user-scalable=no”&quot;/&gt; 媒体查询 :&lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only screen and (max-device-width:480px)”&gt; CSS : @media only screen and (max-device-width:480px) 浏览器是怎样解析CSS选择器的？CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。 在网页中的应该使用奇数还是偶数的字体？为什么呢？使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。 怎么让Chrome支持小于12px 的文字？ p{font-size:10px;-webkit-transform:scale(0.8);} 让页面里的字体变清晰 只在ioswebkit-font-smoothing：antialiased 灰度平滑 android：position:fixed无效&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt; 手动写动画的最小时间间隔是多久多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。 inline-block间隙float/font-size:0、letter-spacing、word-spacing 行内级元素末尾实现换行,用伪元素代替1234.test::after&#123; content: "A";//0x000A,00A white-space: pre;&#125; 百分比的padding和margin的依据都是父元素的width 视差滚动插件：parallax-scrolling 多行文本垂直居中：需要设置display属性为inline-block。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IoC理念]]></title>
    <url>%2F2018-03-07-ioc.html</url>
    <content type="text"><![CDATA[vue这么火react这么火，该看看IoC咯~现在都喜欢对项目拆解成多个模块/组件来组合使用，以此提高code复用性。一个复杂组件总会依赖其他组件来协同完成某个逻辑功能。组件越复杂，依赖越多，可复用性就越差。然后我们就可以用一下这个IoC理念咯。嗯，一种全新的设计模式。 定义 IoC 全称 Inversion of Control，中文术语为依赖倒置（反转），包含两个准则： 1.高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象 2.抽象不应该依赖于具体实现，具体实现应该依赖于抽象 核心思想：面向接口编程。 举个栗子哇 炸，再理解一下。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序是真的讨厌]]></title>
    <url>%2F2018-03-01-wechatfuck.html</url>
    <content type="text"><![CDATA[微信小程序出现好久了，一直没仔细了解。从一开始就是莫名的排斥，公司关于小程序的项目也是都直接丢给新人。今天抖音刷到一个吃饭吃什么的段子，就想说这很easy,自己写一个玩一下啊。嗯，写一个放哪儿，那就小程序吧。但是好像一点都不酷，嗯，那我给它做成云标签墙吧。 想象中，一切都很美好。 START原来做过一个小demo是这样子的。 讲道理一堆食物这样子滚应该很诱人吧。然后就开始一边看看文档一边写。一切顺利地进行到这一步 QUESTIONgetElement可以直接标签内操作，但是烦。 appendChild可以用模板做，但是烦。而且无限的append的好像就有点难做了。]]></content>
      <categories>
        <category>oh my bug</category>
      </categories>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo提交问题]]></title>
    <url>%2F2018-02-28-bug20180228.html</url>
    <content type="text"><![CDATA[fatal: could not read Username for &#39;https://github.com&#39;:No error巴拉巴拉今天在提交git的时候，居然炸了，说是找不到username，然而config也没改过啊，生气。 TRY尝试一原因：https方式的时候 在git remote add origin 的https url 里面没有用户名和密码方案：git remote add origin https://{username}:{password}@github.com/{username}/project.git或者直接修改.git/config隐藏文件为 git remote add origin https://{username}:{password}@github.com/{username}/project.git格式结果：查了N次，用户名都是对的，添加了N次，都是已存在。 尝试二原因：如果安装git客户端的时候没有勾选git命令在bash和cmd命令都有效，若是在cmd命令下则因为没有将git添加到windows的path。方案：在blog的目录打开git bash再尝试hexo d。结果：然并卵 尝试三原因：git的版本bug方案：查看git版本git version结果：我的是2.12.2windows.2。$ git clone git://git.kernel.org/pub/scm/git/git.git用这个更新之后还是2.12.2.所以直接官网下载了2.16.2的安装包。https://git-scm.com/download/win搞了好久的vpn啊，还好最后升级之后真的解决了问题！开心值+100！！！]]></content>
      <categories>
        <category>oh my bug</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018-01-27-gitstudy.html</url>
    <content type="text"><![CDATA[git常用命令 入门学习githug通关宝典 代码冲突服务器代码合并本地代码123$ git stash //暂存当前正在进行的工作。$ git pull origin master //拉取服务器的代码$ git stash pop //合并暂存的代码 服务器代码覆盖本地代码12$git reset --hard //回滚到上一个版本$git pull origin master 更换git地址$ git remote set-url origin 合并一条$ git merge --squash another$ git commit –amend –no-edit(git commit –amend -m &#39;xxxxx&#39;)//合并上一次commit git pll 和 git fetchgit pull = git fetch + git merge如果git fetch,git log -p master..origin/master //比较本地的master分支和origin/master分支的区别如果git pull，容易error: You have not concluded your merge (MERGE_HEAD exists).解决方案： 保留本地代码 123$:git merge --abort //中止合并$:git reset --merge //重新合并$:git pull//重新拉取 放弃本地代码，保留远端代码 123$:git fetch --all$:git reset --hard origin/master$:git fetch git pull 提示错误,Your local changes to the following files would be overwritten by merge 服务器代码合并本地代码 123$ git stash //暂存当前正在进行的工作。$ git pull origin master //拉取服务器的代码$ git stash pop //合并暂存的代码 服务器代码覆盖本地代码 12$git reset --hard //回滚到上一个版本$git pull origin master git merge 和 git rebasegit rebase -i 命令来压缩合并两次提交git rebase -i HEAD~2?git rebase --onto在分支上，执行git rebase master，有冲突就解决冲突，解决后直接git add . 再git rebase –continue，切换到master分支，执行git merge dev看看 一、安装git升级$ git clone git://git.kernel.org/pub/scm/git/git.git 二、配置查看用户名和邮箱$ git config user.name$ git config user.email 修改用户名和邮箱$ git config --global user.name$ git config --global user.email 初始化一个版本仓库$ git init Clone远程版本库$ git clone addr. 添加远程版本库origin$ git remote add origin addr. 查看远程仓库$ git remote -v 三、提交你的修改添加当前修改的文件到暂存区$ git add . 如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件$ git add -u 提交你的修改$ git commit –m &amp;quot;你的注释&amp;quot; 推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支]$ git push origin master 查看文件状态$ git status 跟踪新文件$ git add readme.txt 从当前跟踪列表移除文件，并完全删除$ git rm readme.txt 仅在暂存区删除，保留文件在当前目录，不再跟踪$ git rm –cached readme.txt 重命名文件$ git mv reademe.txt readme 查看当前分支的存在提交历史记录$ git log不包括诸如删除的或被合并的提交 查看当前分支所有操作历史$ git reflog诸如历史提交记录，撤销，合并提交等详细历史记录 修改最后一次提交注释的，利用–amend参数$ git checkout –- readme.txt 四、基本的分支管理创建一个分支$ git branch workspace 切换工作目录到workspace$ git chekcout workspace 将上面的命令合在一起，创建workspace分支并切换到workspace$ git chekcout –b workspace 合并workspace分支，当前工作目录为master$ git merge workspace 合并完成后，没有出现冲突，删除workspace分支$ git branch –d workspace 拉去远程仓库的数据，语法为 git fetch [remote-name]$ git fetch fetch 会拉去最新的远程仓库数据，但不会自动到当前目录下，要自动合并$ git pull 查看远程仓库的信息$ git remote show origin 五、合并合并的commit的前一个commit节点$ git rebase -i （commitHash）pick：简写p，启用该commit；reword：简写r，使用该commit，但是修改提交信息，修改后可以继续编辑后面的提交信息；edit：简写e，使用commit，停止合并该commit；squash：简写s，使用该commit，并将该commit并入前一commit；drop：简写d，移除该commit； 六、撤销撤销一个提交的同时会创建一个新的提交$ git revert head@{19}撤销提交时若多个提交修改了同一文件可能会出现冲突，需要处理冲突后，暂存：$ git add.然后继续执行revert操作：$ git revert --continue 期望撤销的提交是最近独立存在的，并没有发生合并$ git reset （commitHash）]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件夹命名习惯]]></title>
    <url>%2F2018-01-07-name.html</url>
    <content type="text"><![CDATA[常用的项目目录文件命名 config 配置文件 static 静态资源 src,source 源代码 examples，demo 示例 docs 文档 plugins 插件 lib library,库文件 component 组件 dist distribution,打包编译后的文件 less,sass,typescript,es6 test,tests,test 测试文件 benchmarks 测试版本的性能变化 units,spec 单元测试 e2e 端对端测试 build,script 构建脚本 utils,tools,helpers 工具代码 models,views,controllers,middlewares MVC，中间件 router 路由 server 服务端代码 adapters 适配器模式 legacy 兼容历史版本或者浏览器的代码 bin 命令脚本，命令行工具 common 公用文件 packages 打包多个npm包,减小体积 core 核心文件 misc 杂项]]></content>
      <categories>
        <category>rule</category>
      </categories>
      <tags>
        <tag>rule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端语音播报问题集合]]></title>
    <url>%2F2017-12-19-sound.html</url>
    <content type="text"><![CDATA[突然想到之前一个项目的问题，当时手忙脚乱糊弄地解决了一下。打卡签到，播放“XXX,签到成功”。判断一个人的语音提示是否播报完成？或者打断？ 文本生成语音1234567891011121314151617181920var speaker = new window.SpeechSynthesisUtterance();var speakTimer, stopTimer;// 开始播报function speakText(text) &#123; clearTimeout(speakTimer); window.speechSynthesis.cancel(); speakTimer = setTimeout(function () &#123; speaker.text = text; window.speechSynthesis.speak(speaker); &#125;, 200);&#125;// 停止播报function stopSpeak() &#123; clearTimeout(stopTimer); clearTimeout(speakTimer); stopTimer = setTimeout(function () &#123; window.speechSynthesis.cancel(); &#125;, 20);&#125; APISpeechSynthesis 参数 含义 paused 是否暂停 pending 是否处理中 speaking 是否朗读中 onvoiceschanged 声音变化时触发 cancel() 情况待朗读队列 getVoices() 获取浏览器支持的语音包列表 pause() 暂停 resume() 重新开始 speak() 读合成的语音，参数必须 SpeechSynthesisUtterance 参数 含义 lang 语言 pitch 音高 rate 语速 text 文本 voice 声音 volume 音量 onboundary 单词或句子边界触发，即分隔处触发 onend 结束时触发 onerror 错误时触发 onmark onpause 暂停时触发 onresume 重新播放时触发 onstart 开始时触发]]></content>
      <categories>
        <category>oh my bug</category>
      </categories>
      <tags>
        <tag>question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018前端学习计划]]></title>
    <url>%2F2017-12-19-plan2018.html</url>
    <content type="text"><![CDATA[再堕落下去，要是个废人了。开始好好学习，天天向上咯！小小列个清单先~ 旧的要巩固基础 结构：HTML/HTML5 样式：CSS/CSS3/canvas/svg/vr/webGL 逻辑：JavaScript/jQuery 地图：摸清天地图，一切地图不是事儿 数据:数据库/php(后台小哥哥的东西，看看会cv就好) 服务：node 兼容性：web和移动端/各浏览器 框架全家桶 vue+vuex+vue+router+axios react+ Angular(找时间看2啊) 构建 LESS/SASS TypeSript webpack+npm/yarn 代码规范 es6 小技能 gif录制，用啥软件来着，记得回去翻翻 新的要学学学学学！嘿嘿~特效，公式撸起来 贝塞尔曲线原理 视差原理 阻尼公式 新框架 express框架 koa框架 egg.js(天猫)]]></content>
      <categories>
        <category>TODO</category>
      </categories>
      <tags>
        <tag>daydayup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 1 vs. Angular 2]]></title>
    <url>%2F2017-07-21-angularcompare.html</url>
    <content type="text"><![CDATA[Angular 1 对比 Angular 2 get Angular 2.0cnpm install angular@2.0.0-alpha.6 比较1.双向数据绑定单向数据绑定2.0中会有方法实现双向绑定，虽然实现的背后数据是单向的。这听起来很像React的Flux所做的工作。这种结构也可以被Angular来使用。 2.观察器Zone.js$scope.$watch, $scope.$apply, $timeout这些都不在需要了，这也是1.x版本有如此之大的学习曲线的原因。Zone.js可以帮Angular实现变化的自动检测。这听起来很像React的差异比较算法。 3.组件通信2.0：除了$broadcast 和 $emit，2.0还有一些小得变化，1）你可以在DOM层发送消息，而不是在scope；2）你可以组件嵌套，然后link他们，这看上去很像每个组件都使用它们独立的scope。 4. DOM2.0：从很多方面可以看出，Angular 2.0对于DOM样式的操作很像React的virtual DOM，它引用的是最近呈现的view层。关于Angular Native，Misko提到，这个view层可以运行于web worker，甚至是native。 5. scope6. 模块2.0将肯定使用ES6的模块语法。同时，2.0还希望通过懒加载来引入依赖注入。和以往通过单例方式管理不同的是，2.0希望使用一种层次化数据结构来提供继承特性。你将能够控制模块的生命周期，比如services。 7. 指令8. Router9. HTML参考]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>angularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js学习]]></title>
    <url>%2F2017-07-20-node.html</url>
    <content type="text"><![CDATA[Node.js是一个Javascript运行环境(runtime)。简单的说 Node.js 就是运行在服务端的 JavaScript。用于方便地搭建响应速度快、易于扩展的网络应用。 一、定义浏览器内核实际上分为两个部分:渲染引擎和 JavaScript 引擎。前者负责渲染 HTML + CSS，后者则负责运行 JavaScript。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 适用场景 实时性应用，比如在线多人协作工具，网页聊天应用等。 以 I/O 为主的高并发应用，比如为客户端提供 API，读取数据库。 流式应用，比如客户端经常上传文件。 前后端分离。 RESTful API 这是NodeJS最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求API，组织数据进行返回即可。它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的API需求。 统一Web应用的UI层 目前MVC的架构，在某种意义上来说，Web开发有两个UI层，一个是在浏览器里面我们最终看到的，另一个在server端，负责生成和拼接页面。 大量Ajax请求的应用 例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起Ajax请求，NodeJS能响应大量的并发请求。 总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。 局限性 不适合 CPU 密集型的任务，比如人工智能方面的计算，视频、图片的处理等。 辅助概念的理解并发非阻塞 I/O网络 I/O文件 I/O事件循环数据流]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS hack]]></title>
    <url>%2F2017-07-07-hack.html</url>
    <content type="text"><![CDATA[待整理。目前还不怎么需要，先搜集了一下网上大家的方法，以后方便看咯。 概念 由于不同种类的浏览器（Internet Explorer,Safari,Mozilla Firefox,Chrome...）或者同一浏览器的不同版本 对CSS的解析认识不一样，导致生成的页面效果不一样。针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。 整理IE 6 1234* html #footer &#123; position:absolute; top:expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+&apos;px&apos;);&#125; Selector Hacks12/* IE6 and below */* html #uno &#123; color: red &#125; 12/* IE7 */*:first-child+html #dos &#123; color: red &#125; 12/* IE7, FF, Saf, Opera */html&gt;body #tres &#123; color: red &#125; 12/* IE8, FF, Saf, Opera (Everything but IE 6,7) */html&gt;/**/body #cuatro &#123; color: red &#125; 12/* Opera 9.27 and below, safari 2 */html:first-child #cinco &#123; color: red &#125; 12/* Safari 2-3 */html[xmlns*=&quot;&quot;] body:last-child #seis &#123; color: red &#125; 12/* safari 3+, chrome 1+, opera9+, ff 3.5+ */body:first-of-type #ocho &#123; color: red &#125; 12/* saf3+, chrome1+ */@media screen and (-webkit-min-device-pixel-ratio:0) &#123;#diez &#123; color: red &#125;&#125; 12/* iPhone / mobile webkit */@media screen and (max-device-width: 480px) &#123;#veintiseis &#123; color: red &#125;&#125; 12/* Safari 2 - 3.1 */html[xmlns*=&quot;&quot;]:root #trece &#123; color: red &#125; 12/* Everything but IE6-8 */:root *&gt; #quince &#123; color: red &#125; 12/* IE7 */*+html #dieciocho &#123; color: red &#125; 12/* Firefox only. 1+ */#veinticuatro, x:-moz-any-link &#123; color: red &#125; 12/* Firefox 3.0+ */#veinticinco, x:-moz-any-link, x:default &#123; color: red &#125; Attribute Hacks12/* IE6 */#once &#123; _color: blue &#125; 12/* IE6, IE7 */#doce &#123; *color: blue; /* or #color: blue */ &#125; 12/* Everything but IE6 */#diecisiete &#123; color/**/: blue &#125; 12/* IE6, IE7, IE8 */#diecinueve &#123; color: blue\9; &#125; 12/* IE7, IE8 */#veinte &#123; color/*\**/: blue\9; &#125; 12/* IE6, IE7 -- acts as an !important */#veintesiete &#123; color: blue !ie; &#125; /* string after ! can be anything */]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>兼容</tag>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript要仔细学之二//闭包]]></title>
    <url>%2F2017-06-28-js02.html</url>
    <content type="text"><![CDATA[不得不看之闭包–闭包是一种使函数能够都去其它函数的局部变量的语法机制。 现象1234567891011function User()&#123; this.name = "Vicfeel"; //共有属性 var age = 23; //私有属性 this.sayAge:function()&#123; console.log("my age is " + age); &#125;&#125;var user = new User();console.log(user.name); //"Vicfeel"console.log(user.age); //"undefined"user.sayAge(); //"my age is 23" 一个栗子 问题:点击列表输出对应的索引（用JS，非JQ） 123456789101112&lt;ul&gt; &lt;li&gt;哈哈哈&lt;/li&gt; &lt;li&gt;嘤嘤嘤&lt;/li&gt; &lt;li&gt;嘿嘿嘿&lt;/li&gt; &lt;li&gt;啦啦啦&lt;/li&gt; &lt;li&gt;略略略&lt;/li&gt; &lt;li&gt;嘻嘻嘻&lt;/li&gt; &lt;li&gt;呵呵呵&lt;/li&gt; &lt;li&gt;哒哒哒&lt;/li&gt; &lt;li&gt;嘁嘁嘁&lt;/li&gt; &lt;li&gt;哟哟哟&lt;/li&gt;&lt;/ul&gt; 可能有小可爱会这样做:1234567var lis = document.querySelectorAll('ul li');var len = lis.length;for(var i = 0; i &lt; len; i++) &#123; lis[i].addEventListener('click', function () &#123; console.log(i); &#125;, false);&#125; 运行结果是，不管点击哪个列表，结果输出的都是10。 var声明的变量是函数作用域的，而不是块级作用域的。也就是说，for循环10次，每次都是改变同一个i，所以它的值会从0一直加到10。 闭包保存的是外部变量的引用，而不是值。也就是说，循环10次监听器创建了10 个闭包，它们里面的i引用的是同一个啊。所以全部都指向了10。 解决方案let替代var但是涉及到es6,出于兼容性的考虑，还要做转译，还是微微有点不开心1234567var lis = document.querySelectorAll('ul li');var len = lis.length;for(let i = 0; i &lt; len; i++) &#123; lis[i].addEventListener('click', function () &#123; console.log(i); &#125;, false);&#125; 立即执行函数(切断闭包)123456789var lis = document.querySelectorAll('ul li');var len = lis.length;for(var i = 0; i &lt; len; i++) &#123; (function (i) &#123; lis[i].addEventListener('click', function () &#123; console.log(i); &#125;, false); &#125;)(i)&#125; 事件委托(避开闭包)12345678var ul = document.querySelector('ul');var lis = ul.querySelectorAll('li'); ul.addEventListener('click', function (e) &#123; var target = e.target; if(target.nodeName.toLowerCase() === 'li') &#123; console.log([].indexOf.call(lis, target)); &#125;&#125;, false);]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鹅厂小事件]]></title>
    <url>%2F2017-06-21-tencent.html</url>
    <content type="text"><![CDATA[鹅厂啊鹅厂 鹅厂企业邮箱鹅厂企业邮箱pop设置：pop.exmail.qq.comci]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript模块规范:CommonJS和AMD]]></title>
    <url>%2F2017-06-20-modulerule.html</url>
    <content type="text"><![CDATA[目前，通行的Javascript模块规范有两种：CommonJS和AMD。 CommonJS 在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。 假定有一个数学模块math.js，就可以像下面这样加载。[math.js]12var math = require('math');math.add(2,3); // 5 ,调用模块提供的方法 CommonJS规范不适用于浏览器环境。第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 ## AMD规范 全称：Asynchronous Module Definition（异步模块定义）它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：require([module], callback);上述的例子：123 require(['math'], function (math) &#123; math.add(2, 3); &#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rawraw的github]]></title>
    <url>%2F2017-06-20-github.html</url>
    <content type="text"><![CDATA[rawraw的github项目的快速链接 bundler browserify webpack RequireJS/AMD taskrunner Grunt Gulp git常用]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>链接</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5/JavaScript/CSS书写规范]]></title>
    <url>%2F2017-06-14-norm.html</url>
    <content type="text"><![CDATA[作为强迫症，就是特别喜欢介个样子// HTML5头部12345678&lt;!DOCTYPE html&gt;&lt;meta charset="utf-8"&gt;&lt;meta name="viewport" content="width=device-width"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge" /&gt;&lt;meta name="description" content=""&gt;&lt;meta name="keywords" content=""&gt; &lt;title&gt;HTML5 standardization&lt;/title&gt;//type属性：省略 区分浏览器no-js标签是需要与Modernizr等类库配合使用的&lt;script src=&quot;js/libs/modernizr-2.5.0.min.js&quot;&gt;&lt;/script&gt;1234&lt;!--[if lt IE 7]&gt; &lt;html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="zh"&gt; &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; &lt;html class="no-js lt-ie9 lt-ie8" lang="zh"&gt; &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; &lt;html class="no-js lt-ie9" lang="zh"&gt; &lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;&lt;!--&gt; &lt;html class="no-js" lang="zh"&gt; &lt;!--&lt;![endif]--&gt; 避免IE6条件注释引起的高版本IE文件阻塞问题 与Modernizr等特征检测类库使用相同的class，更具备通用性 优于使用CSS Hack 嵌套规则 块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素； 里面不能放块级元素； 块级元素与块级元素并列、内嵌元素与内嵌元素并列； 文档内容 自定义属性：data-* 不要使用内联样式 不要使用和,用css来控制。不要使用和，HTML5不赞成使用 实体字符引用 字符 实体名 实体数 “ &amp;quot; &amp;#34; ‘ &amp;apos;(IE不支持) &amp;#39; &amp; &amp;amp; &amp;#38; &gt; &amp;gt; &amp;#62; &lt; &amp;lt; &amp;#60; &nbsp; &amp;nbsp; &amp;#160; &emsp; &amp;emsp; &amp;#12288; ￥&yen; &amp;yen; &amp;#165; &brvbar; &amp;brvbar; &amp;#39; &copy; &amp;copy; &reg; &amp;reg; &amp;#169; &trade; &amp;trade; &amp;#8428; &middot; &amp;middot; &amp;#183; &laquo; &amp;laquo; &amp;#171; &raquo; &amp;raquo; &amp;#187; &deg; &amp;deg; &amp;#176; &times; &amp;times; &amp;#215; &divide; &amp;divide; &amp;#247; &permil; &amp;permil; &amp;#8240; 图片 给图片添加width和height，提升页面加载速度 给所有img添加alt属性 不要使用或尽量少用gif文件 CSS引用结构按照顺序引入CSS 一律写在 CSS 文件中，原则上不写内联样式，不直接为标签添加样式（reset 除外）。 基础框架（reset / grid …） 通用模块（theme/ common…） 页面样式（page…） 命名规范 CSS对大小写敏感 不采用驼峰式命名，不用中文拼音 不允许使用具体的样式名称命名，也不应包含颜色、位置等与现实效果相关的信息。 加上适当的命名空间（前缀），以避免命名冲突。命名空间不使用单个字母，以免与通用样式冲突。 文件命名CSS 文件命名由小写字母、下划线（_）组成。 选择器命名CSS 文件命名由小写字母、中划线（-）组成。|布局（grid） .g-|模块（module） .m-|元件（unit）|功能（function）|状态 .z-|皮肤（skin） .s-|JS选择器 .j-| 书写规范 ;分行书写 属性值为 0 时，单位可以省略。 属性值为小数时，小数点之前的 0 不可以省略。 省略 url 中的引号，其他需要引号的地方使用单引号。 书写顺序属性| 显示属性 | display, visibility, position, float, clear, list-style, top 等 || 自身属性 | width, height, margin, padding, border, overflow 等 || 文本及修饰属性 | font, text-align, text-decoration, vertical-align, white-space, color, background 等 || CSS3 属性 | border-radius, box-shadow, gradients, transforms, animations 等 | 链接a:link -&gt; a:visited -&gt; a:hover -&gt; a:active 优化合并选择器属性值缩写 margin padding border background font color list-style 避免耗性能的属性 width: expression(this.width&gt;100?&#39;100px&#39;:&#39;auto&#39;); filter: alpha(opacity=50); 图片合并（sprite）文件压缩JavaScript使用===/!====和!=不判断类型 特殊情况在判断函数是否为空的情况下，使用==或!=是可以的。12345//如果foo没有被初始化，它默认的值是undefined而不是null。当然underfined更不会等于null了。//因此这种情况应该使用==和!=。if (foo == null) &#123; ...&#125; DELETE在数组中数组可以被DELETE，但是会留下undefined元素。可以用shift( )/pop( )/splice(index,num)1234var myArray = [ 'a', 'b', 'c', 'd' ];delete myArray[2]; // Noncompliant. myArray =&gt; ['a', 'b', undefined, 'd']console.log(myArray[2]); // 'undefined' for...in..的循环在每次操作前需要进行过滤判断“for … in”这种循环允许开发人员按照属性的名字遍历对象。不幸的是，这个属性的集合包括了对象自身和对象继承的对象的所有属性。如果程序不考虑这点就会出现错误。都应该包括一个if判断来过滤你需要的属性。12345for (name in object) &#123; if (object.hasOwnProperty(name)) &#123; doSomething(name); &#125;&#125; NaN不要出现在比较中NAN不等于包括自身在内的任何值。因此与NAN作比较是得不到你需要的结果的，但是这种错误有可能会出现。事实上，判断值是否等于NAN最好的方法就是和它自己作比较即NAN!==NAN，因为正常的变量都是等于自身的，如果不等于自身成立，就说明这个值是NAN。 保证函数调用时传入的参数都被使用12345678function doSomething(a, b) &#123; compute(arguments);&#125;doSomething(1, 2, 3) function say(a, b) &#123; print(a + ' ' + b);&#125;say('hello', 'world', '!'); 选择器得到的结果一定要用LENGTH判断无论是否找到该对象，选择器总是返回一个对象。123456if ($('.test')) &#123; // ... &#125;if ($('.test').length &gt; 0) &#123; // ...&#125; 用逻辑短路防止出现空的错误123456789101112if (str != null &amp;&amp; str.length == 0) &#123; console.log('String is empty');&#125;if (str != undefined &amp;&amp; str.length == 0) &#123; console.log('String is empty');&#125;if (str == null || str.length &gt; 0) &#123; console.log('String is not empty');&#125;if (str == undefined || str.length &gt; 0) &#123; console.log('String is not empty');&#125; 易错点 用null,不要用undefined（尚未创建）赋值给变量。 var i = 0;i = i++; parseInt函数有两个版本的，一个是只有一个参数的，而另一个是需要两个参数的。然而，旧版的浏览器不支持一个参数的parseInt方法。parseInt(&quot;010&quot;, 10); 性能优化 var input = $( &#39;form input[type=radio]&#39; );代替var input = $( &#39;form input:radio&#39; ); var $productIds = $(&#39;#products&#39;).find(&#39;div.id&#39;);代替var $productIds = $(&#39;#products div.id&#39;); 选择结果应该被保存，var paragraph = $(&#39;p&#39;);paragraph.hide();paragraph.show(); 尽量不要通配选择器$( &#39;.buttons&#39; ).children();代替`$( ‘.buttons &gt; ‘ ); ` 使用===/!==，==和!=不判断类型 约定规范 每一条声明须要由“;”结尾 注释不应该写在每一行的最后面；一行代码不要太长（不超过80）；多分行分行 文件后面应该包含一个空行（这条规则会使得在利用一些工具，例如Git的时候配合的更好） 声明STRING类型的变量是需要用单引号 源代码文件应该有足够的注释（默认15%） FUNCTIONS不应该有太多行（阈值：300），难以理解以及维护。 函数不应该有太多的参数（临界值为7） 一个表达式不应该有超过三个的操作符，以增加表达式的可读性。 循环不应该包括多余一个的BREAK或者CONTINUE语句，否则重构 结尾的逗号不应该被使用var settings = {&#39;foo&#39;: oof,&#39;bar&#39;: rab}; ARGUMENTS.CALLER和ARGUMENTS.CALLEE在ECMAScript5中，这两个函数在strict模式下都被禁止使用。在最新的Javascript版本中不建议被使用。 不要省略大括号（）if，作为范围控制 SWITCH的每个条件结尾都要有BREAK 发布版本中不要有alert(),console,给攻击者泄露敏感信息 //TODO，// FIXME只在 开发过程中。 开发人员不能注释代码，因为会影响代码可读性。不再使用的代码就删除。 new关键字应该和构造函数一起使用 不要使用ARRAY和OBJECT的构造方法。超过一个参数，会新建多个array. 不要重载内置对象 及时释放无用的储存]]></content>
      <categories>
        <category>rule</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>summary</tag>
        <tag>CSS</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API大全整理/from github]]></title>
    <url>%2F2017-06-13-api.html</url>
    <content type="text"><![CDATA[偶然发现的github上的API，蛮好用的吼、 emoji表情包大全https://api.github.com/emojisGET返回数据格式：1234567&#123; "+1": "https://assets-cdn.github.com/images/icons/emoji/unicode/1f44d.png?v7", "-1": "https://assets-cdn.github.com/images/icons/emoji/unicode/1f44e.png?v7", "100": "https://assets-cdn.github.com/images/icons/emoji/unicode/1f4af.png?v7", "1234": "https://assets-cdn.github.com/images/icons/emoji/unicode/1f522.png?v7", //... &#125; markdown编辑器https://api.github.com/markdownPOST12345data = &#123; "text":"#test", "mode": "gfm", "context": "github/gollum" &#125; 返回数据：html]]></content>
      <categories>
        <category>别人家的好东西</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript要仔细学之一//apply( )和call( )的区别]]></title>
    <url>%2F2017-06-12-js01.html</url>
    <content type="text"><![CDATA[call和apply可以改变this指针,即改变函数的作用域。 说明call和apply方法的作用相同，就是参数不同。call和apply的第一个参数都是一样的，但是后面参数不同，call从第二个参数开始后面有许多参数，apply第二个参数必须是数组。call([thisObj[,arg1[, arg2[, [,.argN]]]]])apply([thisObj[,argArray]]) 相同点两个方法产生的作用是完全一样的，call, apply都属于Function.prototype的一个方法call, apply作用就是借用别人的方法来调用,就像调用自己的一样. 不同点方法传递的参数不同f.call(this, arg1, arg2, arg3) == f.apply(this,arguements) ==this.f(arg1, arg2, arg3) 举个栗子①1234567891011121314151617181920212223242526272829303132333435363738394041function print(a, b, c, d)&#123; alert(a + b + c + d);&#125;function example(a, b , c , d)&#123; //用call方式借用print,参数显式打散传递 print.call(this, a, b, c, d); //用apply方式借用print, 参数作为一个数组传递, //这里直接用JavaScript方法内本身有的arguments数组 print.apply(this, arguments); //或者封装成数组 print.apply(this, [a, b, c, d]);&#125;//下面将显示”动感光波”example("动","感","光","波");②function Animal(name) &#123; this.name = name; this.showName = function() &#123; console.log(this.name); &#125;;&#125;function Cat(name) &#123; Animal.call(this, name);&#125;Cat.prototype = new Animal();function Dog(name) &#123; Animal.apply(this, name);&#125;Dog.prototype = new Animal();var cat = new Cat("Black Cat"); //call必须是objectvar dog = new Dog(["Black Dog"]); //apply必须是arraycat.showName();dog.showName();console.log(cat instanceof Animal);console.log(dog instanceof Animal); 模拟call, apply的this替换12345678910111213141516function Animal(name) &#123; this.name = name; this.showName = function() &#123; alert(this.name); &#125;;&#125;;function Cat(name) &#123; this.superClass = Animal; this.superClass(name); delete superClass;&#125;var cat = new Cat("Black Cat");cat.showName(); 应用场景当参数明确时可用call, 当参数不明确时可用apply给合arguments]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块打包-bundler：browserify、webpack、RequireJS/AMD]]></title>
    <url>%2F2017-05-26-bundler.html</url>
    <content type="text"><![CDATA[目前比较完善的模块打包：browserify和webpack。webpack在browserify之后出现。 browserifywebpackRequireJS/AMD]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>bundler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务流工具-taskrunner：Grunt、Gulp]]></title>
    <url>%2F2017-05-26-task-runner.html</url>
    <content type="text"><![CDATA[目前比较完善的任务流工具：Grunt和Gulp。Gulp在Grunt之后出现，有Grunt的优点，同时增加了新特性。 Grunt安装npm install grunt-cli -g Gulp安装npm install gulp-cli -g]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>taskrunner</tag>
        <tag>Gulp</tag>
        <tag>Grunt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[design patterns - JavaScript设计模式]]></title>
    <url>%2F2017-05-25-design-patterns.html</url>
    <content type="text"><![CDATA[哎，最不想整理的就是这一块了 最初在设计模式 一书中，许多设计模式都鼓励使用松散耦合。在更改一个代码片段时，就会发生问题，系统其他部分 —— 曾认为完全不相关的部分中也有可能出现级联破坏。该问题在于紧密耦合 。系统某个部分中的函数和类严重依赖于系统的其他部分中函数和类的行为和结构。您需要一组模式，使这些类能够相互通信，但不希望将它们紧密绑定在一起，以避免出现联锁。 工厂模式简单工厂模式12345678910111213141516function BuyHero(name,type,price)&#123; var obj = &#123;&#125;; obj.name = name; obj.age = type; obj.price = price; obj.sayName = function()&#123; return this.name; &#125;; return obj;&#125;var h1 = new BuyHero('Teemo','ADC','6300');var h2 = new BuyHero('Amumu','Jungle','3100');//返回都是object 无法识别对象的类型，哪个对象的实列 console.log(typeof h1); // object console.log(typeof h2); // object console.log(h1 instanceof Object); // true 复杂工厂模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 定义英雄池的构造函数var League = function(name)&#123; this.name = name; this.method = function()&#123; return this.name; &#125;&#125;;League.prototype = &#123; constructor: League, /* * 买英雄这个方法 * @param &#123;name&#125; 英雄名字 */ buyHero: function(name)&#123; var hero = this.createHero(name); // 执行Q、W...技能，哦，业务逻辑 hero.Q(); hero.W(); return hero; &#125;, createHero: function(model)&#123; throw new Error("父类是抽象类不能直接调用，需要子类重写该方法"); &#125;&#125;;// 实现原型继承function extend(Sub,Sup) &#123;//Sub表示子类，Sup表示超类 var F = function()&#123;&#125;;// 首先定义一个空函数 F.prototype = Sup.prototype;// 设置空函数的原型为超类的原型 Sub.prototype = new F();// 实例化空函数，并把超类原型引用传递给子类 Sub.prototype.constructor = Sub;// 重置子类原型的构造器为子类自身 Sub.sup = Sup.prototype;// 在子类中保存超类的原型,避免子类与超类耦合 if(Sup.prototype.constructor === Object.prototype.constructor) &#123; Sup.prototype.constructor = Sup;// 检测超类原型的构造器是否为原型自身 &#125;&#125;var HeroChild = function(name)&#123; this.name = name; // 继承构造函数父类中的属性和方法 League.call(this,name);&#125;;// 子类继承父类原型方法extend(HeroChild,League);// BicycleChild 子类重写父类的方法HeroChild.prototype.createHero = function()&#123; var Q = function()&#123; console.log("执行Q业务操作"); &#125;; var W = function()&#123; console.log("执行W业务操作"); &#125;; return &#123; Q: Q, W: W &#125;&#125;;var Teemo = new HeroChild("提莫"); console.log(Teemo); console.log(Teemo.name);//提莫 Teemo.buyHero(); 理解 父类是一个抽象类，不能被实列化,将其成员对象的实列化推迟到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。子类之间是相互独立的。 优点解决多个类似对象声明的问题;解决实列化对象产生重复的问题。在父类中编写一些相同的方法代码,在子类中重写该父类的方法，去实现具体的业务逻辑。 1/弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。 2/重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。 缺点无法获取对象类型 单体模式封装单体模式123456789101112131415161718192021222324252627282930313233343536// 写法一var Singleton = function(name)&#123; this.name = name; this.instance = null;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;;// 获取实例对象function getInstance(name) &#123; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;// 写法二var Singleton = function(name)&#123; this.name = name; &#125;; Singleton.prototype.getName = function()&#123; return this.name; &#125; // 获取实例对象 var getInstance = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125; &#125;)();// 测试单体模式的实例var a = getInstance("aa");var b = getInstance("bb");console.log(a===b);// true,b的实例就是a的实例 使用代理实现单体模式具体的单体模式中的实例化类的事情交给代理函数去处理，这样做的好处是具体的业务逻辑分开了，代理只管代理的业务逻辑，在这里代理的作用是实例化对象，并且只实例化一次; 创建div代码只管创建div，其他的不管；12345678910111213141516171819202122232425262728293031323334353637//创建一个div//第一种var CreateDiv = function(html) &#123; this.html = html; this.init();&#125;;CreateDiv.prototype.init = function()&#123; var div = document.createElement("div"); div.innerHTML = this.html; document.body.appendChild(div);&#125;;// 代理实现单体模式var ProxyMode = (function()&#123; var instance; return function(html) &#123; if(!instance) &#123; instance = new CreateDiv("rawraw hello"); &#125; return instance; &#125;&#125;)();//第二种 // 代理实现单体模式 var ProxyMode = (function()&#123; var instance; return function(html) &#123; if(!instance) &#123; instance = document.createElement("div"); instance.innerHTML = "rawraw hello"; document.body.appendChild(instance); &#125; return instance; &#125; &#125;)();var a = new ProxyMode("aaa");var b = new ProxyMode("bbb");console.log(a===b);// true 综合123456789101112131415161718192021222324252627282930313233// 创建divvar createWindow = function()&#123; var div = document.createElement("div"); div.innerHTML = "我是弹窗内容"; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;// 创建iframevar createIframe = function()&#123; var iframe = document.createElement("iframe"); document.body.appendChild(iframe); return iframe;&#125;;// 获取实例的封装代码var getInstance = function(fn) &#123; var result; return function()&#123; return result || (result = fn.call(this,arguments)); &#125;&#125;;// 测试创建divvar createSingleDiv = getInstance(createWindow);document.getElementById("test").onclick = function()&#123; var win = createSingleDiv(); win.style.display = "block";&#125;;// 测试创建iframevar createSingleIframe = getInstance(createIframe);document.getElementById("test").onclick = function()&#123; var win = createSingleIframe(); win.innerHTML = "rawraw hello";&#125;; 理解 单体模式是以对象字面量的方式来创建单体模式一个用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。以对象字面量的方式来创建单体模式。 适用场景：弹窗 优点缺点模块模式123456789101112var singleMode = (function()&#123; var privateNum = 112;// 创建私有变量 // 创建私有函数 function privateFunc()&#123; // 实现自己的业务逻辑代码 &#125; // 返回一个对象包含公有方法和属性 return &#123; publicMethod1: publicMethod1, publicMethod2: publicMethod1 &#125;;&#125;)(); 模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，先定义了私有变量和函数，供内部函数使用，然后将一个对象字面量作为函数的值返回，返回的对象字面量中只包含可以公开的属性和方法。这样的话，可以提供外部使用该方法；由于该返回对象中的公有方法是在匿名函数内部定义的，因此它可以访问内部的私有变量和函数。 增强的模块模式适合那些单列必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况。12345678910111213141516171819202122function CustomType() &#123; this.name = "rawraw";&#125;CustomType.prototype.getName = function()&#123; return this.name;&#125;;var application = (function()&#123; var privateA = "aa";// 定义私有 function A()&#123;&#125;// 定义私有函数 var object = new CustomType();// 实例化一个对象后，返回该实例，然后为该实例增加一些公有属性和方法 object.A = "cc";// 添加公有属性 // 添加公有方法 object.B = function()&#123; return privateA; &#125;; return object;// 返回该对象&#125;)();console.log(application);console.log(application.A);// ccconsole.log(application.B()); // aaconsole.log(application.name); // rawrawconsole.log(application.getName());// rawraw 理解 模块模式的思路是为单体模式添加私有变量和私有方法能够减少全局变量的使用； 适用场景：必须创建一个对象并以某些数据进行初始化，同时还要公开一些能够访问这些私有数据的方法 优点缺点代理模式理解 适用场景：图片预加载 案例1234567891011121314151617181920212223242526272829303132333435363738394041// 不使用代理的预加载图片函数如下var myImage = (function()&#123; var imgNode = document.createElement("img"); document.body.appendChild(imgNode); var img = new Image(); img.onload = function()&#123; imgNode.src = this.src; &#125;; return &#123; setSrc: function(src) &#123; imgNode.src = "http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif"; img.src = src; &#125; &#125;&#125;)();// 调用方式myImage.setSrc("https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png");var myImage = (function()&#123; var imgNode = document.createElement("img"); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();// 代理模式var ProxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src) &#123; myImage.setSrc("http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif"); img.src = src; &#125; &#125;&#125;)();// 调用方式ProxyImage.setSrc("https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png"); 优点1.代理对象可以代替本体被实例化，并使其可以被远程访问；2.它还可以把本体实例化推迟到真正需要的时候；对于实例化比较费时的本体对象，或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象； 缺点职责链模式12345```## 理解## 优点## 缺点# 命令模式 1234## 理解## 优点## 缺点# 模板方法模式 1234## 理解## 优点## 缺点# 策略模式 1234## 理解## 优点## 缺点# 发布-订阅模式(观察者模式) 1234## 理解## 优点## 缺点# 中介者模式 ` 理解优点缺点http://www.cnblogs.com/tugenhua0707/p/5198407.html]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Front-end总结]]></title>
    <url>%2F2017-05-25-front-end.html</url>
    <content type="text"><![CDATA[前端学习的框架。只列点，不展开。类库能够使将开发时间缩短20％，开发者不必担心细节实现。框架通常提供了比类库更高层次的抽象，帮助快速构建项目的前80％。 一、基础HTML（Hyper Text Markup Language）对Web标准的理解、浏览器内核差异、兼容性、hackHTML5 CSS（Cascading Style Sheet）布局、盒子模型、选择器优先级、CSS3、Flexbox JavaScript数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 二、运行环境1.Node.Js主页去我整理的地方看看不结合npm包管理器 三、工具（一）构建工具（任务流工具task runner）1.gulp主页通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 2.grunt（二）模块打包工具（bundler）1.browserify2.webpack3.requirejs主页模块化动态加载。加速、优化代码。 （三）代码分析工具ESLint/JSHint/JSLint（四）单元测试工具Mocha/Jasmine/QUnit/Jest/Ava（五）预编译工具1.LESS2.SASS3.Post CSS4.TypeScript5.Babel四、库（Javascript库和UI库）1.jQuery2.Zepto.js主页 3.SUI Mobile主页基于 Framework7 开发的UI库,兼容到 iOS 6.0+ 和 Android 4.0+。 4.JQuery Mobile主页 五、框架1.Ionic主页Ionic既是一个CSS框架也是一个Javascript UI库。通过 SASS 构建应用程序，它 提供了很多 UI 组件来帮助开发者开发强大的应用。 它使用 JavaScript MVVM 框架和 AngularJS 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。 2.angular.Js主页MVVM，模块化，自动化双向数据绑定 3.Vue.js主页MVVM 数据绑定、可组合的组件系统。从技术上讲， Vue.js 集中在 MVVM 模式上的视图模型层，并通过双向数据绑定连接视图和模型。实际的 DOM 操作和输出格式被抽象出来成指令和过滤器。 4.React主页构建随着时间数据不断变化的大规模应用程序。 5.backbone.js主页 Backbone 为复杂Javascript应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESTful JSON接口连接到应用程序。 6.bootstrap主页 7.EasyUI主页基于jQuery的用户界面插件集合。 8.Pure主页 9.Ant Design主页 六、可视化组件1.Echarts主页 七、插件八、扩展版本管理code review杂七杂八移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构团队协作、可维护、易用性、SEO、UED、架构职业生涯、快速学习能力]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[navicat for mysql安装问题]]></title>
    <url>%2F2017-05-16-navicat.html</url>
    <content type="text"><![CDATA[navicat for mysql安装问题小集合 10451234C:\xampp\MySQL\bin mysql -u root mysql mysql&gt; UPDATE user SET Password=PASSWORD(&apos;newpassword&apos;) where USER=&apos;root&apos;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xampp配置虚拟主机]]></title>
    <url>%2F2017-05-16-xampp.html</url>
    <content type="text"><![CDATA[xampp配置虚拟主机 首先，xampp要可以基本运行起来 域名配置以管理员身份运行hosts,新增127.0.0.1 test.com xampp配置1234567891011&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;E:/test&quot; ## 文件根目录 ServerName test.com ## 虚拟域名 &lt;Directory E:/test&gt; ## 文件根目录 Options -Indexes AllowOverride ALL DirectoryIndex index.php index.html Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>xampp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http协议]]></title>
    <url>%2F2017-05-10-http.html</url>
    <content type="text"><![CDATA[浏览器的渲染过程。一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 浏览器的渲染过程 浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 CSS文件下载完成，开始构建CSSOM 所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。 最后一步，按照算出来的规则，把内容渲染到屏幕上。以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。 display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求（TCP三次握手）； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成 一个完整的URL包括以下几部分http://www.baidu.net:8080/news/index.php?boardID=5&amp;ID=24618&amp;page=1#name1、协议部分2、域名部分3、端口部分4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止5、文件名部分：从域名后的最后一个“/”开始到“？”为止6、参数部分：从“？”开始到“#”为止之间的部分7、锚部分：从“#”开始到最后 一次完整的http请求： 建立TCP连接 Web浏览器向Web服务器发送请求命令 Web浏览器发送请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 HTTP请求四部分1、HTTP请求的方法或动作，比如是get还是post请求；2、正在请求的URL（请求的地址）；3、请求头，包含一些客户端环境信息、身份验证信息等；4、请求体（请求正文），可以包含客户提交的查询字符串信息、表单信息等。 请求头字段：Accept:text/html,image/*(告诉服务器，浏览器可以接受文本，网页图片)Accept-Charaset:ISO-8859-1 [接受字符编码：iso-8859-1]Accept-Encoding:gzip,compress[可以接受 gzip,compress压缩后数据]Accept-Language:zh-cn[浏览器支持的语言]Host:localhost:8080[浏览器要找的主机]If-Modified-Since:Tue, 09 May 2017 01:34:02 GMT[告诉服务器我这缓存中有这个文件,该文件的时间是…]User-Agent:Nozilla/4.0(Com…)[告诉服务器我的浏览器内核，客户端环境信]Cookie：[身份验证信息]Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接] HTTP响应三部分1、一个数字和文字组成的状态码，用来显示请求是成功还是失败；2、响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等；3、响应体（响应正文）。 响应头字段：CacheControl:[告诉浏览器如何缓存页面(因为浏览器的兼容性最好设置两个)]Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接]Content-Type:text/html;charset=gb2312[内容格式和编码]Last-Modified:Tue,11 Juj,2017 18 18:29:20[告诉浏览器该资源上次更新时间是多少]ETag:”540-54f0d59b8b680”Expires:Fri, 26 May 2017 13:28:33 GMT [失效日期]server:apache tomcat nginx [哪种服务器] 说说TCP传输的三次握手第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。 为什么要三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！ 四次挥手1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段；2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段；3、服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接；4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接； 常见HTTP状态码1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。2xx（成功）表示成功处理了请求的状态码。200（成功）：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。3xx（重定向）要完成请求，需要进一步操作。301（永久移动）：请求的网页已永久移动到新位置。302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。304（未修改）：自从上次请求后，请求的网页未修改过。4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。400（错误请求）：服务器不理解请求的语法。404（未找到）：服务器找不到请求的网页。5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。500（服务器内部错误）：服务器遇到错误，无法完成请求。503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 讲讲304缓存的原理服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式整理]]></title>
    <url>%2F2017-05-09-regexp.html</url>
    <content type="text"><![CDATA[特别简单的就不记下来了，这么简单都还要来翻，还撸什么码/ 汉字: ^[\u4e00-\u9fa5]{0,}$email: ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化总结]]></title>
    <url>%2F2017-05-04-optimize.html</url>
    <content type="text"><![CDATA[better better ~~ 强迫症的宝宝-_— 图片清晰度动画3D启用硬件加速1234#test &#123; -webkit-transform:translate3d(0, 0, 0) transform: translate3d(0, 0, 0);&#125;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种爹一样的兼容处理]]></title>
    <url>%2F2017-05-03-compatible.html</url>
    <content type="text"><![CDATA[好奇怪的ie678,好奇怪的安卓机，好奇怪的ios爸爸。。。 web端杂在ie6-7中，用margin-bottom代替padding 移动端]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用的小东西整理]]></title>
    <url>%2F2017-05-03-css3.html</url>
    <content type="text"><![CDATA[常用的css3巴拉巴拉的，js小技巧-_- CSS部分 移动端将文本分成多列12345#test&#123; -moz-column-count:3; -webkit-column-count:3; column-count:3;&#125; 创建模糊文本123456#test &#123; color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125; ``` ### pre标签内文本自动换行 pre{ overflow: auto; background-color: #f1f1f1; overflow-x: auto; /* Use horizontal scroller if needed; for Firefox 2, not white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */ word-wrap: break-word; /* Internet Explorer 5.5+ */ margin: 0; padding:5px 5px 3px 5px; white-space : normal; /* crucial for IE 6, maybe 7? */ } 1### 表格自动宽度 td { white-space: nowrap;}12### 让滚动条顺溜地滑定位后的滑动会出现卡顿 body { -webkit-overflow-scrolling: touch; overflow-scrolling: touch;}1### 长按闪退 #test{ -webkit-touch-callout: none;}1### select 设置右对齐 select option { direction: rtl;}1### touch时有半透明灰色遮罩（ios和android） #test{ -webkit-tap-highlight-color:rgba(255,255,255,0)}1### 输入框默认内阴影、以及默认样式(ios) #test{ -webkit-appearance: none;}123456789### 部分机型存在type为search的input，自带close按钮样式&gt;`#Search::-webkit-search-cancel-button&#123; display: none; &#125;`### 默认首字母会大写(ios)&gt;`&lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt;`### 圆角失效(某些Android) #test{ background-clip: padding-box;}1234567### 移动端伪类 `:active` 失效移动端应该是touch&gt;`&lt;body ontouchstart=&quot;&quot;&gt;` &gt;或者`document.addEventListener(&apos;touchstart&apos;,function()&#123;&#125;,false);`## 浏览器### 禁止复制、选中文本 #test{ -webkit-user-select: none; -moz-user-select: none; -khtml-user-select: none; user-select: none;}123456789101112131415161718192021### 消除 IE10 的叉号&gt;`input:-ms-clear&#123;display:none;&#125;`### css垂直居中 ![去这里看](center) ## CSS3### 伪类#### 修改选中文本的颜色：```css [ 举一个栗子 ]user-select:none::selection&#123;color: white;background-color: red;&#125; ::-moz-selection &#123;color: white;background-color: red;&#125; 首字母设置12345678910111213#test:first-child::first-letter&#123; font-size: 28px; font-weight: bold;&#125;/*首字下沉*/p:first-letter&#123; display:block; margin:5px 0 0 5px; float:left; color:#FF3366; font-size:60px; font-family:Georgia; &#125; 透明度的兼容123456#test &#123; filter: alpha(opacity=50); /* internet explorer */ -khtml-opacity: 0.5; /* khtml, old safari */ -moz-opacity: 0.5; /* mozilla, netscape */ opacity: 0.5; /* fx, safari, opera */&#125; webkit mask遮罩要记得来写http://www.cnblogs.com/cosiray/archive/2012/12/06/2804770.html transform出现锯齿123-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0); transform: rotate(-4deg) skew(10deg) translateZ(0); outline: 1px solid rgba(255,255,255,0) 渐变[ 举一个栗子 ]12345678910111213141516171819202122232425262728/*上至下，默认方向*/#test&#123; background: -webkit-linear-gradient(#000, #fff); background: -o-linear-gradient(#000, #fff); background: -moz-linear-gradient(#000, #fff); background: linear-gradient(#000, #fff); &#125;/*左至右*/#test2 &#123; background: -webkit-linear-gradient(left, #000 , #fff); background: -o-linear-gradient(right, #000, #fff); background: -moz-linear-gradient(right, #000, #fff); background: linear-gradient(to right, #000 , #fff); &#125;/*角度。12点方向为0deg,顺时针增加deg*/#test3 &#123; background: -webkit-linear-gradient(180deg, #000, #fff); background: -o-linear-gradient(180deg, #000, #fff); background: -moz-linear-gradient(180deg, #000, #fff); background: linear-gradient(180deg, #000, #fff);&#125;/*也可以径向渐变，多种颜色，透明度*/#test4&#123; background: -webkit-radial-gradient(#000 , #fff 10%, #000 20%); background: -o-radial-gradient(#000, #fff 10%, #000 20%); background: -moz-radial-gradient(#000, #fff 10%, #000 20%); background: radial-gradient(#000, #fff 10%, #000 20%); &#125; JS部分 中文输入法输入英文时，有六分之一空格（ios） this.value = this.value.replace(/\u2006/g, &#39;&#39;); 移动端autoplay 失效问题必须由用户来触发才可以播放。touchstart 触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。 document.addEventListener(&#39;touchstart&#39;, function () { document.getElementsByTagName(&#39;audio&#39;)[0].play(); document.getElementsByTagName(&#39;audio&#39;)[0].pause(); }); 批量修改样式[ 举一个栗子 ]1div.style.cssText = 'width:100px;height:100px;' 展开select的option123456function showDropdown(sltElement) &#123; var event; event = document.createEvent(&apos;MouseEvents&apos;); event.initMouseEvent(&apos;mousedown&apos;, true, true, window); sltElement.dispatchEvent(event);&#125;; HTML部分 meta标签apple-mobile-web-app-capableapple-mobile-web-app-capable是设置Web应用是否以全屏模式运行。 &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; 缓存有时候改了bug刷新并没有卵用，然后就好气啊。手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。 &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt;format-detection 启动或禁用自动识别页面中的电话号码。&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; 奇怪的浏览器强制屏幕12345678910111213141516171819&lt;!-- QQ浏览器私有 --&gt;&lt;!-- 全屏模式 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- 强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- 强制横屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;landscape&quot;&gt;&lt;!-- 应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- UC浏览器私有 --&gt;&lt;!-- 全屏模式 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- 强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- 强制横屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;landscape&quot;&gt;&lt;!-- 应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; 移动端拨打电话功能（安卓、ios都可以） &lt;a href=&quot;tel:10086&quot;&gt;10086&lt;/a&gt; app横屏字体text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-size-adjust: 100%; 顶部状态栏背景色先指定全屏模式 apple-mobile-web-app-capable &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;blank&quot; /&gt; content:default 正常显示 blank 黑色背景 lank-translucent 黑色半透明，页面主体会向上占据位置 桌面图标图片尺寸可以设定为5757（px）或者Retina可以定为114114（px），ipad尺寸为72*72（px) 去光泽 &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;touch-icon-iphone.png&quot; /&gt; 启动画面 &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;start.png&quot;/&gt;iOS下页面启动加载时显示的画面图片，避免加载时的白屏。可以通过madia来指定不同的大小：1234567891011121314151617181920&lt;!--iPhone--&gt; &lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone Retina --&gt; &lt;link href=&quot;apple-touch-startup-image-640x920.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone 5 --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; media=&quot;(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)&quot; href=&quot;apple-touch-startup-image-640x1096.png&quot;&gt; &lt;!-- iPad portrait --&gt; &lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad landscape --&gt; &lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina portrait --&gt; &lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina landscape --&gt; &lt;link href=&quot;apple-touch-startup-image-1496x2048.png&quot;media=&quot;(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot;rel=&quot;apple-touch-startup-image&quot; /&gt;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[\\这个插件还可以//之select2]]></title>
    <url>%2F2017-04-19-plu-select2.html</url>
    <content type="text"><![CDATA[placeholder: 一定要加空的 [ 举一个栗子 ]1234567$('#test').select2(&#123; data:[ &#123;id:1,text:"teemo"&#125;, &#123;id:2,text:"anni"&#125;, //... ]&#125;)]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>plugin</tag>
        <tag>select2</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试大宝典]]></title>
    <url>%2F2017-04-12-interview.html</url>
    <content type="text"><![CDATA[为什么要学习前端对前端的认识基础知识HTML部分1、重绘和回流 会引起重绘和回流的操作: 添加、删除元素(回流+重绘) 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流) 移动元素，比如改变top,left,transform的值，或者移动元素到另外一个父元素中。(重绘+回流) 对style的操作(对不同的属性操作，影响不一样) 还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等(回流+重绘) 2、浏览器缓存机制浏览器缓存机制是指通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。Cache-Control 用于控制文件在本地缓存有效时长。Last-Modified 是标识文件在服务器上的最新更新时间。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。 特殊情况： 手动刷新页面（F5)，浏览器会直接认为缓存已经过期（可能缓存还没有过期），在请求中加上字段：Cache-Control:max-age=0，发包向服务器查询是否有文件是否有更新。 强制刷新页面（Ctrl+F5)，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。 3、History路由机制用户访问网页的历史记录通常会被保存在一个类似于栈对象中，即history对象，点击返回就出栈，跳下一页就入栈。 window.history.back() 返回到上一个页面 window.history.forward() 进入到下一个页面 window.history.go([delta]) 跳转到指定页面 HTML5增强的History Api和时间： pushState是往history对象里添加一个新的历史记录，即压栈。 replaceState 是替换history对象中的当前历史。 当点击浏览器后退按钮或js调用history.back都会触发onpopstate事件（类似的事件: onhashchange）。onpopstate是专门用来监听浏览器前进后退。onhashchange监听浏览器、客户端前进和后退事件 4、Canvas和SVGCanvas 通过Javascript 来绘制 2D 图形。 SVG 是一种使用 XML 描述 2D 图形的语言。 Canvas和SVG相比，canvas更依赖于分辨率，不支持事件处理器，文本渲染能力弱，比较适合密集型游戏，其中的许多对象会被频繁绘制，而svg则比较适用于类似谷歌地图带有大型渲染区域的应用程序。 CSS部分0、盒子模型window.top.document.compatMode ？ 1、选择器常用选择器：类选择器、标签选择器、ID选择器、后代选择器、群组选择器、伪类选择器(before/after)、兄弟选择器(+~)、属性选择器。 2、定位 relative、absolute、fixed fixed 在移动端的兼容性问题。解决方案： absolute+内部滚动 浮动清浮动方案 3、自适应calc/box 4、Flex布局注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 5、CSS3 transition、transform、Animation 6、Sprite7、iconfontJS部分0、基础语法基础数据类型 原始类型:Number（数值） String（字符串） Boolean（布尔） Null（空） Undefined（未定义） 引用类型:Object（对象） tips:typeof运算符对于null类型返回的是object。 1、作用域每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。作用域链的作用是用于解析标识符，当函数被创建时（不是执行），会将this、arguments、命名参数和该函数中的所有局部变量添加到该当前作用域中，当JavaScript需要查找变量X的时候（这个过程称为变量解析），它首先会从作用域链中的链尾也就是当前作用域进行查找是否有X属性，如果没有找到就顺着作用域链继续查找，直到查找到链头，也就是全局作用域链，仍未找到该变量的话，就认为这段代码的作用域链上不存在x变量，并抛出一个引用错误（ReferenceError）的异常。 作用域链:作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 在JS中没有块级作用域，只有函数作用域。怪异现象：变量提升。 js变量提升(es6)JavaScript函数中声明的所有变量（但不涉及赋值）都被“提前”至函数的顶部。 举个栗子123456var scope = "global";function myFunc()&#123; console.log(scope); //undefined var scope = "local";&#125;`````````````````````````````````````````` var scope = “global”;function myFunc(){ var scope; console.log(scope); scope = “local”;}12345678910111213141516### 2、原型链prototype，建立了变量查找机制。原型链的链头是object,它的prototype比较特殊，值为null。原型链的作用是用于对象继承。当访问对象的一个属性时, 首先查找对象本身, 找到则返回; 若未找到, 则继续查找其原型对象的属性(如果还找不到实际上还会沿着原型链向上查找, 直至到根). 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined；### 3、函数普通函数的创建有：显式声明、匿名定义、new Function() 等三种方式。#### 函数声明和函数表达式的区别函数声明会提前ECMAScript规范中表示，函数声明语句可以出现在全局代码中，或者内嵌在其他函数中，但是不能出现在循环、条件判、或者try/finally以及with语句中。##### que0.1 : `spacify(&apos;rawraw&apos;)` =&gt; `&apos;r a w r a w&apos;` answer : ```jsfunction spacify(str) &#123; return str.split(&apos;&apos;).join(&apos; &apos;);&#125; que0.2 : spacify(&#39;rawraw&#39;) =&gt; &#39;r a w r a w&#39;answer :123String.prototype.spacify = function()&#123; return this.split('').join(' ');&#125;; apply和call的区别详情见这里 que0.1 : log(&#39;hello world&#39;);answer :1234function log(msg)&#123; console.log(msg);&#125;//apply que0.2 : log(&#39;hello&#39;, &#39;world&#39;);answer :1log('hello', 'world'); que0.3 : ‘(app) hello world’arguments是一个伪数组，我们需要先将它转换成正常的数组，我们可以使用Array.prototype.slice,answer :12345function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift('(app)'); console.log.apply(console, args);&#125;; Context的理解que0.1 : 运行结果1234567var User = &#123; count: 1, getCount: function() &#123; return this.count; &#125;&#125;; que0.2 : 运行结果1234console.log(User.getCount());var func = User.getCount; console.log(func()); //undefined,unc的上下文是 window，因此已经失去了count属性 que0.3 : 如何确保func的上下文始终都和User关联，这样可以使输出的答案是1answer : 12var func = User.getCount.bind(User); console.log(func()); que0.4 : 老浏览器兼容answer :123456Function.prototype.bind = Function.prototype.bind || function(context) &#123; var self = this; return function()&#123; return self.apply(context, arguments); &#125;;&#125; 4、函数指针this的指向： 作为普通函数调用（this指向全局对象window对象） 作为对象的方法调用（this指向该对象） 构造器调用（this指向用new返回的这个对象） call、apply、bind的调用（this指向第一个参数对象） 5、闭包去看闭包吧 什么情况下会发生闭包，为什么需要闭包，什么场景下需要，闭包闭了谁，怎么释放被闭包的变量内存，闭包的优点是什么，缺点是什么等等。《红宝书》：是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。《你不知道的javascript》：当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函数持有对该词法作用域的引用，这个引用就叫做闭包。 闭包其实是一个主动执行的代码块，这个代码块的特殊之处是可以永久保存局部变量，但又不污染全局变量，可以形成一个独立的执行过程，因此我们经常用闭包来定义组件。闭包本质还是函数，只不过这个函数绑定了上下文环境（函数内部引用的所有变量）。 特性 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 缺点常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 使用场景可以用来管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。 6、事件系统 Event(事件模型及事件代理/委托)(事件是用户与页面交互的基础，到目前为止，DOM事件从PC端的 鼠标事件(mouse) 发展到移动端的 触摸事件(touch) 和 手势事件(guesture) 由于DOM结构可能会多层嵌套，因此也衍生出了两种事件流：事件捕获和事件冒泡，后者最常用。利用事件冒泡机制可以实现很多功能，比如页面点击统计。 除此之外，在页面初始化、滚动、隐藏、返回等操作时分别内置了onload/onDOMContentLoaded、onscroll、onvisibility和onhashchange等事件，如果想要捕获这些事件，需要通过addEventLisener/attachEvent来进行绑定。) 事件的三个阶段捕获，目标，冒泡阶段(低版本IE不支持捕获阶段) {事件的代理/委托}的原理以及优缺点优点 大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适事件代理的应用常用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不应用触发事件的被绑上了事件 IE和W3C不同绑定事件解绑事件的方法有什么区别，参数分别是什么，以及事件对象e有什么区别target，currentTarget，以及IE下的srcElement和this 实现事件模型即写一个类或是一个模块，有两个函数，一个bind一个trigger，分别实现绑定事件和触发事件，核心需求就是可以对某一个事件名称绑定多个事件响应函数，然后触发这个事件名称时，依次按绑定顺序触发相应的响应函数。 大致实现思路就是创建一个类或是匿名函数，在bind和trigger函数外层作用域创建一个字典对象，用于存储注册的事件及响应函数列表，bind时，如果字典没有则创建一个，key是事件名称，value是数组，里面放着当前注册的响应函数，如果字段中有，那么就直接push到数组即可。trigger时调出来依次触发事件响应函数即可。 不过还有很多细节，比如触发响应函数时的上下文应该是什么，触发响应函数的参数列表应该是什么，如果要求把调用trigger的参数列表都传到响应函数中还要考虑到吧arguments对象转化为纯数组才行等等。 还有一些面试官会问到事件如何派发也就是事件广播（dispatchEvent）等等，这里不再展开。 代理 当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。1234567891011121314151617181920212223242526272829&lt;ul id='list'&gt;&lt;/ul&gt;var count = 100;var ulList = document.getElementById("list");//动态构建节点for(var i = count;i--;)&#123; var liDom = document.createElement('li'); ulList.appendChild(liDom);&#125;//绑定点击事件var liNode = ulList.getElementByTagName("li");for(var i=0, l = liNodes.length; i &lt; l; i++)&#123; liNode[i].onClick = function()&#123; //li点击事件 &#125;&#125;var count = 100;var ulList = document.getElementById("list");//动态构建节点for(var i = count;i--;)&#123; var liDom = document.createElement('li'); ulList.appendChild(liDom);&#125;//绑定点击事件var liNode = ulList.getElementByTagName("li");liNode.onClick = function(e)&#123; if(e.target &amp;&amp; e.target.nodeName.toUpperCase == "LI") &#123; // li点击事件 &#125;&#125; 7、单线程和异步队列 setTimeout和setInterval JS是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，主线程会形成一个全局执行环境，执行环境采用栈的方式将待执行任务按顺序依次来执行。但在浏览器中有一些任务是非常耗时的，比如http请求、定时器、事件回调等，为了保证其他任务的执行效率不被影响，JS在执行环境中维护了一个异步队列(也叫工作线程)，并将这些任务放入队列中进行等待，这些任务的执行时机并不确定，只有当主线程的任务执行完成以后，才会去检查异步队列中的任务是否需要开始执行。这就是为什么setTimeout(fn,0) 始终要等到最后执行的原因。 Ajax8、DOM对象:document/全局对象:window(document对象里保存着整个web页面dom结构，在页面上所有的元素最终都会映射为一个dom对象。 document也提供了很多api来查找特定的dom对象，比如getElementById,querySelector等等。) Function.bind函数作用，应用场景，举个栗子1、Function.bind返回的也是一个函数，所以注定发生了闭包；2、在返回的这个函数中去调用一个其他的函数，这其实本质上就是函数钩子(HOOK)；1、保持函数的this指向；2、保持函数的所有参数都传递到目标函数；3、保持函数的返回值； 123456789101112131415161718192021222324if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== "function") &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 9、继承算法去重[基本数组去重]123456789Array.prototype.unique = function()&#123; var result = []; this.forEach(function(v)&#123; if(result.indexOf(v) &lt; 0)&#123; result.push(v); &#125; &#125;); return result;&#125; [利用hash表去重]12345678910Array.prototype.unique = function()&#123; var result = [],hash = &#123;&#125;; this.forEach(function(v)&#123; if(!hash[v])&#123; hash[v] = true; result.push(v); &#125; &#125;); return result;&#125; 上面的方法存在一个bug，对于数组[1,2,’1’,’2’,3]，去重结果为[1,2,3]，原因在于对象对属性索引时会进行强制类型转换，arr[‘1’]和arr[1]得到的都是arr[1]的值，因此需做一些改变：123456789101112Array.prototype.unique = function()&#123; var result = [],hash = &#123;&#125;; this.forEach(function(v)&#123; var type = typeof(v); //获取元素类型 hash[v] || (hash[v] = new Array()); if(hash[v].indexOf(type) &lt; 0)&#123; hash[v].push(type); //存储类型 result.push(v); &#125; &#125;); return result;&#125; 先排序后去重1234567Array.prototype.unique = function()&#123; var result = [this[0]]; this.sort(); this.forEach(function(v)&#123; v != result[result.length - 1] &amp;&amp; result.push(v); //仅与result最后一个元素比较 &#125;);&#125; 排序方法一(尽可能不用js数组方法）：1234567891011121314151617181920212223function quickSort(arr)&#123; qSort(arr,0,arr.length - 1);&#125;function qSort(arr,low,high)&#123; if(low &lt; high)&#123; var partKey = partition(arr,low,high); qSort(arr,low, partKey - 1); qSort(arr,partKey + 1,high); &#125;&#125;function partition(arr,low,high)&#123; var key = arr[low]; //使用第一个元素作为分类依据 while(low &lt; high)&#123; while(low &lt; high &amp;&amp; arr[high] &gt;= arr[key]) high--; arr[low] = arr[high]; while(low &lt; high &amp;&amp; arr[low] &lt;= arr[key]) low++; arr[high] = arr[low]; &#125; arr[low] = key; return low;&#125; 方法二（使用js数组方法）：12345678910function quickSort(arr)&#123; if(arr.length &lt;= 1) return arr; var index = Math.floor(arr.length/2); var key = arr.splice(index,1)[0]; var left = [],right = []; arr.forEach(function(v)&#123; v &lt;= key ? left.push(v) : right.push(v); &#125;); return quickSort(left).concat([key],quickSort(right));&#125; 跨域问题http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.htmlhttp://www.cnblogs.com/scottckt/archive/2011/11/12/2246531.htmlhttp://www.cnblogs.com/cat3/archive/2011/06/15/2081559.htmlJSONP原理。这里简单讲就是HTML里面所有带src属性的标签都可以跨域，如iframe，img，script等。 正则尽量不要拆字符，不可预知性1234567891011121314function getQueryObject(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf("?") + 1); var obj = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (rs, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); val = String(val); obj[name] = val; return rs; &#125;); return obj;&#125; 性能优化网络性能优化，加快访问速度，浏览器并行加载数量，怎样实现原生JS异步载入，CDN加速的原理，如何将不同静态资源发布到多个域名服务器上，发布后这些静态字段的url路径改怎么批量改写，用什么工具进行项目打包，css打包后的相对路径怎么转换为绝对路径，用什么工具进行项目模块依赖管理，怎么进行cookie优化文件合并文件最小化/文件压缩使用CDN托管缓存的使用 函数节流http://www.alloyteam.com/2012/11/javascript-throttle/ 前端设计模式比较多的有观察者模式，职责链模式，工厂模式。比如如何去设计一个前端UI组件，应该公开出哪些方法，应该提供哪些接口，应该提供哪些事件。哪部分逻辑流程应该开放出去让用户自行编写，如何实现组件与组件之间的通信，如何实现高内聚低耦合，如何实现组件的高复用等等 前端面试问题合集 了解这家公司版本管理流程管理每天怎么知道要做什么事情？]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown常用语法]]></title>
    <url>%2F2017-04-11-markdown.html</url>
    <content type="text"><![CDATA[markdown：语法比较少也简单，用来写作排版很棒哦、markdownpad：编译+预览的功能。纯编译的话，一般编辑器都可以。markdownpad2破解绿色中文版下载&emsp;提取密码：2ne1 一、标题1.第一种方法的标题code： 123456# 一级标题## 二级标题### 三级标题 #### 四级标题##### 五级标题###### 六级标题 结果：最小到6个###### 一级标题二级标题三级标题四级标题五级标题六级标题2. 第二种方法的标题code： 12345一级标题=============二级标题---- 结果： 一级标题二级标题3. 第三种方法的标题code： 12345678&lt;font size=1&gt;rawraw&lt;/font&gt;&lt;font size=2&gt;rawraw&lt;/font&gt;&lt;font size=3&gt;rawraw&lt;/font&gt;&lt;font size=4&gt;rawraw&lt;/font&gt;&lt;font size=5&gt;rawraw&lt;/font&gt;&lt;font size=6&gt;rawraw&lt;/font&gt;&lt;font size=7&gt;rawraw&lt;/font&gt;&lt;font size=8&gt;rawraw&lt;/font&gt; 结果：最大到7rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw 二、排序code： 1234567891011121314//无序 * == + == -* raw* rawraw* raw+ raw+ rawraw+ rawrawraw- raw- rawraw- rawrawraw//有序，相当于自己写吧1. 提莫2. 娑娜3. 莫甘娜 结果： raw rawraw raw raw rawraw rawrawraw raw rawraw rawrawraw 提莫 娑娜 莫甘娜 三、引用code： 12&gt; 这是一段引用&gt;&gt; 这是一段引用的嵌套 结果： 这是一段引用 这是一段引用的嵌套 四、图片code： 1![“好看死了的图片”](/images/bg/0004.jpg) 结果： 五、链接code： 123456[去吧，皮卡丘](nothing)[回到主页](http://rawraw.info)飞去百度吧[Baidu] [1] ,或者[Rawraw] [2] 或者 [nothing] [3]. [1]: http://www.baidu.com/ "Baidu" [2]: http://rawraw.info "Rawrawh" [3]: nothing "nothing" 结果： 去吧，皮卡丘回到主页飞去百度吧[Baidu] [1] ,或者[Rawraw] [2] 或者 [nothing] [3]. [1]: http://www.baidu.com/ “Baidu” [2]: http://rawraw.info “Rawraw” [3]: nothing “nothing” 文章内部链接的话，可以利用a的锚点 六、代码code： 123456//行内代码`body &#123; margin: 0; padding: 0; &#125;`//行内代码代码块```CSS [reset.css]body &#123; margin: 0; padding: 0; &#125;\`\`\` 结果： body { margin: 0; padding: 0; } [reset.css]1body &#123; margin: 0; padding: 0; &#125; 七、分割线code： 123***//或者--- 结果： 八、斜体code： 123//_和* 一样_我是歪的_*我是歪的* 结果： 我是歪的我是歪的 九、表格好麻烦 code： 12345| 立正！ | 向左看！ | 向右看齐！|| :----------: |---------- | -----: || 拉克丝 | 潘森 | 伊泽瑞尔 || 弗拉基米尔 | 波比 | 崔丝塔娜 || 费德提克 | 雷克顿 | 库奇 | 结果： 立正！ 向左看！ 向右看齐！ 拉克丝 潘森 伊泽瑞尔 弗拉基米尔 波比 崔丝塔娜 费德提克 雷克顿 库奇 十、phpstorm中的markdown插件Setting –&gt; Plungins –&gt; 搜索markdown ，install]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS居中方法合集]]></title>
    <url>%2F2017-04-09-center.html</url>
    <content type="text"><![CDATA[居中方法合集 看demo去吧/ 行元素居中水平居中text-align:center 垂直居中line-height 块元素居中水平居中margin: 0 auto 水平垂直居中方法一: 纯position + margin本元素：position: absolute;left: 50%;top: 50%;margin-left: -50px;margin-top: -50px;父元素：position: relative;兼容性：兼容所有margin值为本元素宽高的一半123&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.box1&#123; position: relative; width: 200px; height: 200px; background: #ffd2e9;&#125;.box1 .center &#123; position: absolute; left: 50%; top: 50%; width: 100px; height: 100px; background: #8cebf6; margin-left: -50px; margin-top: -50px;&#125; 方法二: position + margin本元素：margin: auto;position: absolute;left: 0;right: 0;top: 0;bottom: 0;父元素：position: relative兼容：不兼容ie6123&lt;div class=&quot;box2&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.box2 &#123; position: relative; width: 200px; height: 200px; background: #ffd2e9;&#125;.box2 .center &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; width: 100px; height: 100px; background: #8cebf6; margin: auto;&#125; 方法三: position + transform方法三-01本元素：position: absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);父元素：position: relative 方法三-02本元素：position: relative;top: 50%;left:50%;display: inline-block;-webkit-transform: translate(-50%);transform: translate(-50%);父元素：nothing兼容性：ie9以下不支持 transformposition定位父元素元素的宽高50%，transform定位本元素的宽高50%12345678&lt;div class=&quot;box3&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box3_&quot;&gt; &lt;div class=&quot;center&quot;&gt; 11111111 &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930.box3&#123; position: relative; width: 200px; height: 200px; background: #ffd2e9;&#125;.box3 .center &#123; position: absolute; top:50%; left:50%; width: 100px; height: 100px; background: #8cebf6; -webkit-transform:translate(-50%,-50%); transform:translate(-50%,-50%);&#125;.box3_&#123; width: 200px; height: 200px; background: #ffd2e9;&#125;.box3_ .center&#123; position: relative; top: 50%; left:50%; display: inline-block; background: #8cebf6; -webkit-transform: translate(-50%); transform: translate(-50%);&#125; 方法四: flex + center本元素：nothing~~父元素：display: flex;align-items: center;justify-content: center;兼容性：适合移动端123&lt;div class=&quot;box4&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.box4&#123; display: flex; width: 200px; height: 200px; align-items: center;/*垂直居中*/ justify-content: center;/*水平居中*/ background: #ffd2e9;&#125;.box4 .center &#123; width: 100px; height: 100px; background: #8cebf6;&#125; 方法五: flex + margin本元素：margin: auto;父元素：display: flex;兼容性：适合移动端123&lt;div class=&quot;box5&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112.box5 &#123; display: flex; width: 200px; height: 200px; background: #ffd2e9;&#125;.box5 .center &#123; width: 100px; height: 100px; margin: auto; background: #8cebf6;&#125; 方法六:table-cell + inline-block本元素：display: inline-block;父元素：display: table-cell;vertical-align: middle;text-align: center;兼容性：不兼容ie6/7123&lt;div class=&quot;box6&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box6&#123; display: table-cell; width: 200px; height: 200px; background: #ffd2e9; vertical-align: middle; text-align: center;&#125;.box6 .center&#123; display: inline-block; width: 100px; height: 100px; background: #8cebf6;&#125; 不定宽高的元素居中上述方法四五六]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo之站点配置和next主题配置]]></title>
    <url>%2F2017-04-07-hexo-next.html</url>
    <content type="text"><![CDATA[给丑丑的默认hexo换个皮肤、 站点配置next主题配置http://www.tuicool.com/articles/ueI7naVNext主题文档：http://theme-next.iissnan.com/Rss:$ npm install hexo-generator-feed –save]]></content>
      <categories>
        <category>别人家的好东西</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看好看的颜色也是一种幸福]]></title>
    <url>%2F2017-04-07-color.html</url>
    <content type="text"><![CDATA[日系传统颜色： 青碧SEIHEKI浅葱ASAGI青磁SEIJI水浅葱MIZUASAGI白群BYAKUGUN瓶覗KAMENOZOKI水MIZU空SORA露草TSUYUKUSA #0080ff]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2017-04-07-hexo.html</url>
    <content type="text"><![CDATA[很酷啊~hexo+github,再加上十几二十块买个酷酷的域名,完成这个小站哦~写写学习笔记，写写杂七杂八的小东西，虽然可能没什么人来看，但是，我开心呀~~~ 一、hexo先配hexo再拉git库吧，不然.git文件在hexo初始化的时候被删掉也是一个心烦的事情内。//1、安装node环境（基本可以忽略，都装了吧）1$ cnpm install npm -g//2、全局安装hexo依赖1$ npm install -g hexo-cli//3、初始化博客文件夹1$ npm init [folder]第一次尝试的报错：说是swig和minimatch要升级到3.0.2的问题，那就在安装一下swig,再升级一下minimatch咯12$ npm install swig$ npm minimatch@”3.0.2”第二次尝试的报错：还是swig有问题咯，那就再装，哼，明明绿了第三次尝试的报错：还是跟第二次一样！！还有这个关于fsevents的报错，是可以忽略的反正他跟你说缺啥，你就用npm install补啥看到INFO Start blogging with Hexo!这句话就ok啦//4、启动hexo12345$ hexo sever//或者$ hexo s//可以自定义端口号，默认是4000，没事也就别改啦$ hexo server -p 1102 //指定1102端口如果前面看到INFO Start blogging with Hexo!，这一步基本没问题。听话地去浏览器打开http://localhost:4000，然后看到这样没有报错最开心了！！第一步搞定！这是hexo的默认主题和配置，然后就可以开始屁颠屁颠改成自己喜欢的样子了咧。二、github//1、建立github库Tip:命名必须 账户名.github.io//2、项目拉取到本地1$ git clone https://github.com/yourname/yourname.github.io三、hexo/github大合体//1、安装deployer依赖1$ npm install hexo-deployer-git --save//2、hexo配置修改 1234567node_modules --&gt;scaffolds --&gt;source --&gt; 文章、图片等资源themes --&gt; 站点主题的相关配置.gitignore --&gt;_config.yml --&gt; 主要改这个文件！！！package.json --&gt; yes!打开_config.yml,就先改# Site和# Deployment这两部分先，其他的以后熟了再细看吧。去看完整版(有空再写哈哈)[_config.yml]12345678910# Sitetitle: #你的网站的名字咧subtitle: #你的网站的副标题咧description: #你的网站的描述咧author: #你的大名咧# Deploymentdeploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 千万千万不要忘记每个冒号后面都要有空格！！WTF! //3、hexo新建文章12345//新建文章$ hexo new test //默认post//新建草稿和文件夹（先别试这个）$ hexo new draft test$ hexo new page test 可以发现source文件夹下的_posts文件夹下多了一个test.md的文件， [test.md]12345---title: test //该文章标题，可以和文件名不一样的date: 2017-04-07 15:00:51tags: //标签，多个用数组[ tag1 , tag2 ]--- //4、hexo打包1$ hexo generate //打包，等同于hexo g //5、hexo同步到git1$ hexo deploy //上传git,等同于hexo d 如果出现下图，一定是前面的_config.yml里面的# Deployment部分没有配置好。 注意红色部分也要有个空格！WTF! 四、世界宇宙超级无敌酷的域名合体 五、hexo常用语句整理12345$ hexo n = hexo new //新建$ hexo s = hexo server //开启$ hexo c = hexo clean //清缓存 $ hexo g = hexo generate //打包$ hexo d = hexo deploy //上传git]]></content>
      <categories>
        <category>别人家的好东西</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nothing]]></title>
    <url>%2F2017-03-30-nothing.html</url>
    <content type="text"><![CDATA[不想撸码的时候要看看电影看看书、看看那些美丽的地方、 书单：1.《React全栈》 作者：张轩 杨寒星 2.《JavaScript高级程序设计》 3.《JavaScript语言精粹》 4.《高性能JavaScript》 电影：1.《暗夜恐惧》 8个黑白简约风高智商小故事 2.《爆裂鼓手》 一定要戴着耳机看，感觉老师才是男主，演技爆表。 3.《立春》 https://www.zhihu.com/question/28882548/answer/42426812?utm_campaign=weekly192&amp;utm_source=weekly-digest&amp;utm_medium=email 旅行攻略：1.[绿野自助户外活动](www.lvye.org) 2.[穷游网:针对国外旅游的攻略论坛](www.go2eu.com)]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>很闲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel安装、编译、配置（cmd和phpstorm）]]></title>
    <url>%2F2017-03-27-babel.html</url>
    <content type="text"><![CDATA[讲道理 这里我要找一张好看的图片（没写完啊没写完，不生气了再写） 开始Babel转码器工具：cmd、phpstorm10.0.3环境：Windows 10好多爹一样的浏览器不支持666的ES6啊！大Babel帮你ES6编译成ES5哦~省事儿~作用： ①让code支持es6 ②支持react的一些特性（eg:JSX） 安装环境12cnpm install babel-cli -gcnpm install babel-cli --save-dev 安装插件前面新建的es5.js和源文件es6.js是一毛一样的，毕竟还没有配置。 新建配置文件.babelrc1234&#123;"presets":[],"plugins":[]&#125; 安装预设1$ cnpm install --save-dev babel-preset-es2015 啊啊啊啊啊啊啊啊啊啊啊啊啊！！！！！答应我这一步千万不要用Terminal来装！！不要用Terminal来装！！不要用Terminal来装！！会炸啊会炸！！老老实实把这个项目关了去打开cmd！无响应了一个世纪、看到红色的这句话，省你一个小时时间！装完趁早吧，好气！也别轻易把node_modules给ignore，找个吃饭的时间弄，不然真当卡死。哦，还有气死！另外，如果phpstorm一直好卡一直indexing的话，可以在phpstorm.vmoptions里面，最后加上12-Dawt.usesystemAAFontSettings=lcd -Dawt.java2d.opengl=true 回归正题，在.babelrc文件里加上es2015的字段，在package.js加上对应字段。[.babelrc]1234&#123;"presets":["es2015"],"plugins":[]&#125; [package.js]123"babel": &#123; "presets": ["es2015"]&#125; 安装展开符插件1$ cnpm install babel-plugin-transform-object-rest-spread --save-dev 在.babelrc文件里加上transform-object-rest-spread的字段1234&#123;"presets":["es2015"],"plugins":["transform-object-rest-spread"]&#125; 三、编译es6文件夹底下新建es6.js123let number = [1,2,3];let double = number.map((n) =&gt; n*2);console.log(double); 如果出现红红黄黄的报错↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓File =&gt; settings =&gt; Languages =&gt; JavaScript =&gt; JavaScript language version 改为ECMAScript6 然后apply一下、 cmd编译$ babel es6.jscmd窗口的结果：123456789"use strict";/***Created by rawraw on 2017/3/27.var number = [1, 2, 3];var double2 = number.map(function (n) &#123; return n * 2;&#125;);console.log(double2); 手动编译先试一下安装的杂七杂八能不能运行起来 cmd文件 to 文件123$ babel es6/es6.js -o es5/es5.js//或者$ babel es6/es6.js --out-file es5/es5.js 文件夹 to 文件夹123$ babel es6 -d es5//或者$ babel es6 --out-dir es5 文件夹 to 文件123$ babel es6 -d es5//或者$ babel es6 --out-file es5/es5.js 直接运行es6 codebabel-node 通过phpstorm下面的terminal嗯，好，很完美。然后es5文件夹下es5.js的内容试这样子的[es5.js]123456"use strict";var number = [1, 2, 3];var double2 = number.map(function (n) &#123; return n * 2;&#125;);console.log(double2); 自动编译cmd监听123$ babel es6/es6.js -w -o es5/es5.js//或者$ babel es6/es6.js --watch --out-file es5/es5.js phpstorm添加事件监听这个时候，如果讲道理的话，自己会弹出来这个，那就很happy地点击add添加事件监听。 不讲道理的话，↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓File =&gt; settings =&gt; Tools =&gt; File Watchers =&gt; + =&gt; Babel名字随意取咯~如果这个时候apply,不设置编译后目标文件夹，默认是在该文件下生成一个js和js.mapTips:在babel监听配置之前，已存在的js文件，需要发生修改，才会触发自动编译。可以在中间回车几下。不过好丑好难过啊，还是整一个文件夹给它吧(自动编译定位在虚线内，也可以跳过啊，并没有影响) 好啦好啦，开始正式配置了、主要修改scope 和 output paths,就是编译前的文件夹和编译后的文件夹需要进行编译的文件夹：绿色框框的是哪个按钮啥意思自己去百度哈，总之就是选文件夹用的、如果这个时候apply,不设置编译后目标文件夹，默认是在该文件下生成一个js和js.map原：$FileNameWithoutExtension$-compiled.js:$FileNameWithoutExtension$-compiled.js.map改：$ProjectFileDir$\es5\$FileNameWithoutExtension$.js 并且，很稳地出现报错： 主要就是这句：Error: Couldn&#39;t find preset &quot;env&quot; relative to directory &quot;es5&quot;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>JavaScript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LESS环境部署]]></title>
    <url>%2F2017-03-24-less.html</url>
    <content type="text"><![CDATA[等等再发咯]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇test]]></title>
    <url>%2F2017-03-22-test1.html</url>
    <content type="text"><![CDATA[1 + 1 = 11 ? nothing测试1测试2[reset.css]1body &#123; margin: 0; padding: 0; &#125; 一、一级标题//2、二级标题红的呢]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
