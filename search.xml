<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[模块打包-bundler：browserify、webpack、RequireJS/AMD]]></title>
      <url>%2F2017%2F05%2F26%2Fbundler%2F</url>
      <content type="text"><![CDATA[目前比较完善的模块打包：browserify和webpack。webpack在browserify之后出现。 browserifywebpackRequireJS/AMD]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[任务流工具-taskrunner：Grunt、Gulp]]></title>
      <url>%2F2017%2F05%2F26%2Ftask-runner%2F</url>
      <content type="text"><![CDATA[目前比较完善的任务流工具：Grunt和Gulp。Gulp在Grunt之后出现，有Grunt的优点，同时增加了新特性。 Grunt安装npm install grunt-cli -g Gulp安装npm install gulp-cli -g]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[design patterns - JavaScript设计模式]]></title>
      <url>%2F2017%2F05%2F25%2Fdesign-patterns%2F</url>
      <content type="text"><![CDATA[哎，最不想整理的就是这一块了 最初在设计模式 一书中，许多设计模式都鼓励使用松散耦合。在更改一个代码片段时，就会发生问题，系统其他部分 —— 曾认为完全不相关的部分中也有可能出现级联破坏。该问题在于紧密耦合 。系统某个部分中的函数和类严重依赖于系统的其他部分中函数和类的行为和结构。您需要一组模式，使这些类能够相互通信，但不希望将它们紧密绑定在一起，以避免出现联锁。 工厂模式简单工厂模式12345678910111213141516function BuyHero(name,type,price)&#123; var obj = &#123;&#125;; obj.name = name; obj.age = type; obj.price = price; obj.sayName = function()&#123; return this.name; &#125;; return obj;&#125;var h1 = new BuyHero('Teemo','ADC','6300');var h2 = new BuyHero('Amumu','Jungle','3100');//返回都是object 无法识别对象的类型，哪个对象的实列 console.log(typeof h1); // object console.log(typeof h2); // object console.log(h1 instanceof Object); // true 复杂工厂模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 定义英雄池的构造函数var League = function(name)&#123; this.name = name; this.method = function()&#123; return this.name; &#125;&#125;;League.prototype = &#123; constructor: League, /* * 买英雄这个方法 * @param &#123;name&#125; 英雄名字 */ buyHero: function(name)&#123; var hero = this.createHero(name); // 执行Q、W...技能，哦，业务逻辑 hero.Q(); hero.W(); return hero; &#125;, createHero: function(model)&#123; throw new Error("父类是抽象类不能直接调用，需要子类重写该方法"); &#125;&#125;;// 实现原型继承function extend(Sub,Sup) &#123;//Sub表示子类，Sup表示超类 var F = function()&#123;&#125;;// 首先定义一个空函数 F.prototype = Sup.prototype;// 设置空函数的原型为超类的原型 Sub.prototype = new F();// 实例化空函数，并把超类原型引用传递给子类 Sub.prototype.constructor = Sub;// 重置子类原型的构造器为子类自身 Sub.sup = Sup.prototype;// 在子类中保存超类的原型,避免子类与超类耦合 if(Sup.prototype.constructor === Object.prototype.constructor) &#123; Sup.prototype.constructor = Sup;// 检测超类原型的构造器是否为原型自身 &#125;&#125;var HeroChild = function(name)&#123; this.name = name; // 继承构造函数父类中的属性和方法 League.call(this,name);&#125;;// 子类继承父类原型方法extend(HeroChild,League);// BicycleChild 子类重写父类的方法HeroChild.prototype.createHero = function()&#123; var Q = function()&#123; console.log("执行Q业务操作"); &#125;; var W = function()&#123; console.log("执行W业务操作"); &#125;; return &#123; Q: Q, W: W &#125;&#125;;var Teemo = new HeroChild("提莫"); console.log(Teemo); console.log(Teemo.name);//提莫 Teemo.buyHero(); 理解 父类是一个抽象类，不能被实列化,将其成员对象的实列化推迟到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。子类之间是相互独立的。 优点解决多个类似对象声明的问题;解决实列化对象产生重复的问题。在父类中编写一些相同的方法代码,在子类中重写该父类的方法，去实现具体的业务逻辑。 1/弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。 2/重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。 缺点无法获取对象类型 单体模式封装单体模式123456789101112131415161718192021222324252627282930313233343536// 写法一var Singleton = function(name)&#123; this.name = name; this.instance = null;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;;// 获取实例对象function getInstance(name) &#123; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;// 写法二var Singleton = function(name)&#123; this.name = name; &#125;; Singleton.prototype.getName = function()&#123; return this.name; &#125; // 获取实例对象 var getInstance = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125; &#125;)();// 测试单体模式的实例var a = getInstance("aa");var b = getInstance("bb");console.log(a===b);// true,b的实例就是a的实例 使用代理实现单体模式具体的单体模式中的实例化类的事情交给代理函数去处理，这样做的好处是具体的业务逻辑分开了，代理只管代理的业务逻辑，在这里代理的作用是实例化对象，并且只实例化一次; 创建div代码只管创建div，其他的不管；12345678910111213141516171819202122232425262728293031323334353637//创建一个div//第一种var CreateDiv = function(html) &#123; this.html = html; this.init();&#125;;CreateDiv.prototype.init = function()&#123; var div = document.createElement("div"); div.innerHTML = this.html; document.body.appendChild(div);&#125;;// 代理实现单体模式var ProxyMode = (function()&#123; var instance; return function(html) &#123; if(!instance) &#123; instance = new CreateDiv("rawraw hello"); &#125; return instance; &#125;&#125;)();//第二种 // 代理实现单体模式 var ProxyMode = (function()&#123; var instance; return function(html) &#123; if(!instance) &#123; instance = document.createElement("div"); instance.innerHTML = "rawraw hello"; document.body.appendChild(instance); &#125; return instance; &#125; &#125;)();var a = new ProxyMode("aaa");var b = new ProxyMode("bbb");console.log(a===b);// true 综合123456789101112131415161718192021222324252627282930313233// 创建divvar createWindow = function()&#123; var div = document.createElement("div"); div.innerHTML = "我是弹窗内容"; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;// 创建iframevar createIframe = function()&#123; var iframe = document.createElement("iframe"); document.body.appendChild(iframe); return iframe;&#125;;// 获取实例的封装代码var getInstance = function(fn) &#123; var result; return function()&#123; return result || (result = fn.call(this,arguments)); &#125;&#125;;// 测试创建divvar createSingleDiv = getInstance(createWindow);document.getElementById("test").onclick = function()&#123; var win = createSingleDiv(); win.style.display = "block";&#125;;// 测试创建iframevar createSingleIframe = getInstance(createIframe);document.getElementById("test").onclick = function()&#123; var win = createSingleIframe(); win.innerHTML = "rawraw hello";&#125;; 理解 单体模式是以对象字面量的方式来创建单体模式一个用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。以对象字面量的方式来创建单体模式。 适用场景：弹窗 优点缺点模块模式123456789101112var singleMode = (function()&#123; var privateNum = 112;// 创建私有变量 // 创建私有函数 function privateFunc()&#123; // 实现自己的业务逻辑代码 &#125; // 返回一个对象包含公有方法和属性 return &#123; publicMethod1: publicMethod1, publicMethod2: publicMethod1 &#125;;&#125;)(); 模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，先定义了私有变量和函数，供内部函数使用，然后将一个对象字面量作为函数的值返回，返回的对象字面量中只包含可以公开的属性和方法。这样的话，可以提供外部使用该方法；由于该返回对象中的公有方法是在匿名函数内部定义的，因此它可以访问内部的私有变量和函数。 增强的模块模式适合那些单列必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况。12345678910111213141516171819202122function CustomType() &#123; this.name = "rawraw";&#125;CustomType.prototype.getName = function()&#123; return this.name;&#125;;var application = (function()&#123; var privateA = "aa";// 定义私有 function A()&#123;&#125;// 定义私有函数 var object = new CustomType();// 实例化一个对象后，返回该实例，然后为该实例增加一些公有属性和方法 object.A = "cc";// 添加公有属性 // 添加公有方法 object.B = function()&#123; return privateA; &#125;; return object;// 返回该对象&#125;)();console.log(application);console.log(application.A);// ccconsole.log(application.B()); // aaconsole.log(application.name); // rawrawconsole.log(application.getName());// rawraw 理解 模块模式的思路是为单体模式添加私有变量和私有方法能够减少全局变量的使用； 适用场景：必须创建一个对象并以某些数据进行初始化，同时还要公开一些能够访问这些私有数据的方法 优点缺点代理模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647```## 理解&gt;&gt;&gt; 适用场景：图片预加载## 案例```js// 不使用代理的预加载图片函数如下var myImage = (function()&#123; var imgNode = document.createElement(&quot;img&quot;); document.body.appendChild(imgNode); var img = new Image(); img.onload = function()&#123; imgNode.src = this.src; &#125;; return &#123; setSrc: function(src) &#123; imgNode.src = &quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;; img.src = src; &#125; &#125;&#125;)();// 调用方式myImage.setSrc(&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;);var myImage = (function()&#123; var imgNode = document.createElement(&quot;img&quot;); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();// 代理模式var ProxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src) &#123; myImage.setSrc(&quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;); img.src = src; &#125; &#125;&#125;)();// 调用方式ProxyImage.setSrc(&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;); 优点1.代理对象可以代替本体被实例化，并使其可以被远程访问；2.它还可以把本体实例化推迟到真正需要的时候；对于实例化比较费时的本体对象，或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象； 缺点职责链模式12345```## 理解## 优点## 缺点# 命令模式 1234## 理解## 优点## 缺点# 模板方法模式 1234## 理解## 优点## 缺点# 策略模式 1234## 理解## 优点## 缺点# 发布-订阅模式(观察者模式) 1234## 理解## 优点## 缺点# 中介者模式 ``` 理解优点缺点http://www.cnblogs.com/tugenhua0707/p/5198407.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Front-end总结]]></title>
      <url>%2F2017%2F05%2F25%2Ffront-end%2F</url>
      <content type="text"><![CDATA[前端学习流程整理、我的小计划。然后可能就是大神了吧，哈哈哈哈哈哈哈哈哈哈~ 要不要画个图 我先纠结几天吧、]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[navicat for mysql安装问题]]></title>
      <url>%2F2017%2F05%2F16%2Fnavicat%2F</url>
      <content type="text"><![CDATA[navicat for mysql安装问题小集合 10451234C:\xampp\MySQL\bin mysql -u root mysql mysql&gt; UPDATE user SET Password=PASSWORD(&apos;newpassword&apos;) where USER=&apos;root&apos;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xampp配置虚拟主机]]></title>
      <url>%2F2017%2F05%2F16%2Fxampp%2F</url>
      <content type="text"><![CDATA[xampp配置虚拟主机 首先，xampp要可以基本运行起来 域名配置以管理员身份运行hosts,新增127.0.0.1 test.com xampp配置1234567891011&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;E:/test&quot; ## 文件根目录 ServerName test.com ## 虚拟域名 &lt;Directory E:/test&gt; ## 文件根目录 Options -Indexes AllowOverride ALL DirectoryIndex index.php index.html Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http协议]]></title>
      <url>%2F2017%2F05%2F10%2Fhttp%2F</url>
      <content type="text"><![CDATA[一个页面的呈现，经历了怎样的对白、 在浏览器输入url地址浏览器查找域名的 IP 地址 http://mp.weixin.qq.com/s/Z-vKtayFWPZ-E-mXAgVNsQhttp://mp.weixin.qq.com/s/monpEQJWf1MpBYManDY12A]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式整理]]></title>
      <url>%2F2017%2F05%2F09%2Fregexp%2F</url>
      <content type="text"><![CDATA[特别简单的就不记下来了，这么简单都还要来翻，还撸什么码/ 汉字: ^[\u4e00-\u9fa5]{0,}$email: ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[优化总结]]></title>
      <url>%2F2017%2F05%2F04%2Foptimize%2F</url>
      <content type="text"><![CDATA[better better ~~ 强迫症的宝宝-_— 图片清晰度动画3D启用硬件加速1234#test &#123; -webkit-transform:translate3d(0, 0, 0) transform: translate3d(0, 0, 0);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[各种爹一样的兼容处理]]></title>
      <url>%2F2017%2F05%2F03%2Fcompatible%2F</url>
      <content type="text"><![CDATA[好奇怪的ie678,好奇怪的安卓机，好奇怪的ios爸爸。。。 web端杂在ie6-7中，用margin-bottom代替padding 移动端]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[好用的小东西整理]]></title>
      <url>%2F2017%2F05%2F03%2Fcss3%2F</url>
      <content type="text"><![CDATA[常用的css3巴拉巴拉的，js小技巧-_- CSS部分 移动端将文本分成多列12345#test&#123; -moz-column-count:3; -webkit-column-count:3; column-count:3;&#125; 创建模糊文本123456#test &#123; color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125; ``` ### pre标签内文本自动换行 pre{ overflow: auto; background-color: #f1f1f1; overflow-x: auto; /* Use horizontal scroller if needed; for Firefox 2, not white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */ word-wrap: break-word; /* Internet Explorer 5.5+ */ margin: 0; padding:5px 5px 3px 5px; white-space : normal; /* crucial for IE 6, maybe 7? */ } 1### 表格自动宽度 td { white-space: nowrap;}12### 让滚动条顺溜地滑定位后的滑动会出现卡顿 body { -webkit-overflow-scrolling: touch; overflow-scrolling: touch;}1### 长按闪退 #test{ -webkit-touch-callout: none;}1### select 设置右对齐 select option { direction: rtl;}1### touch时有半透明灰色遮罩（ios和android） #test{ -webkit-tap-highlight-color:rgba(255,255,255,0)}1### 输入框默认内阴影、以及默认样式(ios) #test{ -webkit-appearance: none;}123456789### 部分机型存在type为search的input，自带close按钮样式&gt;`#Search::-webkit-search-cancel-button&#123; display: none; &#125;`### 默认首字母会大写(ios)&gt;`&lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt;`### 圆角失效(某些Android) #test{ background-clip: padding-box;}1234567### 移动端伪类 `:active` 失效移动端应该是touch&gt;`&lt;body ontouchstart=&quot;&quot;&gt;` &gt;或者`document.addEventListener(&apos;touchstart&apos;,function()&#123;&#125;,false);`## 浏览器### 禁止复制、选中文本 #test{ -webkit-user-select: none; -moz-user-select: none; -khtml-user-select: none; user-select: none;}123456789101112131415161718192021### 消除 IE10 的叉号&gt;`input:-ms-clear&#123;display:none;&#125;`### css垂直居中 ![去这里看](center) ## CSS3### 伪类#### 修改选中文本的颜色：```css [ 举一个栗子 ]user-select:none::selection&#123;color: white;background-color: red;&#125; ::-moz-selection &#123;color: white;background-color: red;&#125; 首字母设置12345678910111213#test:first-child::first-letter&#123; font-size: 28px; font-weight: bold;&#125;/*首字下沉*/p:first-letter&#123; display:block; margin:5px 0 0 5px; float:left; color:#FF3366; font-size:60px; font-family:Georgia; &#125; 透明度的兼容123456#test &#123; filter: alpha(opacity=50); /* internet explorer */ -khtml-opacity: 0.5; /* khtml, old safari */ -moz-opacity: 0.5; /* mozilla, netscape */ opacity: 0.5; /* fx, safari, opera */&#125; webkit mask遮罩要记得来写http://www.cnblogs.com/cosiray/archive/2012/12/06/2804770.html transform出现锯齿123-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0); transform: rotate(-4deg) skew(10deg) translateZ(0); outline: 1px solid rgba(255,255,255,0) 渐变[ 举一个栗子 ]12345678910111213141516171819202122232425262728/*上至下，默认方向*/#test&#123; background: -webkit-linear-gradient(#000, #fff); background: -o-linear-gradient(#000, #fff); background: -moz-linear-gradient(#000, #fff); background: linear-gradient(#000, #fff); &#125;/*左至右*/#test2 &#123; background: -webkit-linear-gradient(left, #000 , #fff); background: -o-linear-gradient(right, #000, #fff); background: -moz-linear-gradient(right, #000, #fff); background: linear-gradient(to right, #000 , #fff); &#125;/*角度。12点方向为0deg,顺时针增加deg*/#test3 &#123; background: -webkit-linear-gradient(180deg, #000, #fff); background: -o-linear-gradient(180deg, #000, #fff); background: -moz-linear-gradient(180deg, #000, #fff); background: linear-gradient(180deg, #000, #fff);&#125;/*也可以径向渐变，多种颜色，透明度*/#test4&#123; background: -webkit-radial-gradient(#000 , #fff 10%, #000 20%); background: -o-radial-gradient(#000, #fff 10%, #000 20%); background: -moz-radial-gradient(#000, #fff 10%, #000 20%); background: radial-gradient(#000, #fff 10%, #000 20%); &#125; JS部分 中文输入法输入英文时，有六分之一空格（ios） this.value = this.value.replace(/\u2006/g, &#39;&#39;); 移动端autoplay 失效问题必须由用户来触发才可以播放。touchstart 触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。 document.addEventListener(&#39;touchstart&#39;, function () { document.getElementsByTagName(&#39;audio&#39;)[0].play(); document.getElementsByTagName(&#39;audio&#39;)[0].pause(); }); 批量修改样式[ 举一个栗子 ]1div.style.cssText = 'width:100px;height:100px;' 展开select的option123456function showDropdown(sltElement) &#123; var event; event = document.createEvent(&apos;MouseEvents&apos;); event.initMouseEvent(&apos;mousedown&apos;, true, true, window); sltElement.dispatchEvent(event);&#125;; HTML部分 meta标签apple-mobile-web-app-capableapple-mobile-web-app-capable是设置Web应用是否以全屏模式运行。 &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; 缓存有时候改了bug刷新并没有卵用，然后就好气啊。手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。 &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt;format-detection 启动或禁用自动识别页面中的电话号码。&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; 奇怪的浏览器强制屏幕12345678910111213141516171819&lt;!-- QQ浏览器私有 --&gt;&lt;!-- 全屏模式 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- 强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- 强制横屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;landscape&quot;&gt;&lt;!-- 应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- UC浏览器私有 --&gt;&lt;!-- 全屏模式 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- 强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- 强制横屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;landscape&quot;&gt;&lt;!-- 应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; 移动端拨打电话功能（安卓、ios都可以） &lt;a href=&quot;tel:10086&quot;&gt;10086&lt;/a&gt; app横屏字体text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-size-adjust: 100%; 顶部状态栏背景色先指定全屏模式 apple-mobile-web-app-capable&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;blank&quot; /&gt; content:default 正常显示 blank 黑色背景 lank-translucent 黑色半透明，页面主体会向上占据位置 桌面图标图片尺寸可以设定为5757（px）或者Retina可以定为114114（px），ipad尺寸为72*72（px) 去光泽 &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;touch-icon-iphone.png&quot; /&gt; 启动画面 &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;start.png&quot;/&gt;iOS下页面启动加载时显示的画面图片，避免加载时的白屏。可以通过madia来指定不同的大小：1234567891011121314151617181920&lt;!--iPhone--&gt; &lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone Retina --&gt; &lt;link href=&quot;apple-touch-startup-image-640x920.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone 5 --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; media=&quot;(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)&quot; href=&quot;apple-touch-startup-image-640x1096.png&quot;&gt; &lt;!-- iPad portrait --&gt; &lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad landscape --&gt; &lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina portrait --&gt; &lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina landscape --&gt; &lt;link href=&quot;apple-touch-startup-image-1496x2048.png&quot;media=&quot;(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot;rel=&quot;apple-touch-startup-image&quot; /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[\\这个插件还可以//之select2]]></title>
      <url>%2F2017%2F04%2F19%2Fplu-select2%2F</url>
      <content type="text"><![CDATA[placeholder: 一定要加空的 [ 举一个栗子 ]1234567$('#test').select2(&#123; data:[ &#123;id:1,text:"teemo"&#125;, &#123;id:2,text:"anni"&#125;, //... ]&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试大宝典]]></title>
      <url>%2F2017%2F04%2F12%2Finterview%2F</url>
      <content type="text"><![CDATA[为什么要学习前端对前端的认识基础知识CSS部分盒子模型window.top.document.compatMode ？ 自适应calc/box JS部分闭包什么情况下会发生闭包，为什么需要闭包，什么场景下需要，闭包闭了谁，怎么释放被闭包的变量内存，闭包的优点是什么，缺点是什么等等。 事件模型及事件代理/委托事件的三个阶段捕获，目标，冒泡阶段(低版本IE不支持捕获阶段) {事件的代理/委托}的原理以及优缺点优点 大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适事件代理的应用常用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不应用触发事件的被绑上了事件 IE和W3C不同绑定事件解绑事件的方法有什么区别，参数分别是什么，以及事件对象e有什么区别target，currentTarget，以及IE下的srcElement和this 实现事件模型即写一个类或是一个模块，有两个函数，一个bind一个trigger，分别实现绑定事件和触发事件，核心需求就是可以对某一个事件名称绑定多个事件响应函数，然后触发这个事件名称时，依次按绑定顺序触发相应的响应函数。 大致实现思路就是创建一个类或是匿名函数，在bind和trigger函数外层作用域创建一个字典对象，用于存储注册的事件及响应函数列表，bind时，如果字典没有则创建一个，key是事件名称，value是数组，里面放着当前注册的响应函数，如果字段中有，那么就直接push到数组即可。trigger时调出来依次触发事件响应函数即可。 不过还有很多细节，比如触发响应函数时的上下文应该是什么，触发响应函数的参数列表应该是什么，如果要求把调用trigger的参数列表都传到响应函数中还要考虑到吧arguments对象转化为纯数组才行等等。 还有一些面试官会问到事件如何派发也就是事件广播（dispatchEvent）等等，这里不再展开。 Function.bind函数作用，应用场景，举个栗子1、Function.bind返回的也是一个函数，所以注定发生了闭包；2、在返回的这个函数中去调用一个其他的函数，这其实本质上就是函数钩子(HOOK)；1、保持函数的this指向；2、保持函数的所有参数都传递到目标函数；3、保持函数的返回值； 123456789101112131415161718192021222324if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== &quot;function&quot;) &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 算法排序、去重巴拉巴拉js变量提升(es6)跨域问题http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.htmlhttp://www.cnblogs.com/scottckt/archive/2011/11/12/2246531.htmlhttp://www.cnblogs.com/cat3/archive/2011/06/15/2081559.htmlJSONP原理。这里简单讲就是HTML里面所有带src属性的标签都可以跨域，如iframe，img，script等。 正则尽量不要拆字符，不可预知性1234567891011121314function getQueryObject(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(&quot;?&quot;) + 1); var obj = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (rs, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); val = String(val); obj[name] = val; return rs; &#125;); return obj;&#125; 性能优化网络性能优化，加快访问速度，浏览器并行加载数量，怎样实现原生JS异步载入，CDN加速的原理，如何将不同静态资源发布到多个域名服务器上，发布后这些静态字段的url路径改怎么批量改写，用什么工具进行项目打包，css打包后的相对路径怎么转换为绝对路径，用什么工具进行项目模块依赖管理，怎么进行cookie优化文件合并文件最小化/文件压缩使用CDN托管缓存的使用 函数节流http://www.alloyteam.com/2012/11/javascript-throttle/ 前端设计模式比较多的有观察者模式，职责链模式，工厂模式。比如如何去设计一个前端UI组件，应该公开出哪些方法，应该提供哪些接口，应该提供哪些事件。哪部分逻辑流程应该开放出去让用户自行编写，如何实现组件与组件之间的通信，如何实现高内聚低耦合，如何实现组件的高复用等等 前端面试问题合集 了解这家公司版本管理流程管理每天怎么知道要做什么事情？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown常用语法]]></title>
      <url>%2F2017%2F04%2F11%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[markdown：语法比较少也简单，用来写作排版很棒哦、markdownpad：编译+预览的功能。纯编译的话，一般编辑器都可以。markdownpad2破解绿色中文版下载&emsp;提取密码：2ne1 一、标题1.第一种方法的标题code： 123456# 一级标题## 二级标题### 三级标题 #### 四级标题##### 五级标题###### 六级标题 结果：最小到6个###### 一级标题二级标题三级标题四级标题五级标题六级标题2. 第二种方法的标题code： 12345一级标题=============二级标题---- 结果： 一级标题二级标题3. 第三种方法的标题code： 12345678&lt;font size=1&gt;rawraw&lt;/font&gt;&lt;font size=2&gt;rawraw&lt;/font&gt;&lt;font size=3&gt;rawraw&lt;/font&gt;&lt;font size=4&gt;rawraw&lt;/font&gt;&lt;font size=5&gt;rawraw&lt;/font&gt;&lt;font size=6&gt;rawraw&lt;/font&gt;&lt;font size=7&gt;rawraw&lt;/font&gt;&lt;font size=8&gt;rawraw&lt;/font&gt; 结果：最大到7rawrawrawrawrawrawrawrawrawrawrawrawrawrawrawraw 二、排序code： 1234567891011121314//无序 * == + == -* raw* rawraw* raw+ raw+ rawraw+ rawrawraw- raw- rawraw- rawrawraw//有序，相当于自己写吧1. 提莫2. 娑娜3. 莫甘娜 结果： raw rawraw raw raw rawraw rawrawraw raw rawraw rawrawraw 提莫 娑娜 莫甘娜 三、引用code： 12&gt; 这是一段引用&gt;&gt; 这是一段引用的嵌套 结果： 这是一段引用 这是一段引用的嵌套 四、图片code： 1![“好看死了的图片”](/images/bg/0004.jpg) 结果： 五、链接code： 123456[去吧，皮卡丘](nothing)[回到主页](http://rawraw.info)飞去百度吧[Baidu] [1] ,或者[Rawraw] [2] 或者 [nothing] [3]. [1]: http://www.baidu.com/ "Baidu" [2]: http://rawraw.info "Rawrawh" [3]: nothing "nothing" 结果： 去吧，皮卡丘回到主页飞去百度吧Baidu ,或者Rawraw 或者 nothing. 文章内部链接的话，可以利用a的锚点 六、代码code： 123456//行内代码`body &#123; margin: 0; padding: 0; &#125;`//行内代码代码块```CSS [reset.css]body &#123; margin: 0; padding: 0; &#125;\`\`\` 结果： body { margin: 0; padding: 0; } [reset.css]1body &#123; margin: 0; padding: 0; &#125; 七、分割线code： 123***//或者--- 结果： 八、斜体code： 123//_和* 一样_我是歪的_*我是歪的* 结果： 我是歪的我是歪的 九、表格好麻烦 code： 12345| 立正！ | 向左看！ | 向右看齐！|| :----------: |---------- | -----: || 拉克丝 | 潘森 | 伊泽瑞尔 || 弗拉基米尔 | 波比 | 崔丝塔娜 || 费德提克 | 雷克顿 | 库奇 | 结果： 立正！ 向左看！ 向右看齐！ 拉克丝 潘森 伊泽瑞尔 弗拉基米尔 波比 崔丝塔娜 费德提克 雷克顿 库奇 十、phpstorm中的markdown插件Setting –&gt; Plungins –&gt; 搜索markdown ，install]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS居中方法合集]]></title>
      <url>%2F2017%2F04%2F09%2Fcenter%2F</url>
      <content type="text"><![CDATA[居中方法合集 看demo去吧/ 行元素居中水平居中text-align:center 垂直居中line-height 块元素居中水平居中margin: 0 auto 水平垂直居中方法一: 纯position + margin本元素：position: absolute;left: 50%;top: 50%;margin-left: -50px;margin-top: -50px;父元素：position: relative;兼容性：兼容所有margin值为本元素宽高的一半123&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.box1&#123; position: relative; width: 200px; height: 200px; background: #ffd2e9;&#125;.box1 .center &#123; position: absolute; left: 50%; top: 50%; width: 100px; height: 100px; background: #8cebf6; margin-left: -50px; margin-top: -50px;&#125; 方法二: position + margin本元素：margin: auto;position: absolute;left: 0;right: 0;top: 0;bottom: 0;父元素：position: relative兼容：不兼容ie6123&lt;div class=&quot;box2&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.box2 &#123; position: relative; width: 200px; height: 200px; background: #ffd2e9;&#125;.box2 .center &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; width: 100px; height: 100px; background: #8cebf6; margin: auto;&#125; 方法三: position + transform方法三-01本元素：position: absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);父元素：position: relative 方法三-02本元素：position: relative;top: 50%;left:50%;display: inline-block;-webkit-transform: translate(-50%);transform: translate(-50%);父元素：nothing兼容性：ie9以下不支持 transformposition定位父元素元素的宽高50%，transform定位本元素的宽高50%12345678&lt;div class=&quot;box3&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box3_&quot;&gt; &lt;div class=&quot;center&quot;&gt; 11111111 &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930.box3&#123; position: relative; width: 200px; height: 200px; background: #ffd2e9;&#125;.box3 .center &#123; position: absolute; top:50%; left:50%; width: 100px; height: 100px; background: #8cebf6; -webkit-transform:translate(-50%,-50%); transform:translate(-50%,-50%);&#125;.box3_&#123; width: 200px; height: 200px; background: #ffd2e9;&#125;.box3_ .center&#123; position: relative; top: 50%; left:50%; display: inline-block; background: #8cebf6; -webkit-transform: translate(-50%); transform: translate(-50%);&#125; 方法四: flex + center本元素：nothing~~父元素：display: flex;align-items: center;justify-content: center;兼容性：适合移动端123&lt;div class=&quot;box4&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.box4&#123; display: flex; width: 200px; height: 200px; align-items: center;/*垂直居中*/ justify-content: center;/*水平居中*/ background: #ffd2e9;&#125;.box4 .center &#123; width: 100px; height: 100px; background: #8cebf6;&#125; 方法五: flex + margin本元素：margin: auto;父元素：display: flex;兼容性：适合移动端123&lt;div class=&quot;box5&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112.box5 &#123; display: flex; width: 200px; height: 200px; background: #ffd2e9;&#125;.box5 .center &#123; width: 100px; height: 100px; margin: auto; background: #8cebf6;&#125; 方法六:table-cell + inline-block本元素：display: inline-block;父元素：display: table-cell;vertical-align: middle;text-align: center;兼容性：不兼容ie6/7123&lt;div class=&quot;box6&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box6&#123; display: table-cell; width: 200px; height: 200px; background: #ffd2e9; vertical-align: middle; text-align: center;&#125;.box6 .center&#123; display: inline-block; width: 100px; height: 100px; background: #8cebf6;&#125; 不定宽高的元素居中上述方法四五六]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo之站点配置和next主题配置]]></title>
      <url>%2F2017%2F04%2F07%2Fhexo-next%2F</url>
      <content type="text"><![CDATA[给丑丑的默认hexo换个皮肤、 一、站点配置 一、next主题配置http://www.tuicool.com/articles/ueI7naVNext主题文档：http://theme-next.iissnan.com/Rss:$ npm install hexo-generator-feed –save]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[看好看的颜色也是一种幸福]]></title>
      <url>%2F2017%2F04%2F07%2Fcolor%2F</url>
      <content type="text"><![CDATA[日系传统颜色： 青碧SEIHEKI浅葱ASAGI青磁SEIJI水浅葱MIZUASAGI白群BYAKUGUN瓶覗KAMENOZOKI水MIZU空SORA露草TSUYUKUSA #0080ff]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo搭建个人博客]]></title>
      <url>%2F2017%2F04%2F07%2Fhexo%2F</url>
      <content type="text"><![CDATA[很酷啊~hexo+github,再加上十几二十块买个酷酷的域名,完成这个小站哦~写写学习笔记，写写杂七杂八的小东西，虽然可能没什么人来看，但是，我开心呀~~~ 一、hexo先配hexo再拉git库吧，不然.git文件在hexo初始化的时候被删掉也是一个心烦的事情内。//1、安装node环境（基本可以忽略，都装了吧）1$ cnpm install npm -g//2、全局安装hexo依赖1$ npm install -g hexo-cli//3、初始化博客文件夹1$ npm init [folder]第一次尝试的报错：说是swig和minimatch要升级到3.0.2的问题，那就在安装一下swig,再升级一下minimatch咯12$ npm install swig$ npm minimatch@”3.0.2”第二次尝试的报错：还是swig有问题咯，那就再装，哼，明明绿了第三次尝试的报错：还是跟第二次一样！！还有这个关于fsevents的报错，是可以忽略的反正他跟你说缺啥，你就用npm install补啥看到INFO Start blogging with Hexo!这句话就ok啦//4、启动hexo12345$ hexo sever//或者$ hexo s//可以自定义端口号，默认是4000，没事也就别改啦$ hexo server -p 1102 //指定1102端口如果前面看到INFO Start blogging with Hexo!，这一步基本没问题。听话地去浏览器打开http://localhost:4000，然后看到这样没有报错最开心了！！第一步搞定！这是hexo的默认主题和配置，然后就可以开始屁颠屁颠改成自己喜欢的样子了咧。二、github//1、建立github库Tip:命名必须 账户名.github.io//2、项目拉取到本地1$ git clone https://github.com/yourname/yourname.github.io三、hexo/github大合体//1、安装deployer依赖1$ npm install hexo-deployer-git --save//2、hexo配置修改 1234567node_modules --&gt;scaffolds --&gt;source --&gt; 文章、图片等资源themes --&gt; 站点主题的相关配置.gitignore --&gt;_config.yml --&gt; 主要改这个文件！！！package.json --&gt; yes!打开_config.yml,就先改# Site和# Deployment这两部分先，其他的以后熟了再细看吧。去看完整版(有空再写哈哈)[_config.yml]12345678910# Sitetitle: #你的网站的名字咧subtitle: #你的网站的副标题咧description: #你的网站的描述咧author: #你的大名咧# Deploymentdeploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 千万千万不要忘记每个冒号后面都要有空格！！WTF! //3、hexo新建文章12345//新建文章$ hexo new test //默认post//新建草稿和文件夹（先别试这个）$ hexo new draft test$ hexo new page test 可以发现source文件夹下的_posts文件夹下多了一个test.md的文件， [test.md]12345---title: test //该文章标题，可以和文件名不一样的date: 2017-04-07 15:00:51tags: //标签，多个用数组[ tag1 , tag2 ]--- //4、hexo打包1$ hexo generate //打包，等同于hexo g //5、hexo同步到git1$ hexo deploy //上传git,等同于hexo d 如果出现下图，一定是前面的_config.yml里面的# Deployment部分没有配置好。 注意红色部分也要有个空格！WTF! 四、世界宇宙超级无敌酷的域名合体 五、hexo常用语句整理12345$ hexo n = hexo new //新建$ hexo s = hexo server //开启$ hexo c = hexo clean //清缓存 $ hexo g = hexo generate //打包$ hexo d = hexo deploy //上传git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nothing]]></title>
      <url>%2F2017%2F03%2F30%2Fnothing%2F</url>
      <content type="text"><![CDATA[不想撸码的时候要看看电影看看书、看看那些美丽的地方、 书单：1.《React全栈》 作者：张轩 杨寒星 2.《JavaScript高级程序设计》 3.《JavaScript语言精粹》 4.《高性能JavaScript》 电影：1.《暗夜恐惧》 8个黑白简约风高智商小故事 2.《爆裂鼓手》 一定要戴着耳机看，感觉老师才是男主，演技爆表。 3.《立春》 https://www.zhihu.com/question/28882548/answer/42426812?utm_campaign=weekly192&amp;utm_source=weekly-digest&amp;utm_medium=email 旅行攻略：1.[绿野自助户外活动](www.lvye.org) 2.[穷游网:针对国外旅游的攻略论坛](www.go2eu.com)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Babel安装、编译、配置（cmd和phpstorm）]]></title>
      <url>%2F2017%2F03%2F27%2Fbabel%2F</url>
      <content type="text"><![CDATA[讲道理 这里我要找一张好看的图片（没写完啊没写完，不生气了再写） 开始Babel转码器工具：cmd、phpstorm10.0.3环境：Windows 10好多爹一样的浏览器不支持666的ES6啊！大Babel帮你ES6编译成ES5哦~省事儿~作用： ①让code支持es6 ②支持react的一些特性（eg:JSX） 安装环境12cnpm install babel-cli -gcnpm install babel-cli --save-dev 安装插件前面新建的es5.js和源文件es6.js是一毛一样的，毕竟还没有配置。 新建配置文件.babelrc1234&#123;"presets":[],"plugins":[]&#125; 安装预设1$ cnpm install --save-dev babel-preset-es2015 啊啊啊啊啊啊啊啊啊啊啊啊啊！！！！！答应我这一步千万不要用Terminal来装！！不要用Terminal来装！！不要用Terminal来装！！会炸啊会炸！！老老实实把这个项目关了去打开cmd！无响应了一个世纪、看到红色的这句话，省你一个小时时间！装完趁早吧，好气！也别轻易把node_modules给ignore，找个吃饭的时间弄，不然真当卡死。哦，还有气死！另外，如果phpstorm一直好卡一直indexing的话，可以在phpstorm.vmoptions里面，最后加上12-Dawt.usesystemAAFontSettings=lcd -Dawt.java2d.opengl=true 回归正题，在.babelrc文件里加上es2015的字段，在package.js加上对应字段。[.babelrc]1234&#123;"presets":["es2015"],"plugins":[]&#125; [package.js]123"babel": &#123; "presets": ["es2015"]&#125; 安装展开符插件1$ cnpm install babel-plugin-transform-object-rest-spread --save-dev 在.babelrc文件里加上transform-object-rest-spread的字段1234&#123;"presets":["es2015"],"plugins":["transform-object-rest-spread"]&#125; 三、编译es6文件夹底下新建es6.js123let number = [1,2,3];let double = number.map((n) =&gt; n*2);console.log(double); 如果出现红红黄黄的报错↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓File =&gt; settings =&gt; Languages =&gt; JavaScript =&gt; JavaScript language version 改为ECMAScript6 然后apply一下、 cmd编译$ babel es6.jscmd窗口的结果：123456789"use strict";/***Created by rawraw on 2017/3/27.var number = [1, 2, 3];var double2 = number.map(function (n) &#123; return n * 2;&#125;);console.log(double2); 手动编译先试一下安装的杂七杂八能不能运行起来 cmd文件 to 文件123$ babel es6/es6.js -o es5/es5.js//或者$ babel es6/es6.js --out-file es5/es5.js 文件夹 to 文件夹123$ babel es6 -d es5//或者$ babel es6 --out-dir es5 文件夹 to 文件123$ babel es6 -d es5//或者$ babel es6 --out-file es5/es5.js 直接运行es6 codebabel-node 通过phpstorm下面的terminal嗯，好，很完美。然后es5文件夹下es5.js的内容试这样子的[es5.js]123456"use strict";var number = [1, 2, 3];var double2 = number.map(function (n) &#123; return n * 2;&#125;);console.log(double2); 自动编译cmd监听123$ babel es6/es6.js -w -o es5/es5.js//或者$ babel es6/es6.js --watch --out-file es5/es5.js phpstorm添加事件监听这个时候，如果讲道理的话，自己会弹出来这个，那就很happy地点击add添加事件监听。 不讲道理的话，↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓File =&gt; settings =&gt; Tools =&gt; File Watchers =&gt; + =&gt; Babel名字随意取咯~如果这个时候apply,不设置编译后目标文件夹，默认是在该文件下生成一个js和js.mapTips:在babel监听配置之前，已存在的js文件，需要发生修改，才会触发自动编译。可以在中间回车几下。不过好丑好难过啊，还是整一个文件夹给它吧(自动编译定位在虚线内，也可以跳过啊，并没有影响) 好啦好啦，开始正式配置了、主要修改scope 和 output paths,就是编译前的文件夹和编译后的文件夹需要进行编译的文件夹：绿色框框的是哪个按钮啥意思自己去百度哈，总之就是选文件夹用的、如果这个时候apply,不设置编译后目标文件夹，默认是在该文件下生成一个js和js.map原：$FileNameWithoutExtension$-compiled.js:$FileNameWithoutExtension$-compiled.js.map改：$ProjectFileDir$\es5\$FileNameWithoutExtension$.js 并且，很稳地出现报错： 主要就是这句：Error: Couldn&#39;t find preset &quot;env&quot; relative to directory &quot;es5&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LESS环境部署]]></title>
      <url>%2F2017%2F03%2F24%2Fless%2F</url>
      <content type="text"><![CDATA[等等再发咯]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇test]]></title>
      <url>%2F2017%2F03%2F22%2Ftest1%2F</url>
      <content type="text"><![CDATA[1 + 1 = 11 ? nothing测试1测试2[reset.css]1body &#123; margin: 0; padding: 0; &#125; 一、一级标题//2、二级标题红的呢]]></content>
    </entry>

    
  
  
</search>
