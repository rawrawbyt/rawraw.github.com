<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rawraw</title>
  
  <subtitle>Change not delete ！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rawraw.info/"/>
  <updated>2019-05-20T04:32:24.409Z</updated>
  <id>http://rawraw.info/</id>
  
  <author>
    <name>rawraw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript要仔细学之三//基础</title>
    <link href="http://rawraw.info/2019-05-16-js03.html"/>
    <id>http://rawraw.info/2019-05-16-js03.html</id>
    <published>2019-05-16T09:02:57.000Z</published>
    <updated>2019-05-20T04:32:24.409Z</updated>
    
    <content type="html"><![CDATA[<p>基础</p><p><div align="center"><br><img src="/images/bg/0170.jpg" alt="“封面”"><br></div><br><a id="more"></a></p><h1 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h1><h4 id="JavaScript规定了几种语言类型"><a href="#JavaScript规定了几种语言类型" class="headerlink" title="JavaScript规定了几种语言类型"></a>JavaScript规定了几种语言类型</h4><p>6种基本类型:String、Number、Boolean、Symbol、Undefined、Null<br>1种复杂数据类型：object,Array<br><a href="http://www.mamicode.com/info-detail-2347949.html" target="_blank" rel="noopener">详细</a></p><h4 id="JavaScript对象的底层数据结构是什么"><a href="#JavaScript对象的底层数据结构是什么" class="headerlink" title="JavaScript对象的底层数据结构是什么"></a>JavaScript对象的底层数据结构是什么</h4><p><a href="https://www.cnblogs.com/full-stack-engineer/p/9684072.html" target="_blank" rel="noopener">参考</a><br><a href="https://zhuanlan.zhihu.com/p/26388217" target="_blank" rel="noopener">从Chrome源码看JS Array的实现</a></p><h4 id="Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"><a href="#Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol" class="headerlink" title="Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"></a>Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</h4><p><a href="https://juejin.im/post/5cd44bfbe51d453aa44ad6e4" target="_blank" rel="noopener">参考</a></p><h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0170.jpg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="JavaScript" scheme="http://rawraw.info/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>依赖包管理npm、yarn</title>
    <link href="http://rawraw.info/2019-05-16-yarn.html"/>
    <id>http://rawraw.info/2019-05-16-yarn.html</id>
    <published>2019-05-16T08:31:30.000Z</published>
    <updated>2019-05-20T04:29:52.727Z</updated>
    
    <content type="html"><![CDATA[<p>npm和yarn区别<br><a id="more"></a></p><h1 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h1><p>Yarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化；<br>Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。就像我们可以从官方文档了解那样，它的目的是解决这些团队使用 npm 面临的少数问题，即：</p><ul><li>安装的时候无法保证速度/一致性</li><li>安全问题，因为 npm 安装时允许运行代码</li></ul><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ul><li>yarn.lock 文件</li><li>并行安装<br>每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。</li><li>清晰的输出<br>npm 默认情况下非常冗余，例如使用 npm install 时它会递归列出所有安装的信息；而 Yarn 则一点也不冗余，当可以使用其它命令时，它适当的使用 emojis 表情来减少信息（Windows 除外）。</li></ul><h1 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h1><p>可阅读pnpm的作者Zoltan Kochan发表的<a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener">“为什么要用pnpm？”</a></p><ul><li>pnpm运行起来非常的快，超过了npm和yarn</li><li>pnpm采用了一种巧妙的方法，利用硬链接和符号链接来避免复制所有本地缓存源文件，这是yarn的最大的性能弱点之一</li><li>使用链接并不容易，会带来一堆问题需要考虑。</li><li>pnpm继承了yarn的所有优点，包括离线模式和确定性安装</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm和yarn区别&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="npm" scheme="http://rawraw.info/tags/npm/"/>
    
      <category term="yarn" scheme="http://rawraw.info/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>nginx正向代理和反向代理</title>
    <link href="http://rawraw.info/2019-05-16-nginx.html"/>
    <id>http://rawraw.info/2019-05-16-nginx.html</id>
    <published>2019-05-16T07:01:47.000Z</published>
    <updated>2019-05-20T04:31:02.147Z</updated>
    
    <content type="html"><![CDATA[<p>nginx正向代理和反向代理<br><a id="more"></a></p><p>正向代理的代理对象是客户端,反向代理的代理对象是服务端。</p><p><a href="https://www.cnblogs.com/crazylqy/p/7150580.html" target="_blank" rel="noopener">参考</a></p><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向代理:客户端 &lt;一&gt; 代理 一&gt;服务端</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>反向代理:客户端 一&gt;代理 &lt;一&gt; 服务端</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx正向代理和反向代理&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="nginx" scheme="http://rawraw.info/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>跨浏览器开发</title>
    <link href="http://rawraw.info/2019-05-16-browser.html"/>
    <id>http://rawraw.info/2019-05-16-browser.html</id>
    <published>2019-05-16T06:09:30.000Z</published>
    <updated>2019-05-16T08:44:27.542Z</updated>
    
    <content type="html"><![CDATA[<p>重点：要脱离前端类库的跨浏览器开发</p><a id="more"></a><ul><li>css reset</li><li>Polyfill抚平不同浏览器之间对js实现的差异。</li></ul><p>Selenium是前端工具 测试<br>IETester让您查看 不同IE版本的页面<br>Browsershots让你看看 不同平台上的页面<br>Google让您搜索已知且模糊的IE变态<br>IE 6 No More为您节省了很多麻烦，而不用担心IE 6这个名字的史前垃圾。<br>YUI Graded Browser Support - 确保您知道要关注哪些浏览器<br>jQquery跨浏览器javascript库<br>YUI 3: Reset CSS重置您的CSS(链接包含有用的信息以及CSS)<br>9 Most Common IE Bugs and How to Fix Them非常有用的提示，如何通过先解决常见问题来获得最大的收益。<br>Cross browser development包含许多有关跨浏览器开发的有用教程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重点：要脱离前端类库的跨浏览器开发&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="browser" scheme="http://rawraw.info/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>跨终端开发</title>
    <link href="http://rawraw.info/2019-05-16-client.html"/>
    <id>http://rawraw.info/2019-05-16-client.html</id>
    <published>2019-05-16T06:07:49.000Z</published>
    <updated>2019-05-16T06:08:49.362Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flutter&lt;/p&gt;

      
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="跨终端" scheme="http://rawraw.info/tags/%E8%B7%A8%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>OSI七层模型与TCP/IP四层模型</title>
    <link href="http://rawraw.info/2019-05-16-osi.html"/>
    <id>http://rawraw.info/2019-05-16-osi.html</id>
    <published>2019-05-16T02:58:23.000Z</published>
    <updated>2019-05-16T03:02:47.692Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jingyan.baidu.com/article/00a07f387b7e0682d028dce2.html" target="_blank" rel="noopener">OSI七层模型与TCP/IP四层模型参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/00a07f387b7e0682d028dce2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OSI七层模型与TCP/IP四层模型参考&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="OSI" scheme="http://rawraw.info/tags/OSI/"/>
    
      <category term="TCP" scheme="http://rawraw.info/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>get/post请求区别</title>
    <link href="http://rawraw.info/2019-05-16-getpost.html"/>
    <id>http://rawraw.info/2019-05-16-getpost.html</id>
    <published>2019-05-16T02:24:38.000Z</published>
    <updated>2019-05-16T03:14:18.908Z</updated>
    
    <content type="html"><![CDATA[<p>GET和POST本质上两者没有任何区别，是HTTP协议中的两种发送请求的方法，底层实现都是基于TCP/IP协议。</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>GET和POST是HTTP协议中的两种发送请求的方法。<br>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。<br>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。<br>GET和POST能做的事情是一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。<br>上述的所谓区别，只是浏览器厂家根据约定，做得限制而已。<br>HTTP请求，最初设定了八种方法。这八种方法本质上没有任何区别。只是让请求，更加有语义而已。</p><ul><li>OPTIONS 返回服务器所支持的请求方法</li><li>GET 向服务器获取指定资源</li><li>HEAD 与GET一致，只不过响应体不返回，只返回响应头</li><li>POST 向服务器提交数据，数据放在请求体里</li><li>PUT 与POST相似，只是具有幂等特性，一般用于更新</li><li>DELETE 删除服务器指定资源</li><li>TRACE 回显服务器端收到的请求，测试的时候会用到这个</li><li>CONNECT 预留，暂无使用</li></ul><p>万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p><p>在万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p><p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 </p><h1 id="w3school标准答案"><a href="#w3school标准答案" class="headerlink" title="w3school标准答案"></a>w3school标准答案</h1><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。（所以中文需要URL编码）</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><h2 id="重大区别"><a href="#重大区别" class="headerlink" title="重大区别"></a>重大区别</h2><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><pre><code>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</code></pre><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li>GET与POST都有自己的语义，不能随便混用。</li><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GET和POST本质上两者没有任何区别，是HTTP协议中的两种发送请求的方法，底层实现都是基于TCP/IP协议。&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="http" scheme="http://rawraw.info/tags/http/"/>
    
      <category term="get" scheme="http://rawraw.info/tags/get/"/>
    
      <category term="post" scheme="http://rawraw.info/tags/post/"/>
    
  </entry>
  
  <entry>
    <title>跨域的几种方式</title>
    <link href="http://rawraw.info/2019-05-15-proxy.html"/>
    <id>http://rawraw.info/2019-05-15-proxy.html</id>
    <published>2019-05-15T07:07:42.000Z</published>
    <updated>2019-05-15T09:08:49.574Z</updated>
    
    <content type="html"><![CDATA[<p>跨域的几种方式</p><p><div align="center"><br><img src="/images/bg/0172.jpg" alt="“封面”"><br></div><br><a id="more"></a></p><h1 id="跨域是什么"><a href="#跨域是什么" class="headerlink" title="跨域是什么"></a>跨域是什么</h1><p>一个完整的地址 = 协议 + 子域名 + 主域名 + 端口号 + 请求资源地址</p><p>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。<br>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。</p><blockquote><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</p></blockquote><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。它的存在可以保护用户隐私信息，防止身份伪造等(读取Cookie)。</p><h4 id="同源策略限制内容有："><a href="#同源策略限制内容有：" class="headerlink" title="同源策略限制内容有："></a>同源策略限制内容有：</h4><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求不能发送</li></ul><h4 id="允许跨域加载资源的三个标签"><a href="#允许跨域加载资源的三个标签" class="headerlink" title="允许跨域加载资源的三个标签"></a>允许跨域加载资源的三个标签</h4><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>详情见proxy</p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//前端代码：</span><br><span class="line">&lt;div&gt;user input：&lt;input type = &quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var socket = io(&apos;http://www.domain2.com:8080&apos;);</span><br><span class="line">// 连接成功处理</span><br><span class="line">socket.on(&apos;connect&apos;,function()&#123;</span><br><span class="line">    // 监听服务端消息</span><br><span class="line">    socket.on(&apos;message&apos;,function(msg)&#123;</span><br><span class="line">        console.log(&apos;data from server: ---&gt; &apos;+msg</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line">// 监听服务端关闭</span><br><span class="line">    socket.on(&apos;disconnect&apos;,function()&#123;</span><br><span class="line">        console.log(&apos;Server socket has closed.&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementsByTagName(&apos;input&apos;)[0].onblur = function()&#123;</span><br><span class="line">    socket.send(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Nodejs socket后台：</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var socket  = require(&apos;socket.io&apos;);</span><br><span class="line">// 启http服务</span><br><span class="line">var server = http.createServer(function(req,res)&#123;</span><br><span class="line">    res.writeHead(200,&#123;</span><br><span class="line">        &apos;Content-type&apos;: &apos;text/html&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br><span class="line">// 监听socket连接</span><br><span class="line">socket.listen(server).on(&apos;connection&apos;,function(client)&#123;</span><br><span class="line">// 接收信息</span><br><span class="line">    client.on(&apos;message&apos;,function(msg) &#123;</span><br><span class="line">    client.send(&apos;hello：&apos; + msg);</span><br><span class="line">    console.log(&apos;data from client: ---&gt; &apos; + msg);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">// 断开处理</span><br><span class="line">    client.on(&apos;disconnect&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;Client socket has closed.&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h2><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><p>CORS要求浏览器(&gt;IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。<br>优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。<br>服务端：<br><code>header(&quot;Access-Control-Allow-Origin:*&quot;);</code><br><code>header(&quot;Access-Control-Allow-Methods:POST,GET&quot;);</code></p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>原理：利用 <code>&lt;script&gt;</code> 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</p><p>JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）。</p><p>JSONP优点是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性。</p><ul><li>声明一个回调函数，其函数名(如fn)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该函数名,通过问号传参。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type =&quot;text/javascript&quot;&gt;</span><br><span class="line">function fn(data)&#123;</span><br><span class="line">    alert(data.msg);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type = &quot;text/javascript&quot; src=&quot;http://test.com/jsonServerResponse?jsonp=fn&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和 window.open 方法打开的窗口，它们与父窗口无法通信。HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。</p><p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为 *，表示不限制域名，向所有窗口发送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//发送信息页面 http://localhost:63342/index.html</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;跨域请求&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;iframe src=&quot;http://localhost:3000/users/reg&quot; id=&quot;frm&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value =&quot;OK&quot; onclick=&quot;run()&quot;&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function run()&#123;</span><br><span class="line">    var frm = document.getElementById(&quot;frm&quot;);</span><br><span class="line">    frm.contentWindow.postMessage(&quot;跨域请求信息&quot;,&quot;http://localhost:3000&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//接收信息页面 http://localhost:3000/message.html</span><br><span class="line"> window.addEventListener(&quot;message&quot;,function(e)&#123;//通过监听message事件，可以监听对方发送的消息。</span><br><span class="line">  console.log(e.data);</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域的几种方式&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0172.jpg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="html" scheme="http://rawraw.info/tags/html/"/>
    
      <category term="跨域" scheme="http://rawraw.info/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>这是一个键盘</title>
    <link href="http://rawraw.info/2019-04-29-keyboard.html"/>
    <id>http://rawraw.info/2019-04-29-keyboard.html</id>
    <published>2019-04-29T10:16:21.000Z</published>
    <updated>2019-04-30T05:43:15.253Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="/images/bg/0175.jpg" alt="“封面”"><br></div><a id="more"></a><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="result"><a href="#result" class="headerlink" title="result"></a>result</h2>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0175.jpg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="js" scheme="http://rawraw.info/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>（不记得转自哪里了）如何避免自己写的代码成为别人眼中的一坨屎！</title>
    <link href="http://rawraw.info/2019-04-18-shit.html"/>
    <id>http://rawraw.info/2019-04-18-shit.html</id>
    <published>2019-04-18T06:55:26.000Z</published>
    <updated>2019-04-30T05:47:36.955Z</updated>
    
    <content type="html"><![CDATA[<p>应该是出自某本书还是什么地方的。<br>相信每一个优秀的工程师都有一颗追求卓越代码的心，</p><blockquote><p>Any fool can write code that a computer can understand. Good programmers write code that humans can understand. 普通的工程师堆砌代码，优秀的工程师优雅代码，卓越的工程师简化代码。</p></blockquote><div align="center"><br><img src="/images/bg/0158.jpeg" alt="“封面”"><br></div><a id="more"></a><p>首先，在苍蝇眼里，一切都是屎。</p><h1 id="一、注释"><a href="#一、注释" class="headerlink" title="一、注释"></a>一、注释</h1><ul><li>不要给不好的名字加注释，一个好的名字比好的注释更重要；</li><li>不要“拐杖注释”，好代码 &gt; 坏代码 + 好注释；</li><li>一定要给常量加注释；</li><li>团队统一定义标记：<br>  <em>TODO  待处理的问题；  </em>FIXME  已知有问题的代码；<br>  *HACK 不得不采用的粗糙的解决方案；</li><li>在注释中用精心挑选的输入输出例子进行说明；</li><li>注释应该声明代码的高层次意图，而非明显的细节；</li><li>不要在代码中加入代码的著作信息，git可以干的事情不要交给代码；</li><li>源代码中的html注释是一种厌物, 增加阅读难度；</li><li>注释一定要描述离它最近的代码；</li><li>注释一定要与代码对应；</li><li>公共api需要添加注释，其它代码谨慎使用注释；</li><li>典型的烂注释：<br>  不恰当的信息；废弃的注释；冗余注释；糟糕的注释；注释掉的代码；</li><li>唯一真正好的注释是你想办法不去写的注释：<br>  <em>不要有循规式注释，比如setter/getter注释；  </em>不要添加日志式注释，比如修改时间等信息（git可以做的事情）；<br>  <em>注释一定是表达代码之外的东西，代码可以包含的内容，注释中一定不要出现；  </em>如果有必要注释，请注释意图（why），而不要去注释实现（how)，大家都会看代码；<br>  *适当添加警示注释；</li></ul><h1 id="二、命名"><a href="#二、命名" class="headerlink" title="二、命名"></a>二、命名</h1><ul><li>尽可能使用标准命名方法，比如设计模式，通用学术名词等；</li><li>命名要找更有表现力的词：<br>  <em>使用更专业的词，比如不用get而使用fetch或者download；  </em>避免空泛的名字，像tmp；<br>  <em>使用具体的名字来细致的描述事物；  </em>给变量名带上重要的细节，比如加上单位ms等；<br>  <em>为作用域大的名字采用更长的名字，作用域小的使用短名字；  </em>变量类型为布尔值表达加上is，has，can，should这样的词会更明确；</li><li>变量名称长短应该与其作用域对应；</li><li>别害怕长名称，长而具有描述性的名称比短而令人费解的名称好；</li><li>函数名称应该说明副作用，名称应该表达函数，变量或类的一切信息，请不要掩盖副作用，比如CreateAndReturnXXX；</li></ul><h1 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h1><ul><li>函数不应该有100行那么长，20行封顶最好：<br>  <em>if else while等控制语句其中代码块应该只有一行，也就是一个函数调用语句；  </em>函数的锁进层次不应该多于两层；<br>  *一个函数只做一件事，一个函数不应该能抽象出另外一个函数；</li><li>某个公共函数调用的私有函数紧随其后；</li><li>最理想的参数是零参数，最长不要超过三个入参，尽量不要输出参数：<ul><li>如果函数传入三个及以上参数最好将其抽象为类；</li><li>标识参数十分丑陋，向函数传入布尔值用于区分不同业务的做法很丑陋，应该拆分为多个函数；</li></ul></li><li>别返回null值，抛出异常或者返回特殊对象，尽量避免NPE；</li><li>别传入null值；</li></ul><h1 id="四、异常与错误"><a href="#四、异常与错误" class="headerlink" title="四、异常与错误"></a>四、异常与错误</h1><ul><li>抽离try catch包含的代码块，其中代码块抽象为一个函数；</li><li>抛出的每个异常，都应当提供足够的环境说明，已便判断错误的来源与处所；</li><li>不要将系统错误归咎于偶然事件；</li></ul><h1 id="五、并发"><a href="#五、并发" class="headerlink" title="五、并发"></a>五、并发</h1><ul><li>分离并发相关代码与其它代码；</li><li>严格限制对可能被共享的数据的访问；</li><li>避免使用一个共享对象的多个同步方法；</li><li>保持同步区域微小，尽可能少设计临界区；</li></ul><h1 id="六、单元测试"><a href="#六、单元测试" class="headerlink" title="六、单元测试"></a>六、单元测试</h1><ul><li>不要怕单元测试的方法名字太长或者繁琐，测试函数的名称就像注释；</li><li>不要追求太高的测试覆盖率，测试代码前面90%通常比后面10%花的时间少；</li><li>使用最简单的并且能够完整运用代码的测试输入；；</li><li>给测试函数取一个完整性的描述性名字，比如  Test _；</li><li>测试代码与生产代码一样重要；</li><li>如果测试代码不能保证整洁，你就会很快失去他们；</li><li>每个测试一个断言，单个测试中断言数量应该最小化也就是一个断言；</li><li>FIRST原则：<ul><li>快速 Fast；</li><li>独立 Independent  测试应该相互独立；</li><li>可重复 Repeatable  测试应当在任何环境中重复通过；</li><li>自足验证 Self-Validating   测试应该有布尔值输出；</li><li>及时  Timely   最好的方式是TDD；</li></ul></li></ul><h1 id="七、代码结构"><a href="#七、代码结构" class="headerlink" title="七、代码结构"></a>七、代码结构</h1><ul><li>代码行长度控制在100-120个字符；</li><li>可能用大多数为200行，最长500行的单个文件构造出色的系统；</li><li>关系密切的代码应该相互靠近：<ul><li>变量声明应该靠近其使用位置；</li><li>若某个函数调用了另外一个，应该把他们放在一起，而且调用者应该放在被调用者上面；</li><li>自上向下展示函数调用依赖顺序；</li></ul></li><li>应该把解释条件意图的函数抽离出来，尽可能将条件表达为肯定形式；</li><li>不要继承常量，比如接口中定义常量，不要使用继承欺骗编程语言的作用范围规则；</li><li>模块不应了解它所操作对象的内部情况；</li><li>DTO（Data Transfer Objects）是一个只有公共变量没有函数的类；</li><li>对象暴露行为，隐藏数据；</li><li>不要使用“尤达表示法” 如 if(null == obj)，现代编译器对if(obj = null)这样的代码会给出警告；</li><li>一般情况使用if else，简单语句使用三目运算符；</li><li>通常来讲提早返回可以减少嵌套并让代码整洁；</li></ul><h1 id="八、设计"><a href="#八、设计" class="headerlink" title="八、设计"></a>八、设计</h1><ul><li>类应该足够短小：<ul><li>类应该满足单一权责原则（SRP），类和模块只有一个修改理由；</li><li>类应该只有少量的实体变量；</li><li>类应该遵循依赖倒置原则 DIP（Dependency Inversion Principle），类应该依赖于抽象而不是依赖于具体细节；</li><li>类中的方法越少越好，函数知道的变量越少越好，类拥有的实体变量越少越好；</li></ul></li><li>通过减少变量的数量和让他们尽量“轻量级”来让代码更有可读性：<ul><li>减少变量；</li><li>缩小变量的作用域；</li><li>只写一次的变量更好，如常量；</li></ul></li><li>最好读的代码就是没有代码：<ul><li>从项目中消除不必要的功能，不要过度设计；</li><li>从新考虑需求，解决版本最简单的问题，只要能完成工作就行；</li><li>经常性地通读标准库的整个API，保持对他们的熟悉程度；</li></ul></li><li>简单设计：<ul><li>运行所有测试；</li><li>不可重复；</li><li>表达了程序员的意图；</li><li>尽可能减少类和方法的数量；</li><li>以上规则按重要程度排列；</li></ul></li><li>无论是设计系统或者单独模块，别忘了使用大概可工作的最简单方案；</li><li>整洁的代码只提供一种而非多种做一件事的途径，他只有尽量少的依赖。明确定义并提供尽量少的API；</li><li>减少重复代码，提高表达力，提早构建，简单抽象；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应该是出自某本书还是什么地方的。&lt;br&gt;相信每一个优秀的工程师都有一颗追求卓越代码的心，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Any fool can write code that a computer can understand. Good programmers write code that humans can understand. 普通的工程师堆砌代码，优秀的工程师优雅代码，卓越的工程师简化代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0158.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Rule" scheme="http://rawraw.info/categories/Rule/"/>
    
    
      <category term="rule" scheme="http://rawraw.info/tags/rule/"/>
    
  </entry>
  
  <entry>
    <title>less=&gt;vue中引入</title>
    <link href="http://rawraw.info/2019-04-18-less-vue.html"/>
    <id>http://rawraw.info/2019-04-18-less-vue.html</id>
    <published>2019-04-18T06:45:19.000Z</published>
    <updated>2019-04-30T05:43:36.136Z</updated>
    
    <content type="html"><![CDATA[<p>在vue中引入less</p><div align="center"><br><img src="/images/bg/0160.jpeg" alt="“封面”"><br></div><a id="more"></a><h1 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h1><p><code>npm install less less-loader --save</code><br>or<br><code>yarn add less less-loader --save</code></p><h1 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h1><p>修改webpack.config.js文件，配置loader加载依赖，让其支持外部的less,在原来的代码上添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.less$/,</span><br><span class="line">    loader: &quot;style-loader!css-loader!less-loader&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    或者</span><br><span class="line">    @import &apos;./index.less&apos;; //引入全局less文件</span><br><span class="line">    ）。</span><br><span class="line"></span><br><span class="line">webpack.base.conf.js</span><br><span class="line">    &#123;  </span><br><span class="line">        test: /\.scss$/,   </span><br><span class="line">        loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;,&quot;style-loader!css-loader!less-loader&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        test:/\.less$/,</span><br><span class="line">        loader:&apos;less-loader&apos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在vue中引入less&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0160.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="vue" scheme="http://rawraw.info/tags/vue/"/>
    
      <category term="less" scheme="http://rawraw.info/tags/less/"/>
    
  </entry>
  
  <entry>
    <title>gulp配置</title>
    <link href="http://rawraw.info/2019-04-18-gulp.html"/>
    <id>http://rawraw.info/2019-04-18-gulp.html</id>
    <published>2019-04-18T06:22:21.000Z</published>
    <updated>2019-04-30T05:41:20.092Z</updated>
    
    <content type="html"><![CDATA[<p>gulp配置</p><div align="center"><br><img src="/images/bg/0164.jpg" alt="“封面”"><br></div><a id="more"></a><h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;connect&apos;, function () &#123;</span><br><span class="line">    connect.server(&#123;</span><br><span class="line">        port: 3006,</span><br><span class="line">        livereload: true,</span><br><span class="line">        host: &apos;0.0.0.0&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h2><h3 id="if-eq"><a href="#if-eq" class="headerlink" title="if_eq"></a>if_eq</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hbs.handlebars.registerHelper(&apos;if_eq&apos;,function(v1,v2,name)&#123;</span><br><span class="line">    if(v1 == v2)&#123;</span><br><span class="line">        return name.fn(this)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return name.inverse(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gulp配置&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0164.jpg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="gulp" scheme="http://rawraw.info/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>mvc/mvvm</title>
    <link href="http://rawraw.info/2019-03-16-mvc.html"/>
    <id>http://rawraw.info/2019-03-16-mvc.html</id>
    <published>2019-03-16T06:24:55.000Z</published>
    <updated>2019-05-16T06:41:56.224Z</updated>
    
    <content type="html"><![CDATA[<p>mvc/mvvm区别</p><a id="more"></a><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>Model View Controller</p><p>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。<br>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。<br>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p><p>MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来</p><p>众所周知，MVC 是开发客户端最经典的设计模式，iOS 开发也不例外，但是 MVC 有让人无法忽视的严重问题。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>Model和View永远不能相互通信，只能通过Controller传递。</li><li>Controller可以直接与Model对话（读写调用Model），Model通过Notification和KVO机制与Controller间接通信。</li><li>Controller可以直接与View对话，通过outlet,直接操作View,outlet直接对应到View中的控件,View通过action向Controller报告事件的发生(如用户Touch我了)。Controller是View的直接数据源（数据很可能是Controller从Model中取得并经过加工了）。Controller是View的代理（delegate),以同步View与Controller。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>View的可扩展性相当低。<br>在通常的开发中，除了简单的 Model、View 以外的所有部分都被放在了 Controller 里面。Controller 负责显示界面、响应用户的操作、网络请求以及与 Model 交互。这就导致了 Controller：</p><ul><li>逻辑复杂，难以维护；</li><li>和 View 紧耦合，无法测试；</li></ul><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>Model View ViewModel</p><p>Controller的存在感被完全的降低了。<br>本质上是一个精心优化的 MVC 架构；<br>既然 View 和 Controller 是一对好基友，在 MVVM 里面，干脆把它们当做 View。<br>现在将原来 Controller 的部分职责拆分出来由 View Model 承担，主要包括：</p><ul><li>校验用户输入；</li><li>网络请求；</li><li>展示层的逻辑，比如格式化字符串；</li><li>其他不能放入 Model，与 View 无关的逻辑；</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>MVVM 兼容 MVC，可以先创建一个简单的 View Model，再慢慢迁移。</li><li>MVVM 使得 app 更容易测试，因为 View Model 部分不涉及 UI。</li></ul><p>MVVM 最好配合 binding 机制，Model 的变化需要同步到 View Model，View Model 的变化也需要同步到 View</p><p><a href="https://www.jianshu.com/p/b0aab1ffad93" target="_blank" rel="noopener">发展史</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mvc/mvvm区别&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="mvc" scheme="http://rawraw.info/tags/mvc/"/>
    
      <category term="mvvm" scheme="http://rawraw.info/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>在table中margin 失效</title>
    <link href="http://rawraw.info/2018-05-20-tem.html"/>
    <id>http://rawraw.info/2018-05-20-tem.html</id>
    <published>2018-05-20T06:38:47.000Z</published>
    <updated>2019-04-30T05:48:43.137Z</updated>
    
    <content type="html"><![CDATA[<p>想写个某几行<code>tr</code>滑动的动画，发现margin在table里没有用，那我总不能特地搞个定位来弄这个动画吧。气。</p><p><div align="center"><br><img src="/images/bg/0131.jpeg" alt="“封面”"><br></div><br><a id="more"></a></p><p>当<code>display：table</code>,<code>margin</code>会不起作用</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p><code>border-spacing</code><br>设置单元格td的边在横向和纵向上的间距。<br>指定一个length值时，这个值将作用于横向和纵向上的间距;<br>指定两个length值时，第一个将作用于横向间距，第二个值将作用于纵向间距。<br><code>table{border-spacing:5px 10px;}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123;</span><br><span class="line">    <span class="attribute">border-collapse</span>:separate;</span><br><span class="line">    <span class="attribute">border-spacing</span>: -<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想写个某几行&lt;code&gt;tr&lt;/code&gt;滑动的动画，发现margin在table里没有用，那我总不能特地搞个定位来弄这个动画吧。气。&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0131.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="css" scheme="http://rawraw.info/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>vue集合</title>
    <link href="http://rawraw.info/2018-05-20-vue.html"/>
    <id>http://rawraw.info/2018-05-20-vue.html</id>
    <published>2018-05-20T06:38:18.000Z</published>
    <updated>2019-04-30T05:49:22.243Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="/images/bg/0163.jpeg" alt="“封面”"><br></div><a id="more"></a><h1 id="bugs"><a href="#bugs" class="headerlink" title="bugs"></a>bugs</h1><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><font color="red">[Vue warn]: Error in render: “TypeError: _self.$scopedSlots.default is not a function”</font><blockquote><p>究其原因，是因为表格是element-ui通过循环产生的，而vue在dom重新渲染时有一个性能优化机制，就是相同dom会被复用，这就是问题所在，所以，通过key去标识一下当前行是唯一的，不许复用，就行了。</p></blockquote><p>方案：添加 <font color="red">:key=”Math.random()”</font></p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0163.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="vue" scheme="http://rawraw.info/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>npm常用命令</title>
    <link href="http://rawraw.info/2018-03-27-npm.html"/>
    <id>http://rawraw.info/2018-03-27-npm.html</id>
    <published>2018-03-27T14:08:37.000Z</published>
    <updated>2019-05-20T04:29:21.522Z</updated>
    
    <content type="html"><![CDATA[<p>npm常用命令以及npm包发布</p><a id="more"></a><h1 id="安装升级"><a href="#安装升级" class="headerlink" title="安装升级"></a>安装升级</h1><p>安装node以后自动会安装NPM。</p><h2 id="淘宝镜像"><a href="#淘宝镜像" class="headerlink" title="淘宝镜像"></a>淘宝镜像</h2><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p><code>$ npm install -g npm</code></p><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p><code>$ npm install &lt;pkg&gt;</code> 或者 <code>$ npm install &lt;pkg&gt;@&lt;version&gt;</code></p><h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><p><code>$ npm uninstall &lt;pkg&gt;</code> 或者  <code>$ npm uninstall &lt;pkg&gt;@[&lt;version&gt;]</code></p><h2 id="查看当前项目下的包列表"><a href="#查看当前项目下的包列表" class="headerlink" title="查看当前项目下的包列表"></a>查看当前项目下的包列表</h2><p><code>$ npm ls</code></p><p>#查看全局包列表<br><code>$ npm ls －g</code></p><p>#清理缓存<br><code>$ npm cache clean</code></p><p>#显示包的package.json信息,后面可以跟属性名称。<br>e.g.：<code>$ npm view &lt;pkg&gt; versions</code>  其中versions是<code>package.json</code>的<code>versions</code>属性<br><code>$ npm view &lt;pkg&gt; [attribute]</code></p><h1 id="发布自己的npm包"><a href="#发布自己的npm包" class="headerlink" title="发布自己的npm包"></a>发布自己的npm包</h1><h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><p>第一次：<br><code>$ npm adduser</code><br>输入password的时候会自动隐藏，管自己输就好了<br>然后邮箱一直enter不了，一直报e400的错。然后想到之前装的淘宝镜像。然后就用<code>cnpm</code>就完全o**k！！<br>所以 所有的命令行 自己自动都改c吧，懒得一个个改了。<br>not 第一次：<br><code>$ npm login</code></p><h3 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h3><p><code>$ npm whoami</code></p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><code>$ npm init</code><br>动次打次 怼怼怼<br><code>$ npm publish</code><br><code>$ npm publish &lt;pkg&gt;@&lt;version&gt;</code></p><h3 id="报错集合"><a href="#报错集合" class="headerlink" title="报错集合"></a>报错集合</h3><p><code>ERR 403</code>:包名字重了<br><code>npm please try running this command again as root</code>：未登录</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><code>$ npm publish &lt;pkg&gt;@&lt;version&gt;</code></p><h3 id="快速升级方法"><a href="#快速升级方法" class="headerlink" title="快速升级方法"></a>快速升级方法</h3><h4 id="小版本号升级一个版本"><a href="#小版本号升级一个版本" class="headerlink" title="小版本号升级一个版本"></a>小版本号升级一个版本</h4><p><code>$ npm version patch</code></p><h4 id="中版号升级一个版本"><a href="#中版号升级一个版本" class="headerlink" title="中版号升级一个版本"></a>中版号升级一个版本</h4><p><code>$ npm version minor</code></p><h4 id="大版本号升级一个版本"><a href="#大版本号升级一个版本" class="headerlink" title="大版本号升级一个版本"></a>大版本号升级一个版本</h4><p><code>$ npm version major</code><br>npm社区版本号规则采用的是semver(语义化版本)，主要规则如下：<br>版本格式：主版号.次版号.修订号，版号递增规则如下：<br>    主版号：当你做了不相容的 API 修改，<br>    次版号：当你做了向下相容的功能性新增，<br>    修订号：当你做了向下相容的问题修正。<br>    先行版号及版本编译资讯可以加到「主版号.次版号.修订号」的后面，作为延伸。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>不能删除整个包，只能某个版本<br><code>$ npm unpublish &lt;pkg&gt;[@&lt;version&gt;]</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm常用命令以及npm包发布&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="npm" scheme="http://rawraw.info/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>animation整理</title>
    <link href="http://rawraw.info/2018-03-27-animation.html"/>
    <id>http://rawraw.info/2018-03-27-animation.html</id>
    <published>2018-03-27T11:32:40.000Z</published>
    <updated>2019-04-30T05:37:04.994Z</updated>
    
    <content type="html"><![CDATA[<p>清电脑翻出一堆以前做的demo。</p><p><div align="center"><br><img src="/images/bg/0061.jpeg" alt="“封面”"><br></div><br><a id="more"></a></p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p><a href="demos/nav/navText.html">导航栏</a></p><h1 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h1><p><a href="demos/cloud/cloud.html">云墙</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;清电脑翻出一堆以前做的demo。&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0061.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Frontend-work" scheme="http://rawraw.info/categories/Frontend-work/"/>
    
    
      <category term="css" scheme="http://rawraw.info/tags/css/"/>
    
      <category term="animation" scheme="http://rawraw.info/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>暂放</title>
    <link href="http://rawraw.info/2018-03-23-temporay.html"/>
    <id>http://rawraw.info/2018-03-23-temporay.html</id>
    <published>2018-03-23T05:28:50.000Z</published>
    <updated>2019-04-30T05:48:52.652Z</updated>
    
    <content type="html"><![CDATA[<p>偶尔翻到以前的笔记，先都堆在这放放，晚点整理；</p><a id="more"></a><h3 id="20160710："><a href="#20160710：" class="headerlink" title="20160710："></a>20160710：</h3><p>1.angular 对应的路由路径/回调不能为空</p><h3 id="20160817："><a href="#20160817：" class="headerlink" title="20160817："></a>20160817：</h3><p>1.iphone4.5 偶尔不支持vh /vw的！！！（vh用，反正要写媒体查询）</p><h3 id="20160810："><a href="#20160810：" class="headerlink" title="20160810："></a>20160810：</h3><p>自动换行 word-break:break-all和word-wrap:break-word</p><p><a href="http://www.oschina.net/translate/comparing-the-top-frameworks-for-building-hybrid-mobile-apps-1" target="_blank" rel="noopener">构建混合移动应用的流行框架优缺点对比</a></p><h1 id="Angular中ng-view-和ui-view区别"><a href="#Angular中ng-view-和ui-view区别" class="headerlink" title="Angular中ng-view 和ui-view区别"></a>Angular中ng-view 和ui-view区别</h1><p>ui-router是angular-ui下的一个模块angular-ui，可以嵌套。<br>ng-view不可以嵌套</p><h1 id="Keypress-keydown-keyup-区别"><a href="#Keypress-keydown-keyup-区别" class="headerlink" title="Keypress keydown keyup 区别"></a>Keypress keydown keyup 区别</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶尔翻到以前的笔记，先都堆在这放放，晚点整理；&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="杂" scheme="http://rawraw.info/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>移动端兼容性整理以及优化</title>
    <link href="http://rawraw.info/2018-03-23-compatibility.html"/>
    <id>http://rawraw.info/2018-03-23-compatibility.html</id>
    <published>2018-03-23T05:28:21.000Z</published>
    <updated>2019-04-30T05:39:51.118Z</updated>
    
    <content type="html"><![CDATA[<p>移动端兼容性整理<br><a id="more"></a></p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>Modernizr：兼容CSS3、HTML5新特性</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h3 id="contenteditable元素只能输入纯文本"><a href="#contenteditable元素只能输入纯文本" class="headerlink" title="contenteditable元素只能输入纯文本"></a>contenteditable元素只能输入纯文本</h3><p>-webkit-user-modify: read-only|read-write|read-write-plaintext-only</p><h3 id="IE6-8和FF3-浏览器不支持”-nth-child”选择器"><a href="#IE6-8和FF3-浏览器不支持”-nth-child”选择器" class="headerlink" title="IE6-8和FF3-浏览器不支持”:nth-child”选择器"></a>IE6-8和FF3-浏览器不支持”:nth-child”选择器</h3><p>:nth-child(2n),:nth-child(even)<br>:nth-child(n+5)这个选择器是选择从第五个元素开始选择<br>:nth-child(4n+1)这种方法是实现隔几选一的效果，比如我们这里是隔三选一<br>::selection<br>user-select:none</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h3 id="增加该属性，可以增加弹性（在绝对定位的时候会用到）"><a href="#增加该属性，可以增加弹性（在绝对定位的时候会用到）" class="headerlink" title="增加该属性，可以增加弹性（在绝对定位的时候会用到）"></a>增加该属性，可以增加弹性（在绝对定位的时候会用到）</h3><p>-webkit-overflow-scrolling: touch;</p><h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><p>开始中文输入时会触发compositionstart事件<br>选词结束后会触发compositionend事件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端兼容性整理&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="兼容" scheme="http://rawraw.info/tags/%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>css基础小结</title>
    <link href="http://rawraw.info/2018-03-19-cssbase.html"/>
    <id>http://rawraw.info/2018-03-19-cssbase.html</id>
    <published>2018-03-19T12:52:43.000Z</published>
    <updated>2019-04-30T05:40:20.415Z</updated>
    
    <content type="html"><![CDATA[<p>css tips~</p><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><blockquote><p>不同浏览器的一些标签的默认值不同</p></blockquote><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>默认为box-sizing是content-box；<br>标准盒子模型（content-box）：宽度=内容的宽度（content）+ border + padding + margin<br>低版本IE盒子模型（border-box）：宽度=内容宽度（content+border+padding）+ margin</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>id、类、标签选择器、相邻选择器、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器</p><h2 id="优先级算法"><a href="#优先级算法" class="headerlink" title="优先级算法"></a>优先级算法</h2><p>元素选择符： 1<br>class选择符： 10<br>id选择符：100<br>元素标签：1000<br>!important</p><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>盒子属性不可继承<br>可继承的属性：font-size, font-family, color<br>不可继承的样式：border, padding, margin, width, height</p><h2 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h2><p>自己去翻那篇居中的<br>有空来放个链接</p><h2 id="a的hover顺序"><a href="#a的hover顺序" class="headerlink" title="a的hover顺序"></a>a的hover顺序</h2><p> <code>a:link {} a:visited {} a:hover {} a:active {}</code></p><h2 id="隐藏的几种方法"><a href="#隐藏的几种方法" class="headerlink" title="隐藏的几种方法"></a>隐藏的几种方法</h2><p>1.display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）<br>2.visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）<br>3.层级z-index<br>4.定位定到天边去吧</p><p>chrome中，使用visibility：collapse值和使用hidden没有区别。<br>firefox，opera和IE，使用collapse值和使用display：none没有什么区别。 </p><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>清浮动:伪类<br>浮动元素的display:block</p><h2 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h2><ul><li>rgba</li><li><code>background-image background-origin(content-box/padding-box/border-box) background-size background-repeat</code></li><li><code>word-wrap：break-word</code></li><li><code>text-shadow： 1px 1px 1px #666666;</code></li><li><code>border-radius</code></li><li><code>border-image: url(border.png) 30 30 round</code></li><li><code>box-shadow: 10px 10px 5px #666666</code></li><li>font-face属性：定义自己的字体</li><li>媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性</li></ul><h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><ul><li>IE6双边距bug<br>块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。</li><li><p>渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">background-color:#f1ee18;/*所有识别*/</span><br><span class="line">.background-color:#00deff9; /*IE6、7、8识别*/</span><br><span class="line">+background-color:#a200ff;/*IE6、7识别*/</span><br><span class="line">_background-color:#1e0bd1;/*IE6识别*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。<br>hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</p></li><li>IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；<br>Firefox下，只能使用getAttribute()获取自定义属性。<br>解决方法:统一通过getAttribute()获取自定义属性。</li><li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 <code>-webkit-text-size-adjust: none;</code> 解决。</li></ul><h2 id="BFC规范-块级格式化上下文：block-formatting-context"><a href="#BFC规范-块级格式化上下文：block-formatting-context" class="headerlink" title="BFC规范(块级格式化上下文：block formatting context)"></a>BFC规范(块级格式化上下文：block formatting context)</h2><p>定位方案：</p><ul><li>内部的Box会在垂直方向上一个接一个放置。</li><li>Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。</li><li>每个元素的margin box 的左边，与包含块border box的左边相接触。</li><li>BFC的区域不会与float box重叠。</li><li>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li><li>计算BFC的高度时，浮动元素也会参与计算。</li></ul><p>满足下列条件之一就可触发BFC</p><ul><li>根元素，即html</li><li>float的值不为none（默认）</li><li>overflow的值不为visible（默认）</li><li>display的值为inline-block、table-cell、table-caption</li><li>position的值为absolute或fixed</li></ul><p>举个栗子：<br>上下margin重合的问题：在重合元素外包裹一层容器，并触发该容器生成一个BFC。<code>overflow: hidden;</code></p><h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><p>一个网站能够兼容多个终端，通过媒体查询检测不同的设备屏幕尺寸做处理。<br><code>&lt;meta name=&quot;’viewport’&quot; content=&quot;”width=device-width,&quot; initial-scale=&quot;1.&quot; maximum-scale=&quot;1,user-scalable=no”&quot;/&gt;</code></p><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><ul><li><head><meta name="generator" content="Hexo 3.8.0">:<code>&lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only screen and (max-device-width:480px)”&gt;</code></head></li><li>CSS : <code>@media only screen and (max-device-width:480px)</code></li></ul><h2 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h2><p>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。<br>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p><h2 id="在网页中的应该使用奇数还是偶数的字体？为什么呢？"><a href="#在网页中的应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="在网页中的应该使用奇数还是偶数的字体？为什么呢？"></a>在网页中的应该使用奇数还是偶数的字体？为什么呢？</h2><p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p><h2 id="怎么让Chrome支持小于12px-的文字？"><a href="#怎么让Chrome支持小于12px-的文字？" class="headerlink" title="怎么让Chrome支持小于12px 的文字？"></a>怎么让Chrome支持小于12px 的文字？</h2><p>   <code>p{font-size:10px;-webkit-transform:scale(0.8);}</code></p><h2 id="让页面里的字体变清晰"><a href="#让页面里的字体变清晰" class="headerlink" title="让页面里的字体变清晰"></a>让页面里的字体变清晰</h2><p>  只在ios<code>webkit-font-smoothing：antialiased 灰度平滑</code></p><h2 id="android：position-fixed无效"><a href="#android：position-fixed无效" class="headerlink" title="android：position:fixed无效"></a>android：position:fixed无效</h2><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</code></p><h2 id="手动写动画的最小时间间隔是多久"><a href="#手动写动画的最小时间间隔是多久" class="headerlink" title="手动写动画的最小时间间隔是多久"></a>手动写动画的最小时间间隔是多久</h2><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。</p><h2 id="inline-block间隙"><a href="#inline-block间隙" class="headerlink" title="inline-block间隙"></a>inline-block间隙</h2><p>float/font-size:0、letter-spacing、word-spacing</p><h2 id="行内级元素末尾实现换行-用伪元素代替"><a href="#行内级元素末尾实现换行-用伪元素代替" class="headerlink" title="行内级元素末尾实现换行,用伪元素代替"></a>行内级元素末尾实现换行,用伪元素代替<br></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    content: "A";//0x000A,00A</span><br><span class="line">    <span class="selector-tag">white-space</span>: <span class="selector-tag">pre</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>百分比的padding和margin的依据都是父元素的width</li><li>视差滚动插件：parallax-scrolling</li><li>多行文本垂直居中：需要设置display属性为inline-block。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css tips~&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="css" scheme="http://rawraw.info/tags/css/"/>
    
  </entry>
  
</feed>
