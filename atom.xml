<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rawraw</title>
  
  <subtitle>Change not delete ！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rawraw.info/"/>
  <updated>2019-08-21T06:43:48.792Z</updated>
  <id>http://rawraw.info/</id>
  
  <author>
    <name>rawraw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何做好一份分享</title>
    <link href="http://rawraw.info/2019-08-21-share.html"/>
    <id>http://rawraw.info/2019-08-21-share.html</id>
    <published>2019-08-21T02:47:23.000Z</published>
    <updated>2019-08-21T06:43:48.792Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Stay Hungry, Stay Foolish.<br>刻意训练和精心准备，则是演讲成功的最关键的因素。<br>所谓的优秀，都是刻意训练和长期的积累在短时间内爆发出来的，大家往往只看到短时间内惊人的爆发力，却忽略了其背后的付出与努力。</p></blockquote><p><div align="center"><br><img src="/images/bg/0123.jpeg" alt="“封面”"><br></div><br><a id="more"></a></p><p>如何快速有效地提升自己。曾经，我们强调更多的是学习和思考，古语也说: 学而不思则罔，思而不学则殆。而现在，还有一种更为行之有效的方法，那就是：分享。</p><p>沟通的本质是让对方轻松地弄明白他原来并不知道的东西，更进一步，让对方通过自己已经懂的知识理解他原来并不懂的东西。</p><h4 id="Who-What-amp-When-Why-How-Future-Recap"><a href="#Who-What-amp-When-Why-How-Future-Recap" class="headerlink" title="Who-What&amp;When-Why-How-Future-Recap"></a>Who-What&amp;When-Why-How-Future-Recap</h4><ul><li><p>Who: 自我介绍，让听众了解自己，建立连接；</p></li><li><p>What&amp;When: 今天要分享的主题，通过简短介绍吸引听众的注意力、好奇心；</p></li><li><p>Why: 为什么要做这个架构改造、技术升级，整个项目的背景是什么样的，结合对听众的了解，做特定的介绍；</p></li><li><p>How: 深入浅出 3~4 个最核心的内容点，当然为了全面性，你可以都罗列出来，但介绍的重点建议控制在 3~4 项；</p></li><li><p>Future: 让大家了解你未来的计划，你对技术趋势的看法等等；</p></li><li><p>Recap: 对今天的主题再做一个回顾，让听众加深对核心内容记忆。</p></li></ul><h3 id="point1-逐字稿"><a href="#point1-逐字稿" class="headerlink" title="point1 逐字稿"></a>point1 逐字稿</h3><p>前期避免紧张必备逐字稿，充分的准备；别让正式演讲是你的第一次；时刻提醒自己要放慢语速；<br><a href="https://www.jianshu.com/p/1809a46b8a4c" target="_blank" rel="noopener">逐字稿</a></p><h3 id="point2-PPT"><a href="#point2-PPT" class="headerlink" title="point2 PPT"></a>point2 PPT</h3><p>PPT是配角，你才是主角；多图少字；<br>PPT保留keyword，只是提醒作用（照着ppt读，人家不如直接下载ppt）；正常流程，不要交互式的幻灯片；<br>流程图更能清晰地表达；</p><ul><li>Who: 1 页</li><li>What&amp;When: 1~2 页</li><li>Why: 1 页</li><li>How: 展开 3~4 点，每点 2~3 页</li><li>Future: 1 页</li><li>Recap: 1 页</li></ul><h3 id="point3-心理"><a href="#point3-心理" class="headerlink" title="point3 心理"></a>point3 心理</h3><p>紧张和焦虑感是普遍存在的，并非自己独有；<br>确信自己的分享对听众是有价值的，会让自己信心满满;</p><p>了解需求；<br>可以先引入话题，提出观点；<br>适可而止，不可贪多，知识点建议控制在三点左右，这样不仅更容易让听众记住，而且自己讲的时候也比较简单，不用担心到时候忘词；<br>不要背完整的演讲稿（实在不安可以背），记住开场和思路；<br>要提前熟悉场地，看看演讲场地的环境，了解听众座位的布局;</p><h3 id="point4-学会讲故事"><a href="#point4-学会讲故事" class="headerlink" title="point4 学会讲故事"></a>point4 学会讲故事</h3><blockquote><p>凡是能让人在脑海中产生画面感的话语或文字就是故事。</p></blockquote><p>人们在听故事的时候更容易产生共情作用，也更容易理解你想要表达的信息。</p><p>讲一个好故事的核心：给听众一个期望，然后用你讲的故事填满这个期望，让人们采用你的建议和陈述，这就是故事的核心。</p><p>赋比兴；</p><p>用自己习惯的手势配合你的演讲内容就好，但是不要手足无措，比如一会儿插兜一会儿抱胸，自己不觉得，台下听众会看得非常清楚。<br>一个非常自然的手势是“切西瓜”，伸出手臂，摊开手掌，让手掌与地面垂直，然后小幅度上下挥动。<br>不要做出夸张的身体姿势，有病哦；</p><p>（可以去看这本书《粘住》）</p><p>### </p><ul><li>收尾时要强调重点；根据心理学中的“近因效应”：人对演讲末尾部分的印象最为深刻，记忆也最为清晰。要想让听众记住你期望他记住的 2-3 个关键点，以达到分享的目的，在收尾时的总结和强调就至关重要。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Stay Hungry, Stay Foolish.&lt;br&gt;刻意训练和精心准备，则是演讲成功的最关键的因素。&lt;br&gt;所谓的优秀，都是刻意训练和长期的积累在短时间内爆发出来的，大家往往只看到短时间内惊人的爆发力，却忽略了其背后的付出与努力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0123.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node.js内存溢出</title>
    <link href="http://rawraw.info/2019-08-19-nodememory.html"/>
    <id>http://rawraw.info/2019-08-19-nodememory.html</id>
    <published>2019-08-19T02:24:09.000Z</published>
    <updated>2019-08-20T02:07:04.571Z</updated>
    
    <content type="html"><![CDATA[<p>转的整理；</p><div align="center"><br><img src="/images/bg/0139.jpeg" alt="“封面”"><br></div><a id="more"></a><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><ol><li>密集型运算；批量处理数据，大量循环；</li><li>操作的数据量较大；对象需要频繁的创建/销毁，或操作对象本身较大；</li></ol><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><h4 id="V8内存分配机制"><a href="#V8内存分配机制" class="headerlink" title="V8内存分配机制"></a>V8内存分配机制</h4><ol><li>V8本身分配的内存较小;</li><li>JavaScript语言本身限制;</li><li>程序员使用不当;</li></ol><blockquote><p>V8是 Google 在 Chrome 浏览器中使用的 JavaScript 引擎。而在浏览器环境中，运算一般不需要多大内存。<br>V8 对每个进程分配的运行内存，在32位系统中约为700MB，而在64位系统中约为1.4GB。</p></blockquote><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ol><li>使用 async/await防止事件堆积,变为同步操作； V8 获得内存回收的机会；<br>每次循环V8都会回收内存一次，因此内存不会再溢出。但这样做必然会造成运行效率的降低，而应该在速度在安全之间平衡，控制好循环的安全次数。<br>说明:实际开发中，上面这种虽然解决了内存溢出，但是仍然会造成进程阻塞，可以开启一个进程/线程来解决阻塞问题<br><a href="https://mp.weixin.qq.com/s/fkrHHMwx75NLhvv4P3rk-w" target="_blank" rel="noopener">深入理解Node.js 进程与线程</a></li><li>增加V8内存空间<br><code>node --max-old-space-size=4096 app</code></li><li>使用非V8内存<br>V8内存：数组、字符串等JavaScript内置对象，运行时使用“V8内存”<br>系统内存：Buffer是一个Node.js的扩展对象，使用底层的系统内存，不占用V8内存空间。与之相关的文件系统fs和流Stream流操作，都不会占用V8内存。<br>[fs学习]（<a href="https://mp.weixin.qq.com/s/m1SqvFaqTn3Bh2Fg9500sQ）" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/m1SqvFaqTn3Bh2Fg9500sQ）</a><br>[stream学习]（<a href="https://mp.weixin.qq.com/s/HQmualyyEV4t7lG0PZf8zQ）" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HQmualyyEV4t7lG0PZf8zQ）</a><br><a href="https://mp.weixin.qq.com/s/t5oZmD1tR5rSlJAmSlwXOg" target="_blank" rel="noopener">Buffer学习</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转的整理；&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0139.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://rawraw.info/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>webpack config</title>
    <link href="http://rawraw.info/2019-08-13-webpack.html"/>
    <id>http://rawraw.info/2019-08-13-webpack.html</id>
    <published>2019-08-13T03:18:57.000Z</published>
    <updated>2019-08-21T08:23:34.276Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="/images/bg/0128.jpeg" alt="“封面”"><br></div><a id="more"></a><h2 id="打包原理"><a href="#打包原理" class="headerlink" title="打包原理"></a>打包原理</h2><p>webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。webpack就是识别你的 入口文件。识别你的模块依赖，来打包你的代码。<br>webpack做的就是分析代码，转换代码，编译代码，输出代码。</p><p>webpack中每个模块有一个唯一的id，是从0开始递增的。整个打包后的bundle.js是一个匿名函数自执行。参数则为一个数组。数组的每一项都为个function。function的内容则为每个模块的内容，并按照require的顺序排列。</p><p>如何实现一个简单的webpack</p><ul><li>读取文件分析模块依赖</li><li>对模块进行解析执行(深度遍历)</li><li>针对不同的模块使用相应的loader</li><li>编译模块，生成抽象语法树AST。</li><li>循环遍历AST树，拼接输出js。</li></ul><p>loader原理<br>在解析对于文件，会自动去调用响应的loaderloader 本质上是一个函数，输入参数是一个字符串，输出参数也是一个字符串。当然，输出的参数会被当成是 JS 代码，从而被 esprima 解析成 AST，触发进一步的依赖解析。webpack会按照从右到左的顺序执行loader。</p><p><a href="https://www.jianshu.com/p/e24ed38d89fd" target="_blank" rel="noopener">打包原理</a></p><h2 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"></span><br><span class="line">exec(<span class="string">'git rev-parse --abbrev-ref HEAD'</span>, (_error, stdout, _stderr) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> url = stdout.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>);</span><br><span class="line">  <span class="keyword">let</span> pageUrl = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> (url === <span class="string">'master'</span>) &#123;</span><br><span class="line">    url = <span class="string">'https://api.duoxuanmall.com'</span>;</span><br><span class="line">    pageUrl = <span class="string">'https://native.duoxuanmall.com'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    url = <span class="string">'https://dailyapi.duoxuanmall.com'</span>;</span><br><span class="line">    pageUrl = <span class="string">'https://dailynative.duoxuanmall.com'</span>    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> content = <span class="string">`</span></span><br><span class="line"><span class="string">    export const rootUrl = '<span class="subst">$&#123;url&#125;</span>'</span></span><br><span class="line"><span class="string">    export const pageUrl = '<span class="subst">$&#123;pageUrl&#125;</span>'</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  fs.writeFile(<span class="string">'./config/rootUrl.js'</span>, content, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="生成的文件"><a href="#生成的文件" class="headerlink" title="[生成的文件]"></a>[生成的文件]</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> rootUrl = <span class="string">''</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> pageUrl = <span class="string">''</span></span><br></pre></td></tr></table></figure><h2 id="自定义ip"><a href="#自定义ip" class="headerlink" title="自定义ip"></a>自定义ip</h2><p><code>&quot;dev&quot;: &quot;node bin/get_enviroment.js &amp;&amp; webpack-dev-server --config ./webpack.config.js --host 192.168.7.236 --port 8086&quot;,</code></p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0128.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://rawraw.info/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>serverlees无服务器架构</title>
    <link href="http://rawraw.info/2019-08-13-serverlees.html"/>
    <id>http://rawraw.info/2019-08-13-serverlees.html</id>
    <published>2019-08-13T02:50:25.000Z</published>
    <updated>2019-08-20T02:07:04.573Z</updated>
    
    <content type="html"><![CDATA[<p>学不动了学不动了</p><div align="center"><br><img src="/images/bg/0129.jpeg" alt="“封面”"><br></div><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/6lULH06QfNx0FOMwAglZGg" target="_blank" rel="noopener">开发历史</a></p><h2 id="serverlees"><a href="#serverlees" class="headerlink" title="serverlees"></a>serverlees</h2><p>无服务器是一种学说，而不是技术</p><p><a href="https://www.jdon.com/soa/serverless.html" target="_blank" rel="noopener">概念</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学不动了学不动了&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0129.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="serverlees" scheme="http://rawraw.info/tags/serverlees/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript要仔细学之三//阻止事件</title>
    <link href="http://rawraw.info/2019-07-29-js03.html"/>
    <id>http://rawraw.info/2019-07-29-js03.html</id>
    <published>2019-07-29T01:43:05.000Z</published>
    <updated>2019-08-20T02:08:49.566Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈 这么久了，用是会用，居然迷迷糊糊，这次千万记住咯～</p><p><div align="center"><br><img src="/images/bg/0177.jpg" alt="“封面”"><br></div><br><a id="more"></a></p><h3 id="event-stopPropagation-方法"><a href="#event-stopPropagation-方法" class="headerlink" title="event.stopPropagation()方法"></a>event.stopPropagation()方法</h3><blockquote><p>这是阻止事件的冒泡方法，不让事件向documen上层蔓延，但是默认事件任然会执行，当你调用这个方法的时候，如果点击一个连接，这个连接仍然会被打开。</p></blockquote><h3 id="event-preventDefault-方法"><a href="#event-preventDefault-方法" class="headerlink" title="event.preventDefault()方法"></a>event.preventDefault()方法</h3><blockquote><p>这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素，此方法可以控制一些按钮在点击时只触发时间而不会引起表单的提交。</p></blockquote><h3 id="return-false；"><a href="#return-false；" class="headerlink" title="return false；"></a>return false；</h3><blockquote><p>同时阻止事件冒泡也会阻止默认事件；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault()</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈哈 这么久了，用是会用，居然迷迷糊糊，这次千万记住咯～&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0177.jpg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="JavaScript" scheme="http://rawraw.info/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>小程序内置webview调试工具</title>
    <link href="http://rawraw.info/2019-07-27-vconsole.html"/>
    <id>http://rawraw.info/2019-07-27-vconsole.html</id>
    <published>2019-07-27T06:24:24.000Z</published>
    <updated>2019-08-20T02:07:04.574Z</updated>
    
    <content type="html"><![CDATA[<p>webview页面调试工具</p><div align="center"><br><img src="/images/bg/0166.jpg" alt="“封面”"><br></div><a id="more"></a><p>1.<code>yarn add vConsole</code><br>2.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VConsole <span class="keyword">from</span> <span class="string">'vconsole/dist/vconsole.min.js'</span></span><br><span class="line"><span class="keyword">let</span> vConsole = <span class="keyword">new</span> VConsole() <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webview页面调试工具&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0166.jpg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="tool" scheme="http://rawraw.info/categories/tool/"/>
    
    
      <category term="vconsole" scheme="http://rawraw.info/tags/vconsole/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli</title>
    <link href="http://rawraw.info/2019-07-18-vue-cli.html"/>
    <id>http://rawraw.info/2019-07-18-vue-cli.html</id>
    <published>2019-07-18T07:08:51.000Z</published>
    <updated>2019-08-20T02:07:04.574Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="/images/bg/0106.jpeg" alt="“封面”"><br></div><a id="more"></a><h1 id="vue-cli3"><a href="#vue-cli3" class="headerlink" title="vue-cli3"></a>vue-cli3</h1><h3 id="一直运行-sockjs-node-info-t-解决方案"><a href="#一直运行-sockjs-node-info-t-解决方案" class="headerlink" title="一直运行 /sockjs-node/info?t= 解决方案"></a>一直运行 /sockjs-node/info?t= 解决方案</h3><p> sockjs-node 是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟、全双工的浏览器和web服务器之间通信通道。</p><p>服务端：sockjs-node（<a href="https://github.com/sockjs/sockjs-node）" target="_blank" rel="noopener">https://github.com/sockjs/sockjs-node）</a><br>客户端：sockjs-clien（<a href="https://github.com/sockjs/sockjs-client）" target="_blank" rel="noopener">https://github.com/sockjs/sockjs-client）</a></p><p>如果你的项目没有用到 sockjs，vuecli3 运行 yarn serve 之后 network 里面一直调研一个接口：<a href="http://localhost:8080/sockjs-node/info?t=1462183700002" target="_blank" rel="noopener">http://localhost:8080/sockjs-node/info?t=1462183700002</a></p><p>源码关闭：</p><p>找到<code>/node_modules/sockjs-client/dist/sockjs.js</code>第1605行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//  self.xhr.send(payload); 把这里注掉</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  self.emit(<span class="string">'finish'</span>, <span class="number">0</span>, <span class="string">''</span>);</span><br><span class="line">  self._cleanup(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0106.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="note" scheme="http://rawraw.info/categories/note/"/>
    
    
      <category term="vue" scheme="http://rawraw.info/tags/vue/"/>
    
      <category term="vue-cli" scheme="http://rawraw.info/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>小程序们taro</title>
    <link href="http://rawraw.info/2019-07-18-mini-program.html"/>
    <id>http://rawraw.info/2019-07-18-mini-program.html</id>
    <published>2019-07-18T03:38:42.000Z</published>
    <updated>2019-08-20T02:07:04.571Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="/images/bg/0015.jpeg" alt="“封面”"><br></div><a id="more"></a><h4 id="微信小程序转taro"><a href="#微信小程序转taro" class="headerlink" title="微信小程序转taro"></a>微信小程序转taro</h4><p><code>$ taro convert</code></p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0015.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="taro" scheme="http://rawraw.info/tags/taro/"/>
    
  </entry>
  
  <entry>
    <title>快应用</title>
    <link href="http://rawraw.info/2019-07-18-pwa.html"/>
    <id>http://rawraw.info/2019-07-18-pwa.html</id>
    <published>2019-07-18T03:37:38.000Z</published>
    <updated>2019-08-20T02:07:04.572Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://doc.quickapp.cn/" target="_blank" rel="noopener">参考</a></p><div align="center"><br><img src="/images/bg/0172.jpg" alt="“封面”"><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://doc.quickapp.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0172.jpg&quot; alt=&quot;
      
    
    </summary>
    
    
      <category term="pwa" scheme="http://rawraw.info/tags/pwa/"/>
    
  </entry>
  
  <entry>
    <title>chorme扩展工具</title>
    <link href="http://rawraw.info/2019-07-18-chorme-extend.html"/>
    <id>http://rawraw.info/2019-07-18-chorme-extend.html</id>
    <published>2019-07-18T03:32:11.000Z</published>
    <updated>2019-08-20T02:07:04.569Z</updated>
    
    <content type="html"><![CDATA[<p>换了台笔记本，vpn也上不去了。只能瞎搞了。</p><div align="center"><br><img src="/images/bg/0140.jpeg" alt="“封面”"><br></div><a id="more"></a><h1 id="React-Devtools调试工具"><a href="#React-Devtools调试工具" class="headerlink" title="React Devtools调试工具"></a>React Devtools调试工具</h1><h2 id="Git-地址"><a href="#Git-地址" class="headerlink" title="Git 地址"></a>Git 地址</h2><p><a href="https://github.com/facebook/react-devtools`" target="_blank" rel="noopener">Git 地址</a></p><p><code>git clone https://github.com/facebook/react-devtools.git</code></p><h2 id="进入react-devtools文件夹，安装依赖"><a href="#进入react-devtools文件夹，安装依赖" class="headerlink" title="进入react-devtools文件夹，安装依赖"></a>进入react-devtools文件夹，安装依赖</h2><p><code>npm --registry https://registry.npm.taobao.org install</code></p><h2 id="打包一份扩展程序"><a href="#打包一份扩展程序" class="headerlink" title="打包一份扩展程序"></a>打包一份扩展程序</h2><p><code>npm run build:extension:chrome</code><br>项目目录中生成一个新的文件夹，<code>react-devtools -&gt; shells -&gt; chrome -&gt; build -&gt; unpacked</code>文件夹</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>打开chrome扩展程序chrome://extensions/，加载已解压的扩展程序，选择第3步中的生成的unpacked文件夹。</p><h1 id="vue-devtools"><a href="#vue-devtools" class="headerlink" title="vue-devtools"></a>vue-devtools</h1><h2 id="https-github-com-vuejs-vue-devtools"><a href="#https-github-com-vuejs-vue-devtools" class="headerlink" title="https://github.com/vuejs/vue-devtools"></a><a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">https://github.com/vuejs/vue-devtools</a></h2><p><code>git clone https://github.com/vuejs/vue-devtools.git</code><br><code>npm i</code><br>修改manifest.json文件<br>把”persistent”:false改成true<br><code>npm run build</code><br>选择vue-devtools&gt;shells下的chrome文件夹</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;换了台笔记本，vpn也上不去了。只能瞎搞了。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0140.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图床工具</title>
    <link href="http://rawraw.info/2019-07-18-picgo.html"/>
    <id>http://rawraw.info/2019-07-18-picgo.html</id>
    <published>2019-07-18T03:30:35.000Z</published>
    <updated>2019-08-20T02:07:04.572Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/9d91355e8418" target="_blank" rel="noopener">参考</a></p><div align="center"><br><img src="/images/bg/0114.jpeg" alt="“封面”"><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/9d91355e8418&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微信公众号开发注意事项</title>
    <link href="http://rawraw.info/2019-07-18-wx.html"/>
    <id>http://rawraw.info/2019-07-18-wx.html</id>
    <published>2019-07-18T03:27:49.000Z</published>
    <updated>2019-08-20T02:07:04.576Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="/images/bg/0147.jpeg" alt="“封面”"><br></div><a id="more"></a><h2 id="Input-fix"><a href="#Input-fix" class="headerlink" title="Input fix"></a>Input fix</h2><p><a href="https://blog.csdn.net/weixin_39579517/article/details/88397759" target="_blank" rel="noopener">参考</a></p><p>Fix 不能设置 top0</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0147.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="wx" scheme="http://rawraw.info/tags/wx/"/>
    
  </entry>
  
  <entry>
    <title>Vultr 搭建 SSR </title>
    <link href="http://rawraw.info/2019-07-18-ssr.html"/>
    <id>http://rawraw.info/2019-07-18-ssr.html</id>
    <published>2019-07-18T03:26:40.000Z</published>
    <updated>2019-08-20T02:07:04.573Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5bbdbffcf265da0ac2568a80" target="_blank" rel="noopener">参考</a><br><a href="https://idc.wanyunshuju.com/li/548.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5bbdbffcf265da0ac2568a80&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://idc.wanyunshuju.com/l
      
    
    </summary>
    
    
      <category term="ssr" scheme="http://rawraw.info/tags/ssr/"/>
    
  </entry>
  
  <entry>
    <title>ssh哦</title>
    <link href="http://rawraw.info/2019-07-18-ssh.html"/>
    <id>http://rawraw.info/2019-07-18-ssh.html</id>
    <published>2019-07-18T03:07:55.000Z</published>
    <updated>2019-08-20T02:07:04.573Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br><img src="/images/bg/0171.jpg" alt="“封面”"><br></div><br><a id="more"></a></p><h4 id="检查-ssh文件夹是否存在"><a href="#检查-ssh文件夹是否存在" class="headerlink" title="检查.ssh文件夹是否存在"></a>检查.ssh文件夹是否存在</h4><p><code>$ ls -al ~/.ssh</code></p><h4 id="不存在"><a href="#不存在" class="headerlink" title="不存在"></a>不存在</h4><p>新建.ssh文件夹<br><code>$ mkdir ~/.ssh</code><br><code>$ cd ~/.ssh</code><br><code>$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code><br>连续按三次回车<code>id_rsa   id_rsa.pub</code></p><h4 id="查看公钥"><a href="#查看公钥" class="headerlink" title="查看公钥"></a>查看公钥</h4><p><code>$ cat id_rsa.pub</code></p><h4 id="将密钥复制到剪贴板"><a href="#将密钥复制到剪贴板" class="headerlink" title="将密钥复制到剪贴板"></a>将密钥复制到剪贴板</h4><p><code>pbcopy &lt; ~/.ssh/id_rsa.pub</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0171.jpg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="ssh" scheme="http://rawraw.info/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>vue集合</title>
    <link href="http://rawraw.info/2019-05-20-vue.html"/>
    <id>http://rawraw.info/2019-05-20-vue.html</id>
    <published>2019-05-20T06:38:18.000Z</published>
    <updated>2019-08-20T02:07:04.575Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><img src="/images/bg/0163.jpeg" alt="“封面”"><br></div><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h3 id="数据双向绑定"><a href="#数据双向绑定" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h3><p>Vue3之前通过get和set完成，而Vue3后通过proxy来完成。</p><h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>一个内部的json字符串。</p><h1 id="bugs"><a href="#bugs" class="headerlink" title="bugs"></a>bugs</h1><h3 id="for中的key"><a href="#for中的key" class="headerlink" title="for中的key"></a>for中的key</h3><font color="red">[Vue warn]: Error in render: “TypeError: _self.$scopedSlots.default is not a function”</font><blockquote><p>究其原因，是因为表格是element-ui通过循环产生的，而vue在dom重新渲染时有一个性能优化机制，就是相同dom会被复用，这就是问题所在，所以，通过key去标识一下当前行是唯一的，不许复用，就行了。</p></blockquote><p>方案：添加 <font color="red">:key=”Math.random()”</font></p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if / v-show"></a>v-if / v-show</h4><p><code>v-if</code>:惰性;切换过程中条件块内的事件监听器和子组件适当地被销毁和重建;<br><code>v-show</code>:不管初始条件是什么，元素总是会被渲染;<br>v-if 适用于在运行时不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h4 id="computed-watch"><a href="#computed-watch" class="headerlink" title="computed / watch"></a>computed / watch</h4><p><code>computed</code>： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；<br><code>watch</code>： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br>computed适用于需要进行数值计算，并且依赖于其它数据时；因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>watch适用于需要在数据变化时执行异步或开销较大的操作时；使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h4 id="v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h4><ol><li>v-for 遍历必须为 item 添加 key<br>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</li><li>v-for 遍历避免同时使用 v-if<br>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。<br>百度小程序里面for和if同时使用是直接语法报错的；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div</span><br><span class="line">v-<span class="keyword">for</span>=<span class="string">"(key,obj) in lists"</span></span><br><span class="line">:key=<span class="string">"key"</span>&gt;</span><br><span class="line">&#123;&#123; obj.name &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">computed: &#123;</span></span><br><span class="line"><span class="regexp">  lists: function () &#123;</span></span><br><span class="line"><span class="regexp">    return this.lists.filter(function (list) &#123;</span></span><br><span class="line"><span class="regexp">        return list.isActive</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><h5 id="图片资源懒加载"><a href="#图片资源懒加载" class="headerlink" title="图片资源懒加载"></a>图片资源懒加载</h5><ol><li>插件：<code>yarn add vue-lazyload --save-dev</code></li><li><figure class="highlight js"><figcaption><span>[main.js]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyload <span class="keyword">from</span> <span class="string">'vue-lazyload'</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueLazyload)</span><br><span class="line">or</span><br><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">    preLoad: <span class="number">1.3</span>,</span><br><span class="line">    error: <span class="string">'dist/error.png'</span>,</span><br><span class="line">    loading: <span class="string">'dist/loading.gif'</span>,</span><br><span class="line">    attempt: <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>vue文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"/static/img/1.png"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h5><ol><li>首屏加载问题；<br><code>const goodslist = () =&gt; import( /* webpackChunkName: &quot;trade&quot; */ &#39;./views/Goodslist.vue&#39;);</code></li><li>服务端渲染 SSR/预渲染<br>SSR:重点优化的场景；<br>预渲染:少量页面优化；在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。</li></ol><h4 id="第三方插件的按需引入"><a href="#第三方插件的按需引入" class="headerlink" title="第三方插件的按需引入"></a>第三方插件的按需引入</h4><ol><li><code>yarn add babel-plugin-component -D</code></li><li><figure class="highlight js"><figcaption><span>[.babelrc]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [[<span class="string">"es2015"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight js"><figcaption><span>[main.js]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button,&#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br></pre></td></tr></table></figure></li></ol><h4 id="长列表性能优化"><a href="#长列表性能优化" class="headerlink" title="长列表性能优化"></a>长列表性能优化</h4><ol><li>Vue 会通过 <code>Object.defineProperty</code>对数据进行劫持，来实现视图响应数据的变化;纯粹的数据展示，不会做任何修改的数据可以通过 Object.freeze 方法来冻结一个对象；<br><code>this.lists = Object.freeze(lists);</code></li><li>无限列表性能;<code>vue-virtual-scroll-list 和 vue-virtual-scroller</code></li></ol><h4 id="事件的销毁"><a href="#事件的销毁" class="headerlink" title="事件的销毁"></a>事件的销毁</h4><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><ol><li><code>yarn add image-webpack-loader --save-dev</code></li><li><figure class="highlight js"><figcaption><span>[webpack.base.conf.js]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: <span class="number">10000</span>,</span><br><span class="line">      name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="减少-ES6-转为-ES5-的冗余代码"><a href="#减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="减少 ES6 转为 ES5 的冗余代码"></a>减少 ES6 转为 ES5 的冗余代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ES6 转为 ES5,需要以下两个辅助函数：</span><br><span class="line">babel-runtime/helpers/createClass  // 用于实现 class 语法</span><br><span class="line">babel-runtime/helpers/inherits  // 用于实现 extends 语法</span><br></pre></td></tr></table></figure><p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。</p><ol><li><code>yarn add babel-plugin-transform-runtime --save-dev</code></li><li><figure class="highlight js"><figcaption><span>[.babelrc]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-runtime"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><h4 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h4><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p><ul><li>相同的资源被重复加载，浪费用户的流量和服务器的成本。</li><li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。<br>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'vendor'</span>,</span><br><span class="line">  minChunks: <span class="function"><span class="keyword">function</span>(<span class="params">module, count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">      <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">        path.join(__dirname, <span class="string">'../node_modules'</span>)</span><br><span class="line">      ) === <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 抽取出代码模块的映射关系</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'manifest'</span>,</span><br><span class="line">  chunks: [<span class="string">'vendor'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="模版预编译"><a href="#模版预编译" class="headerlink" title="模版预编译"></a>模版预编译</h4><p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。<br>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。<br>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p><h4 id="提取组件的-CSS"><a href="#提取组件的-CSS" class="headerlink" title="提取组件的 CSS"></a>提取组件的 CSS</h4><p>当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。<br>查阅这个构建工具各自的文档来了解更多：</p><ul><li>webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)</li><li>Browserify + vueify</li><li>Rollup + rollup-plugin-vue</li></ul><h4 id="优化-SourceMap"><a href="#优化-SourceMap" class="headerlink" title="优化 SourceMap"></a>优化 SourceMap</h4><p>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。<br>SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ）<br>开发环境推荐：<code>cheap-module-eval-source-map</code><br>生产环境推荐：<code>cheap-module-source-map</code><br>原因如下：</p><ul><li>cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</li><li>module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</li><li>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；</li><li>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</li></ul><h4 id="构建结果输出分析"><a href="#构建结果输出分析" class="headerlink" title="构建结果输出分析"></a>构建结果输出分析</h4><p>vue-cli2:<br><code>webpack-bundle-analyzer</code><br><figure class="highlight js"><figcaption><span>[webpack.prod.conf.js]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  <span class="keyword">var</span> BundleAnalyzerPlugin =   <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line">  webpackConfig.plugins.push(<span class="keyword">new</span> BundleAnalyzerPlugin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>yarn run build --report</code><br>vue-cli3:<br><figure class="highlight js"><figcaption><span>[vue.config.js]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    chainWebpack:<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// config.moudle</span></span><br><span class="line">        <span class="comment">//     .rule('vue')</span></span><br><span class="line">        <span class="comment">//     .user('vue-loader')</span></span><br><span class="line">        <span class="comment">//     .loader('vue-loader')</span></span><br><span class="line">        <span class="comment">//     .tap(options=&gt;&#123;</span></span><br><span class="line">        <span class="comment">//         //update</span></span><br><span class="line">        <span class="comment">//         return options</span></span><br><span class="line">        <span class="comment">//     &#125;)</span></span><br><span class="line">        <span class="comment">// Examples</span></span><br><span class="line">        <span class="comment">//config</span></span><br><span class="line">        <span class="comment">// .plugin('hot')</span></span><br><span class="line">        <span class="comment">// .use(webpack.HotModuleReplacementPlugin);</span></span><br><span class="line">        <span class="comment">// config</span></span><br><span class="line">        <span class="comment">// .plugin('env')</span></span><br><span class="line">        <span class="comment">// .use(webpack.EnvironmentPlugin, ['NODE_ENV']);</span></span><br><span class="line">        config</span><br><span class="line">        .plugin(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">        .use(<span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>if (process.env.npm_config_report) {<br>  // …<br>}<br><figure class="highlight js"><figcaption><span>[package.json]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"analyz"</span>: <span class="string">"npm_config_report=true npm run build"</span></span><br></pre></td></tr></table></figure></p><h2 id="基础web"><a href="#基础web" class="headerlink" title="基础web"></a>基础web</h2><h4 id="开启-gzip-压缩"><a href="#开启-gzip-压缩" class="headerlink" title="开启 gzip 压缩"></a>开启 gzip 压缩</h4><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右</p><ol><li><code>yarn add compression --save</code></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compression = <span class="built_in">require</span>(<span class="string">'compression'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(compression())</span><br></pre></td></tr></table></figure></li><li><p>重启服务，观察网络面板里面的 response header，如果看到content-encoding的字段则表明 gzip 开启成功;</p><h4 id="浏览器缓存-静态资源进行缓存"><a href="#浏览器缓存-静态资源进行缓存" class="headerlink" title="浏览器缓存;静态资源进行缓存"></a>浏览器缓存;静态资源进行缓存</h4><h4 id="CDN-的使用"><a href="#CDN-的使用" class="headerlink" title="CDN 的使用"></a>CDN 的使用</h4><h4 id="Chrome-Performance-查找性能瓶颈"><a href="#Chrome-Performance-查找性能瓶颈" class="headerlink" title="Chrome Performance 查找性能瓶颈"></a>Chrome Performance 查找性能瓶颈</h4></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/bg/0163.jpeg&quot; alt=&quot;“封面”&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="vue" scheme="http://rawraw.info/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>依赖包管理npm、yarn</title>
    <link href="http://rawraw.info/2019-05-16-yarn.html"/>
    <id>http://rawraw.info/2019-05-16-yarn.html</id>
    <published>2019-05-16T08:31:30.000Z</published>
    <updated>2019-05-20T04:29:52.727Z</updated>
    
    <content type="html"><![CDATA[<p>npm和yarn区别<br><a id="more"></a></p><h1 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h1><p>Yarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化；<br>Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。就像我们可以从官方文档了解那样，它的目的是解决这些团队使用 npm 面临的少数问题，即：</p><ul><li>安装的时候无法保证速度/一致性</li><li>安全问题，因为 npm 安装时允许运行代码</li></ul><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ul><li>yarn.lock 文件</li><li>并行安装<br>每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。</li><li>清晰的输出<br>npm 默认情况下非常冗余，例如使用 npm install 时它会递归列出所有安装的信息；而 Yarn 则一点也不冗余，当可以使用其它命令时，它适当的使用 emojis 表情来减少信息（Windows 除外）。</li></ul><h1 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h1><p>可阅读pnpm的作者Zoltan Kochan发表的<a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener">“为什么要用pnpm？”</a></p><ul><li>pnpm运行起来非常的快，超过了npm和yarn</li><li>pnpm采用了一种巧妙的方法，利用硬链接和符号链接来避免复制所有本地缓存源文件，这是yarn的最大的性能弱点之一</li><li>使用链接并不容易，会带来一堆问题需要考虑。</li><li>pnpm继承了yarn的所有优点，包括离线模式和确定性安装</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm和yarn区别&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="npm" scheme="http://rawraw.info/tags/npm/"/>
    
      <category term="yarn" scheme="http://rawraw.info/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>nginx正向代理和反向代理</title>
    <link href="http://rawraw.info/2019-05-16-nginx.html"/>
    <id>http://rawraw.info/2019-05-16-nginx.html</id>
    <published>2019-05-16T07:01:47.000Z</published>
    <updated>2019-05-20T04:31:02.147Z</updated>
    
    <content type="html"><![CDATA[<p>nginx正向代理和反向代理<br><a id="more"></a></p><p>正向代理的代理对象是客户端,反向代理的代理对象是服务端。</p><p><a href="https://www.cnblogs.com/crazylqy/p/7150580.html" target="_blank" rel="noopener">参考</a></p><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向代理:客户端 &lt;一&gt; 代理 一&gt;服务端</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>反向代理:客户端 一&gt;代理 &lt;一&gt; 服务端</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx正向代理和反向代理&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="nginx" scheme="http://rawraw.info/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>跨浏览器开发</title>
    <link href="http://rawraw.info/2019-05-16-browser.html"/>
    <id>http://rawraw.info/2019-05-16-browser.html</id>
    <published>2019-05-16T06:09:30.000Z</published>
    <updated>2019-05-16T08:44:27.542Z</updated>
    
    <content type="html"><![CDATA[<p>重点：要脱离前端类库的跨浏览器开发</p><a id="more"></a><ul><li>css reset</li><li>Polyfill抚平不同浏览器之间对js实现的差异。</li></ul><p>Selenium是前端工具 测试<br>IETester让您查看 不同IE版本的页面<br>Browsershots让你看看 不同平台上的页面<br>Google让您搜索已知且模糊的IE变态<br>IE 6 No More为您节省了很多麻烦，而不用担心IE 6这个名字的史前垃圾。<br>YUI Graded Browser Support - 确保您知道要关注哪些浏览器<br>jQquery跨浏览器javascript库<br>YUI 3: Reset CSS重置您的CSS(链接包含有用的信息以及CSS)<br>9 Most Common IE Bugs and How to Fix Them非常有用的提示，如何通过先解决常见问题来获得最大的收益。<br>Cross browser development包含许多有关跨浏览器开发的有用教程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重点：要脱离前端类库的跨浏览器开发&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="browser" scheme="http://rawraw.info/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>跨终端开发</title>
    <link href="http://rawraw.info/2019-05-16-client.html"/>
    <id>http://rawraw.info/2019-05-16-client.html</id>
    <published>2019-05-16T06:07:49.000Z</published>
    <updated>2019-05-16T06:08:49.362Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flutter&lt;/p&gt;

      
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="跨终端" scheme="http://rawraw.info/tags/%E8%B7%A8%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>OSI七层模型与TCP/IP四层模型</title>
    <link href="http://rawraw.info/2019-05-16-osi.html"/>
    <id>http://rawraw.info/2019-05-16-osi.html</id>
    <published>2019-05-16T02:58:23.000Z</published>
    <updated>2019-05-16T03:02:47.692Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jingyan.baidu.com/article/00a07f387b7e0682d028dce2.html" target="_blank" rel="noopener">OSI七层模型与TCP/IP四层模型参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/00a07f387b7e0682d028dce2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OSI七层模型与TCP/IP四层模型参考&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Note" scheme="http://rawraw.info/categories/Note/"/>
    
    
      <category term="OSI" scheme="http://rawraw.info/tags/OSI/"/>
    
      <category term="TCP" scheme="http://rawraw.info/tags/TCP/"/>
    
  </entry>
  
</feed>
